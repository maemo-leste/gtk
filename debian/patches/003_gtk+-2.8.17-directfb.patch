diff -ruN old/configure.in gtk+/configure.in
--- old/configure.in	2006-04-01 19:38:17.000000000 +0200
+++ gtk+/configure.in	2006-06-13 23:47:24.000000000 +0200
@@ -224,13 +224,13 @@
   gdktarget=x11
 fi
 
-AC_ARG_WITH(gdktarget, [  --with-gdktarget=[[x11/linux-fb/win32]] select non-default GDK target],
+AC_ARG_WITH(gdktarget, [  --with-gdktarget=[[x11/linux-fb/directfb/win32]] select non-default GDK target],
 	gdktarget=$with_gdktarget)
 
 AC_SUBST(gdktarget)
 case $gdktarget in
-  x11|linux-fb|win32) ;;
-  *) AC_MSG_ERROR([Invalid target for GDK: use x11, linux-fb or win32.]);;
+  x11|linux-fb|directfb|win32) ;;
+  *) AC_MSG_ERROR([Invalid target for GDK: use x11, linux-fb, directfb or win32.]);;
 esac
 
 gdktargetlib=libgdk-$gdktarget-$GTK_API_VERSION.la
@@ -1353,6 +1353,27 @@
   AM_CONDITIONAL(ENABLE_FB_MANAGER, false)
 fi
 
+if test "x$gdktarget" = "xdirectfb"; then
+  DIRECTFB_REQUIRED_VERSION=0.9.21
+  AC_MSG_CHECKING(for DirectFB)
+
+  if $PKG_CONFIG --atleast-version $DIRECTFB_REQUIRED_VERSION directfb ; then
+      AC_MSG_RESULT(found)
+      GDK_EXTRA_CFLAGS="`$PKG_CONFIG --cflags directfb cairo-directfb` $GDK_EXTRA_CFLAGS"
+      GDK_EXTRA_LIBS="`$PKG_CONFIG --libs directfb cairo-directfb` $GDK_EXTRA_LIBS"
+  else
+      AC_MSG_ERROR([
+*** DirectFB $DIRECTFB_REQUIRED_VERSION or newer is required. The latest
+*** version of DirectFB is always available from http://www.directfb.org/.
+  ])
+  fi
+
+  AM_CONDITIONAL(USE_DIRECTFB, true)
+else
+  AM_CONDITIONAL(USE_DIRECTFB, false)
+fi
+
+
 # Check for Pango flags
 
 if test "x$gdktarget" = "xwin32"; then
@@ -1570,6 +1591,9 @@
   gdk_windowing='
 #define GDK_WINDOWING_FB
 #define GDK_NATIVE_WINDOW_POINTER'
+elif test "x$gdktarget" = "xdirectfb" ; then
+  gdk_windowing='
+#define GDK_WINDOWING_DIRECTFB'
 fi
 
 if test x$gdk_wchar_h = xyes; then
@@ -1626,6 +1650,7 @@
 gdk/win32/rc/Makefile
 gdk/win32/rc/gdk.rc
 gdk/linux-fb/Makefile
+gdk/directfb/Makefile
 gtk/Makefile
 gtk/makefile.msc
 gtk/gtkversion.h
diff -ruN old/docs/tools/Makefile.am gtk+/docs/tools/Makefile.am
--- old/docs/tools/Makefile.am	2005-08-22 16:44:39.000000000 +0200
+++ gtk+/docs/tools/Makefile.am	2006-06-13 23:46:23.000000000 +0200
@@ -17,7 +17,7 @@
 	$(top_builddir)/gtk/$(gtktargetlib)				\
 	$(GTK_DEP_LIBS)
 
-if OS_UNIX
+if USE_X11
 noinst_PROGRAMS = 		\
 	doc-shooter
 endif
diff -ruN old/gdk/Makefile.am gtk+/gdk/Makefile.am
--- old/gdk/Makefile.am	2005-10-26 20:02:28.000000000 +0200
+++ gtk+/gdk/Makefile.am	2006-06-13 23:46:23.000000000 +0200
@@ -1,7 +1,7 @@
 ## Makefile.am for gtk+/gdk
 
 SUBDIRS = $(gdktarget)
-DIST_SUBDIRS = linux-fb win32 x11
+DIST_SUBDIRS = directfb linux-fb win32 x11
 
 EXTRA_DIST =			\
 	keynames.txt		\
@@ -134,6 +134,11 @@
 	gdkenumtypes.c		\
 	gdkmarshalers.h
 
+libgdk_directfb_2_0_la_SOURCES = $(common_sources) 
+libgdk_directfb_2_0_la_LIBADD = directfb/libgdk-directfb.la $(GDK_DEP_LIBS) \
+  $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
+libgdk_directfb_2_0_la_LDFLAGS = $(LDADD)
+
 libgdk_x11_2_0_la_SOURCES = $(common_sources)
 libgdk_x11_2_0_la_LIBADD = x11/libgdk-x11.la $(GDK_DEP_LIBS) \
   $(top_builddir)/gdk-pixbuf/libgdk_pixbuf-$(GTK_API_VERSION).la
@@ -198,7 +203,7 @@
 
 lib_LTLIBRARIES = $(gdktargetlib)
 
-EXTRA_LTLIBRARIES = libgdk-x11-2.0.la libgdk-linux-fb-2.0.la libgdk-win32-2.0.la
+EXTRA_LTLIBRARIES = libgdk-x11-2.0.la libgdk-directfb-2.0.la libgdk-linux-fb-2.0.la libgdk-win32-2.0.la
 
 MAINTAINERCLEANFILES = gdkenumtypes.h stamp-gdkenumtypes.h gdkenumtypes.c \
   gdkmarshalers.h gdkmarshalers.c
diff -ruN old/gdk/directfb/AUTHORS gtk+/gdk/directfb/AUTHORS
--- old/gdk/directfb/AUTHORS	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/AUTHORS	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,28 @@
+The GDK DirectFB backend was written by
+
+ Denis Oliver Kropp <dok@directfb.org>
+ Sven Neumann <neo@directfb.org>
+
+Large parts of the code are based on other GDK backends
+especially the linuxfb backend which was written mainly
+by Alex Larsson <alexl@redhat.com>.
+
+
+The upgrade to gtk 2.8.x was done by 
+
+ Michael Emmel <mike.emmel@gmail.com>
+
+
+Extensive help and support and code was recieved from the Debian
+community especially the Debian installer team who bravely chose to
+use the gdk directfb port for the graphical debian installer. In
+particular
+
+ Attilio Fiandrotti <fiandro@tiscalinet.it>
+ Davide Viti <zinosat@tiscali.it>
+
+for there tireless work bringing the backend from a small project to
+stability.
+
+And finally thanks to the Extremadura goverment for bringing the
+directfb developers and debian installer team together for a workshop.
diff -ruN old/gdk/directfb/Makefile.am gtk+/gdk/directfb/Makefile.am
--- old/gdk/directfb/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/Makefile.am	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,56 @@
+## Makefile.am for gtk+/gdk/gdk-directfb
+
+libgdkincludedir = $(includedir)/gtk-2.0/gdk
+
+INCLUDES = 		\
+	-DG_LOG_DOMAIN=\"Gdk-DirectFB\"	\
+	-I$(top_srcdir)			\
+	-I$(top_srcdir)/gdk		\
+	-I$(top_builddir)/gdk		\
+	-DG_DISABLE_DEPRECATED		\
+	-DGDK_PIXBUF_DISABLE_DEPRECATED	\
+	-DGDK_DISABLE_DEPRECATED	\
+	@GTK_DEBUG_FLAGS@		\
+	@GDK_DEP_CFLAGS@		
+
+LDADDS = 		\
+	@GDK_DEP_LIBS@		
+
+noinst_LTLIBRARIES = libgdk-directfb.la
+
+libgdk_directfb_la_SOURCES =	\
+	gdkcolor-directfb.c	\
+	gdkcursor-directfb.c	\
+	gdkdnd-directfb.c	\
+	gdkdisplay-directfb.c   \
+	gdkdisplay-directfb.h   \
+	gdkdrawable-directfb.c	\
+	gdkevents-directfb.c	\
+	gdkfont-directfb.c	\
+	gdkgc-directfb.c	\
+	gdkgeometry-directfb.c	\
+	gdkglobals-directfb.c	\
+	gdkim-directfb.c	\
+	gdkimage-directfb.c	\
+	gdkinput-directfb.c	\
+	gdkinput-directfb.h	\
+	gdkkeys-directfb.c	\
+	gdkmain-directfb.c	\
+	gdkpixmap-directfb.c	\
+	gdkprivate-directfb.h	\
+	gdkproperty-directfb.c	\
+	gdkscreen-directfb.c	\
+	gdkselection-directfb.c	\
+	gdkspawn-directfb.c     \
+	gdkvisual-directfb.c	\
+	gdkdirectfb.h		\
+	gdkwindow-directfb.c	\
+	gdkwindowid.c		\
+	x-cursors.xbm
+
+libgdkinclude_HEADERS =		\
+	gdkdirectfb.h 		\
+	gdkprivate-directfb.h
+
+
+EXTRA_DIST = AUTHORS README TODO 
diff -ruN old/gdk/directfb/README gtk+/gdk/directfb/README
--- old/gdk/directfb/README	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/README	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,106 @@
+README for GDK-DirectFB
+------------------------
+
+This is the GDK backend that allows GTK to work on top of DirectFB.
+
+Important:
+The current code does not pass through directfb passed on the gtk
+apps command line on to directfb you need to set the environment variable
+DFBARGS.
+Example:
+export DFBARGS=system=sdl
+
+DirectFB is a hardware abstraction layer on top of the Linux
+frame buffer that provides drawing functions, a window stack and
+support for input devices. The code you find here is a backend for
+GDK, the drawing kit used by GTK+.
+
+
+As DirectFB provides drawing functions, a windowing stack and manages
+input devices, this is a lightweight GDK port. Some parts of GDK
+require higher level drawing functions that are supported by 
+cairo on DirectFB. 
+GDK also uses some feature like bitmaps that do not map well to 
+modern graphics hardware and are for that reason not yet supported in 
+this snapshot. See the file TODO for a list of missing features.
+
+
+If you want GTK+ to draw window decorations for you, edit the file
+gtk/gtkwindow-decorate.c and uncomment the line that says
+#define DECORATE_WINDOWS.
+
+
+GTK+ application compiled with this version of GTK+ understand some
+additional command-line options special to the DirectFB GDK backend:
+
+  --transparent-unfocused  Makes unfocused windows translucent.
+
+  --argb-font              Use ARGB surfaces for fonts, needed for some
+                           broken hardware.
+
+  --glyph-surface-cache    Lets you tune the size of the glyph cache, 
+                           the default is to cache glyphs from 8 faces.
+
+  --enable-color-keying    This option turns on a hack that does the
+                           following:
+
+    (1) It overrides the color used to draw the window background to
+        gdk_directfb_bg_color as defined in gdkprivate-directfb.h.
+        Note that the alpha value only takes effect if the window has
+        an alpha channel.
+    (2) It also draws all rectangles that are drawn in
+        gdk_directfb_bg_color_key in this color (gdk_directfb_bg_color).
+
+    This feature can be used to create windows with translucent background.
+
+Additionally all DirectFB command-line options as described in the
+directfbrc man-page are supported.
+
+
+This version of GTK+ also introduces two new functions that are special
+to the DirectFB version. You need to include gdk/gdkdirectfb.h to be
+able to use them.
+
+  gdk_directfb_window_set_opacity (GdkWindow *window, guchar opacity));
+
+      This function sets the overall opacity for toplevel GDK windows.
+
+  gdk_directfb_visual_by_format (DFBSurfacePixelFormat pixel_format);
+
+      This function returns a GdkVisual for a DirectFB pixelformat and
+      thus gives you control over the window surface. If for example
+      you want to create a window with alpha channel you can use some
+      code like the following:
+
+        visual = gdk_directfb_visual_by_format (DSPF_ARGB);
+        cmap = gdk_colormap_new (visual, FALSE);
+        gtk_widget_push_colormap (cmap);
+        window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+        gtk_widget_pop_colormap ();
+        g_object_unref (cmap);
+
+Don't use these functions if you want to be able to compile your
+application against GTK+-X11 or other GTK+ versions.
+
+
+If you are developing a GTK+ application for GTK+-DirectFB make sure
+you use the gtk+-directfb-2.0.pc file when calling pkg-config to get
+the  correct compiler and linker flags for GTK+-DirectFB:
+
+  pkg-config --cflags gtk+-directfb-2.0
+  pkg-config --libs gtk+-directfb-2.0
+
+
+See the file TODO for a list of unimplemented features.
+
+
+Detailed and up-to-date instructions on how to build a complete
+set of GTK-DFB libraries is avalable in the WIKI of the DirectFB project
+at the address
+http://www.directfb.org/wiki/index.php/Projects:GTK_on_DirectFB
+
+
+This library is free software; you can redistribute it and/or modify it 
+under the terms of the GNU Lesser General Public License as published 
+by the Free Software Foundation; either version 2 of the License, or 
+(at your option) any later version.
diff -ruN old/gdk/directfb/TODO gtk+/gdk/directfb/TODO
--- old/gdk/directfb/TODO	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/TODO	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,58 @@
+A list of missing things and known bugs in the DirectFB GDK backend:
+
+- Implement more GDK drawing functions. The most important ones
+  (including XOR) do work now. Other drawing functions are rarely
+  used and would need support from DirectFB.
+- Implemenent extended input devices. Shouldn't be too hard.
+- Look into DND and selections. DND seems to work inside one
+  application at least.
+- Consider using the recently added glyph cache in PangoFT2 to
+  implement our glyph surface cache. Probably limit the number 
+  of cached glyphs or the size of the surface cache instead of
+  keeping all glyphs from a number of fonts in the cache.
+
+Some things that will probably never happen:
+
+- Line styles, joining and related stuff. We could use code from the
+  LinuxFB backend but it seems to be bloat for most applications.
+  Implementing dashed lines would probably make sense and shouldn't
+  be too hard.
+- Bitmaps (they are partly supported) and masks. This stuff should
+  be entirely deprecated. Use real alpha channels instead!
+
+
+This is a simple list of unimplemented function stubs and there file
+to see the implementation check the x11 dir.
+Its not started yet.
+
+gdkcolor-directfb.c
+gdkcursor-directfb.c
+gdkdisplay-directfb.c
+gdkdnd-directfb.c
+gdkdrawable-directfb.c
+gdkevents-directfb.c
+gdkfont-directfb.c
+gdkgc-directfb.c
+gdkgeometry-directfb.c
+gdkglobals-directfb.c
+gdkimage-directfb.c
+gdkim-directfb.c
+gdkinput-directfb.c
+gdkkeys-directfb.c
+	gdk_keymap_lookup_key 
+	gdk_keyval_convert_case
+gdkmain-directfb.c
+gdkpixmap-directfb.c
+gdkproperty-directfb.c
+gdkscreen-directfb.c
+gdkselection-directfb.c
+gdkspawn-directfb.c
+gdkvisual-directfb.c
+gdkwindow-directfb.c
+gdkwindowid.c
+glyphsurfacecache.c
+
+
+NOTES:
+event filter callbacks missing see the x11 impl
+
diff -ruN old/gdk/directfb/gdkcolor-directfb.c gtk+/gdk/directfb/gdkcolor-directfb.c
--- old/gdk/directfb/gdkcolor-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkcolor-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,623 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002       convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include "config.h"
+#include "gdk.h"
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+
+#include "gdkcolor.h"
+#include "gdkalias.h"
+
+
+typedef struct {
+  GdkColorInfo     *info;
+  IDirectFBPalette *palette;
+} GdkColormapPrivateDirectFB;
+
+
+static void  gdk_colormap_init          (GdkColormap      *colormap);
+static void  gdk_colormap_class_init    (GdkColormapClass *klass);
+static void  gdk_colormap_finalize      (GObject          *object);
+
+static gint  gdk_colormap_alloc_pseudocolors (GdkColormap *colormap,
+                                              GdkColor    *colors,
+                                              gint         ncolors,
+                                              gboolean     writeable,
+                                              gboolean     best_match,
+                                              gboolean    *success);
+static void  gdk_directfb_allocate_color_key (GdkColormap *colormap);
+
+
+static GObjectClass *parent_class = NULL;
+
+
+GType
+gdk_colormap_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type) {
+    static const GTypeInfo object_info =
+      {
+        sizeof (GdkColormapClass),
+        (GBaseInitFunc) NULL,
+        (GBaseFinalizeFunc) NULL,
+        (GClassInitFunc) gdk_colormap_class_init,
+        NULL,           /* class_finalize */
+        NULL,           /* class_data */
+        sizeof (GdkColormap),
+        0,              /* n_preallocs */
+        (GInstanceInitFunc) gdk_colormap_init,
+      };
+
+    object_type = g_type_register_static (G_TYPE_OBJECT,
+                                          "GdkColormap",
+                                          &object_info, 0);
+  }
+
+  return object_type;
+}
+
+static void
+gdk_colormap_init (GdkColormap *colormap)
+{
+  colormap->size           = 0;
+  colormap->colors         = NULL;
+  colormap->windowing_data = NULL;
+}
+
+static void
+gdk_colormap_class_init (GdkColormapClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = gdk_colormap_finalize;
+}
+
+static void
+gdk_colormap_finalize (GObject *object)
+{
+  GdkColormap                *colormap = GDK_COLORMAP (object);
+  GdkColormapPrivateDirectFB *private  = colormap->windowing_data;
+
+  g_free (colormap->colors);
+  colormap->colors = NULL;
+
+  if (private)
+    {
+      g_free (private->info);
+
+      if (private->palette)
+        private->palette->Release (private->palette);
+
+      g_free (private);
+      colormap->windowing_data = NULL;
+    }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+GdkColormap*
+gdk_colormap_new (GdkVisual *visual,
+                  gboolean   private_cmap)
+{
+  GdkColormap *colormap;
+  gint         i;
+
+  g_return_val_if_fail (visual != NULL, NULL);
+
+  colormap = g_object_new (gdk_colormap_get_type (), NULL);
+  colormap->visual = visual;
+  colormap->size   = visual->colormap_size;
+
+  switch (visual->type)
+    {
+    case GDK_VISUAL_PSEUDO_COLOR:
+      {
+        GdkColormapPrivateDirectFB *private;
+        DFBPaletteDescription       dsc;
+
+        colormap->colors = g_new0 (GdkColor, colormap->size);
+
+        private = g_new0 (GdkColormapPrivateDirectFB, 1);
+        private->info = g_new0 (GdkColorInfo, colormap->size);
+
+	if (visual == gdk_visual_get_system())
+	  {
+            /* save the first (transparent) palette entry */
+            private->info[0].ref_count++;
+          }
+
+        dsc.flags = DPDESC_SIZE;
+        dsc.size  = colormap->size;
+        _gdk_display->directfb->CreatePalette (
+		_gdk_display->directfb, &dsc, &private->palette);
+
+        colormap->windowing_data = private;
+
+        gdk_directfb_allocate_color_key (colormap);
+      }
+      break;
+
+    case GDK_VISUAL_STATIC_COLOR:
+      colormap->colors = g_new0 (GdkColor, colormap->size);
+      for (i = 0; i < colormap->size; i++)
+        {
+          GdkColor *color = colormap->colors + i;
+
+          color->pixel = i;
+          color->red   = (i & 0xE0) <<  8 | (i & 0xE0);
+          color->green = (i & 0x1C) << 11 | (i & 0x1C) << 3;
+          color->blue  = (i & 0x03) << 14 | (i & 0x03) << 6;
+        }
+      break;
+
+    default:
+      break;
+    }
+
+  return colormap;
+}
+
+GdkScreen*
+gdk_colormap_get_screen (GdkColormap *cmap)
+{
+  return _gdk_screen;
+}
+
+GdkColormap*
+gdk_screen_get_system_colormap (GdkScreen *screen)
+{
+  static GdkColormap *colormap = NULL;
+
+  if (!colormap)
+    {
+      GdkVisual *visual = gdk_visual_get_system();
+
+      /* special case PSEUDO_COLOR to use the system palette */
+      if (visual->type == GDK_VISUAL_PSEUDO_COLOR)
+        {
+          GdkColormapPrivateDirectFB *private;
+          IDirectFBSurface           *surface;
+
+          colormap = g_object_new (gdk_colormap_get_type (), NULL);
+
+          colormap->visual = visual;
+          colormap->size   = visual->colormap_size;
+          colormap->colors = g_new0 (GdkColor, colormap->size);
+
+          private = g_new0 (GdkColormapPrivateDirectFB, 1);
+          private->info = g_new0 (GdkColorInfo, colormap->size);
+	
+          surface=GDK_WINDOW_IMPL_DIRECTFB (
+				GDK_WINDOW_OBJECT (_gdk_parent_root)->impl)->drawable.surface;
+          surface->GetPalette (surface, &private->palette);
+
+          colormap->windowing_data = private;
+
+          /* save the first (transparent) palette entry */
+          private->info[0].ref_count++;
+
+          gdk_directfb_allocate_color_key (colormap);
+        }
+      else
+        {
+          colormap = gdk_colormap_new (visual, FALSE);
+        }
+    }
+
+  return colormap;
+}
+
+gint
+gdk_colormap_get_system_size (void)
+{
+  GdkVisual *visual;
+
+  visual = gdk_visual_get_system ();
+
+  return visual->colormap_size;
+}
+
+void
+gdk_colormap_change (GdkColormap *colormap,
+                     gint         ncolors)
+{
+  g_message ("gdk_colormap_change() is deprecated and unimplemented");
+}
+
+gboolean
+gdk_colors_alloc (GdkColormap   *colormap,
+                  gboolean       contiguous,
+                  gulong        *planes,
+                  gint           nplanes,
+                  gulong        *pixels,
+                  gint           npixels)
+{
+  /* g_message ("gdk_colors_alloc() is deprecated and unimplemented"); */
+
+  return TRUE;  /* return TRUE here to make GdkRGB happy */
+}
+
+void
+gdk_colors_free (GdkColormap *colormap,
+                 gulong      *in_pixels,
+                 gint         in_npixels,
+                 gulong       planes)
+{
+  /* g_message ("gdk_colors_free() is deprecated and unimplemented"); */
+}
+
+void
+gdk_colormap_free_colors (GdkColormap *colormap,
+                          GdkColor    *colors,
+                          gint         ncolors)
+{
+  GdkColormapPrivateDirectFB *private;
+  gint                        i;
+
+  g_return_if_fail (GDK_IS_COLORMAP (colormap));
+  g_return_if_fail (colors != NULL);
+
+  private = colormap->windowing_data;
+  if (!private)
+    return;
+
+  for (i = 0; i < ncolors; i++)
+    {
+      gint  index = colors[i].pixel;
+
+      if (index < 0 || index >= colormap->size)
+        continue;
+
+      if (private->info[index].ref_count)
+        private->info[index].ref_count--;
+    }
+}
+
+gint
+gdk_colormap_alloc_colors (GdkColormap *colormap,
+                           GdkColor    *colors,
+                           gint         ncolors,
+                           gboolean     writeable,
+                           gboolean     best_match,
+                           gboolean    *success)
+{
+  GdkVisual *visual;
+  gint       i;
+
+  g_return_val_if_fail (GDK_IS_COLORMAP (colormap), 0);
+  g_return_val_if_fail (colors != NULL, 0);
+  g_return_val_if_fail (success != NULL, 0);
+
+  switch (colormap->visual->type)
+    {
+    case GDK_VISUAL_TRUE_COLOR:
+      visual = colormap->visual;
+
+      for (i = 0; i < ncolors; i++)
+        {
+          colors[i].pixel =
+            (((colors[i].red
+               >> (16 - visual->red_prec))   << visual->red_shift)   +
+             ((colors[i].green
+               >> (16 - visual->green_prec)) << visual->green_shift) +
+             ((colors[i].blue
+               >> (16 - visual->blue_prec))  << visual->blue_shift));
+
+          success[i] = TRUE;
+        }
+      break;
+
+    case GDK_VISUAL_PSEUDO_COLOR:
+      return gdk_colormap_alloc_pseudocolors (colormap,
+                                              colors, ncolors,
+                                              writeable, best_match,
+                                              success);
+      break;
+
+    case GDK_VISUAL_STATIC_COLOR:
+      for (i = 0; i < ncolors; i++)
+        {
+          colors[i].pixel = (((colors[i].red   & 0xE000) >> 8)  |
+                             ((colors[i].green & 0xE000) >> 11) |
+                             ((colors[i].blue  & 0xC000) >> 14));
+          success[i] = TRUE;
+        }
+      break;
+
+    default:
+      for (i = 0; i < ncolors; i++)
+        success[i] = FALSE;
+      break;
+    }
+
+  return 0;
+}
+
+gboolean
+gdk_color_change (GdkColormap *colormap,
+                  GdkColor    *color)
+{
+  GdkColormapPrivateDirectFB *private;
+  IDirectFBPalette           *palette;
+
+  g_return_val_if_fail (GDK_IS_COLORMAP (colormap), FALSE);
+  g_return_val_if_fail (color != NULL, FALSE);
+
+  private = colormap->windowing_data;
+  if (!private)
+    return FALSE;
+
+  palette = private->palette;
+  if (!palette)
+    return FALSE;
+
+  if (color->pixel < 0 || color->pixel >= colormap->size)
+    return FALSE;
+
+  if (private->info[color->pixel].flags & GDK_COLOR_WRITEABLE)
+    {
+      DFBColor  entry = { 0xFF,
+                          color->red   >> 8,
+                          color->green >> 8,
+                          color->blue  >> 8 };
+
+      if (palette->SetEntries (palette, &entry, 1, color->pixel) != DFB_OK)
+        return FALSE;
+
+      colormap->colors[color->pixel] = *color;
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+void
+gdk_colormap_query_color (GdkColormap *colormap,
+                          gulong       pixel,
+                          GdkColor    *result)
+{
+  GdkVisual *visual;
+
+  g_return_if_fail (GDK_IS_COLORMAP (colormap));
+
+  visual = gdk_colormap_get_visual (colormap);
+
+  switch (visual->type)
+    {
+    case GDK_VISUAL_TRUE_COLOR:
+      result->red = 65535. *
+        (gdouble)((pixel & visual->red_mask) >> visual->red_shift) /
+        ((1 << visual->red_prec) - 1);
+
+      result->green = 65535. *
+        (gdouble)((pixel & visual->green_mask) >> visual->green_shift) /
+        ((1 << visual->green_prec) - 1);
+
+      result->blue = 65535. *
+        (gdouble)((pixel & visual->blue_mask) >> visual->blue_shift) /
+        ((1 << visual->blue_prec) - 1);
+      break;
+
+    case GDK_VISUAL_STATIC_COLOR:
+    case GDK_VISUAL_PSEUDO_COLOR:
+      if (pixel >= 0 && pixel < colormap->size)
+        {
+          result->red   = colormap->colors[pixel].red;
+          result->green = colormap->colors[pixel].green;
+          result->blue  = colormap->colors[pixel].blue;
+        }
+      else
+        g_warning ("gdk_colormap_query_color: pixel outside colormap");
+      break;
+
+    case GDK_VISUAL_DIRECT_COLOR:
+    case GDK_VISUAL_GRAYSCALE:
+    case GDK_VISUAL_STATIC_GRAY:
+      /* unsupported */
+      g_assert_not_reached ();
+      break;
+    }
+}
+
+IDirectFBPalette *
+gdk_directfb_colormap_get_palette (GdkColormap *colormap)
+{
+  GdkColormapPrivateDirectFB *private;
+
+  g_return_val_if_fail (GDK_IS_COLORMAP (colormap), NULL);
+
+  private = colormap->windowing_data;
+
+  if (private && private->palette)
+    return private->palette;
+  else
+    return NULL;
+}
+
+static gint
+gdk_colormap_alloc_pseudocolors (GdkColormap *colormap,
+                                 GdkColor    *colors,
+                                 gint         ncolors,
+                                 gboolean     writeable,
+                                 gboolean     best_match,
+                                 gboolean    *success)
+{
+  GdkColormapPrivateDirectFB *private = colormap->windowing_data;
+  IDirectFBPalette           *palette;
+  gint                        i, j;
+  gint                        remaining = ncolors;
+
+  palette = private->palette;
+
+  for (i = 0; i < ncolors; i++)
+    {
+      guint     index;
+      DFBColor  lookup = { 0xFF,
+                           colors[i].red   >> 8,
+                           colors[i].green >> 8,
+                           colors[i].blue  >> 8 };
+
+      success[i] = FALSE;
+
+      if (writeable)
+        {
+          /* look for an empty slot and allocate a new color */
+          for (j = 0; j < colormap->size; j++)
+            if (private->info[j].ref_count == 0)
+              {
+                index = j;
+
+                palette->SetEntries (palette, &lookup, 1, index);
+
+                private->info[index].flags = GDK_COLOR_WRITEABLE;
+
+                colors[i].pixel = index;
+                colormap->colors[index] = colors[i];
+
+                goto allocated;
+              }
+        }
+      else
+        {
+          palette->FindBestMatch (palette,
+                                  lookup.r, lookup.g, lookup.b, lookup.a,
+                                  &index);
+
+          if (index < 0 || index > colormap->size)
+            continue;
+
+          /* check if we have an exact (non-writeable) match */
+          if (private->info[index].ref_count &&
+              !(private->info[index].flags & GDK_COLOR_WRITEABLE))
+            {
+              DFBColor  entry;
+
+              palette->GetEntries (palette, &entry, 1, index);
+
+              if (entry.a == 0xFF &&
+                  entry.r == lookup.r && entry.g == lookup.g && entry.b == lookup.b)
+                {
+                  colors[i].pixel = index;
+
+                  goto allocated;
+                }
+            }
+
+          /* look for an empty slot and allocate a new color */
+          for (j = 0; j < colormap->size; j++)
+            if (private->info[j].ref_count == 0)
+              {
+                index = j;
+
+                palette->SetEntries (palette, &lookup, 1, index);
+    		private->info[index].flags = 0;
+
+                colors[i].pixel = index;
+                colormap->colors[index] = colors[i];
+
+                goto allocated;
+              }
+
+          /* if that failed, use the best match */
+          if (best_match &&
+              !(private->info[index].flags & GDK_COLOR_WRITEABLE))
+            {
+#if 0
+               g_print ("best match for (%d %d %d)  ",
+                       colormap->colors[index].red,
+                       colormap->colors[index].green,
+                       colormap->colors[index].blue);
+#endif
+
+              colors[i].pixel = index;
+
+              goto allocated;
+            }
+        }
+
+      /* if we got here, all attempts failed */
+      continue;
+
+    allocated:
+      private->info[index].ref_count++;
+
+#if 0
+      g_print ("cmap %p: allocated (%d %d %d) %d [%d]\n", colormap,
+                colors[i].red, colors[i].green, colors[i].blue, colors[i].pixel,
+	        private->info[index].ref_count);
+#endif
+
+      success[i] = TRUE;
+      remaining--;
+    }
+
+  return remaining;
+}
+
+/* dirty hack for color_keying */
+static void
+gdk_directfb_allocate_color_key (GdkColormap *colormap)
+{
+  GdkColormapPrivateDirectFB *private = colormap->windowing_data;
+  IDirectFBPalette           *palette = private->palette;
+
+  if (!gdk_directfb_enable_color_keying)
+    return;
+
+  palette->SetEntries (palette, &gdk_directfb_bg_color, 1, 255);
+
+  colormap->colors[255].pixel = 255;
+  colormap->colors[255].red   = ((gdk_directfb_bg_color_key.r << 8)
+                                 | gdk_directfb_bg_color_key.r);
+  colormap->colors[255].green = ((gdk_directfb_bg_color_key.g << 8)
+                                 | gdk_directfb_bg_color_key.g);
+  colormap->colors[255].blue  = ((gdk_directfb_bg_color_key.b << 8)
+                                 | gdk_directfb_bg_color_key.b);
+
+  private->info[255].ref_count++;
+}
+
+#define __GDK_COLOR_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkcursor-directfb.c gtk+/gdk/directfb/gdkcursor-directfb.c
--- old/gdk/directfb/gdkcursor-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkcursor-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,539 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002       convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+#include <config.h>
+#include "gdk.h"
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+#include "gdkcursor.h"
+#include "gdkalias.h"
+
+#include "x-cursors.xbm"
+
+static struct {
+  const guchar *bits;
+  int width, height, hotx, hoty;
+  GdkCursor *cursor;
+} stock_cursors[] = {
+  {X_cursor_bits, X_cursor_width, X_cursor_height, X_cursor_x_hot, X_cursor_y_hot},
+  {X_cursor_mask_bits, X_cursor_mask_width, X_cursor_mask_height, X_cursor_mask_x_hot, X_cursor_mask_y_hot},
+  {arrow_bits, arrow_width, arrow_height, arrow_x_hot, arrow_y_hot},
+  {arrow_mask_bits, arrow_mask_width, arrow_mask_height, arrow_mask_x_hot, arrow_mask_y_hot},
+  {based_arrow_down_bits, based_arrow_down_width, based_arrow_down_height, based_arrow_down_x_hot, based_arrow_down_y_hot},
+  {based_arrow_down_mask_bits, based_arrow_down_mask_width, based_arrow_down_mask_height, based_arrow_down_mask_x_hot, based_arrow_down_mask_y_hot},
+  {based_arrow_up_bits, based_arrow_up_width, based_arrow_up_height, based_arrow_up_x_hot, based_arrow_up_y_hot},
+  {based_arrow_up_mask_bits, based_arrow_up_mask_width, based_arrow_up_mask_height, based_arrow_up_mask_x_hot, based_arrow_up_mask_y_hot},
+  {boat_bits, boat_width, boat_height, boat_x_hot, boat_y_hot},
+  {boat_mask_bits, boat_mask_width, boat_mask_height, boat_mask_x_hot, boat_mask_y_hot},
+  {bogosity_bits, bogosity_width, bogosity_height, bogosity_x_hot, bogosity_y_hot},
+  {bogosity_mask_bits, bogosity_mask_width, bogosity_mask_height, bogosity_mask_x_hot, bogosity_mask_y_hot},
+  {bottom_left_corner_bits, bottom_left_corner_width, bottom_left_corner_height, bottom_left_corner_x_hot, bottom_left_corner_y_hot},
+  {bottom_left_corner_mask_bits, bottom_left_corner_mask_width, bottom_left_corner_mask_height, bottom_left_corner_mask_x_hot, bottom_left_corner_mask_y_hot},
+  {bottom_right_corner_bits, bottom_right_corner_width, bottom_right_corner_height, bottom_right_corner_x_hot, bottom_right_corner_y_hot},
+  {bottom_right_corner_mask_bits, bottom_right_corner_mask_width, bottom_right_corner_mask_height, bottom_right_corner_mask_x_hot, bottom_right_corner_mask_y_hot},
+  {bottom_side_bits, bottom_side_width, bottom_side_height, bottom_side_x_hot, bottom_side_y_hot},
+  {bottom_side_mask_bits, bottom_side_mask_width, bottom_side_mask_height, bottom_side_mask_x_hot, bottom_side_mask_y_hot},
+  {bottom_tee_bits, bottom_tee_width, bottom_tee_height, bottom_tee_x_hot, bottom_tee_y_hot},
+  {bottom_tee_mask_bits, bottom_tee_mask_width, bottom_tee_mask_height, bottom_tee_mask_x_hot, bottom_tee_mask_y_hot},
+  {box_spiral_bits, box_spiral_width, box_spiral_height, box_spiral_x_hot, box_spiral_y_hot},
+  {box_spiral_mask_bits, box_spiral_mask_width, box_spiral_mask_height, box_spiral_mask_x_hot, box_spiral_mask_y_hot},
+  {center_ptr_bits, center_ptr_width, center_ptr_height, center_ptr_x_hot, center_ptr_y_hot},
+  {center_ptr_mask_bits, center_ptr_mask_width, center_ptr_mask_height, center_ptr_mask_x_hot, center_ptr_mask_y_hot},
+  {circle_bits, circle_width, circle_height, circle_x_hot, circle_y_hot},
+  {circle_mask_bits, circle_mask_width, circle_mask_height, circle_mask_x_hot, circle_mask_y_hot},
+  {clock_bits, clock_width, clock_height, clock_x_hot, clock_y_hot},
+  {clock_mask_bits, clock_mask_width, clock_mask_height, clock_mask_x_hot, clock_mask_y_hot},
+  {coffee_mug_bits, coffee_mug_width, coffee_mug_height, coffee_mug_x_hot, coffee_mug_y_hot},
+  {coffee_mug_mask_bits, coffee_mug_mask_width, coffee_mug_mask_height, coffee_mug_mask_x_hot, coffee_mug_mask_y_hot},
+  {cross_bits, cross_width, cross_height, cross_x_hot, cross_y_hot},
+  {cross_mask_bits, cross_mask_width, cross_mask_height, cross_mask_x_hot, cross_mask_y_hot},
+  {cross_reverse_bits, cross_reverse_width, cross_reverse_height, cross_reverse_x_hot, cross_reverse_y_hot},
+  {cross_reverse_mask_bits, cross_reverse_mask_width, cross_reverse_mask_height, cross_reverse_mask_x_hot, cross_reverse_mask_y_hot},
+  {crosshair_bits, crosshair_width, crosshair_height, crosshair_x_hot, crosshair_y_hot},
+  {crosshair_mask_bits, crosshair_mask_width, crosshair_mask_height, crosshair_mask_x_hot, crosshair_mask_y_hot},
+  {diamond_cross_bits, diamond_cross_width, diamond_cross_height, diamond_cross_x_hot, diamond_cross_y_hot},
+  {diamond_cross_mask_bits, diamond_cross_mask_width, diamond_cross_mask_height, diamond_cross_mask_x_hot, diamond_cross_mask_y_hot},
+  {dot_bits, dot_width, dot_height, dot_x_hot, dot_y_hot},
+  {dot_mask_bits, dot_mask_width, dot_mask_height, dot_mask_x_hot, dot_mask_y_hot},
+  {dotbox_bits, dotbox_width, dotbox_height, dotbox_x_hot, dotbox_y_hot},
+  {dotbox_mask_bits, dotbox_mask_width, dotbox_mask_height, dotbox_mask_x_hot, dotbox_mask_y_hot},
+  {double_arrow_bits, double_arrow_width, double_arrow_height, double_arrow_x_hot, double_arrow_y_hot},
+  {double_arrow_mask_bits, double_arrow_mask_width, double_arrow_mask_height, double_arrow_mask_x_hot, double_arrow_mask_y_hot},
+  {draft_large_bits, draft_large_width, draft_large_height, draft_large_x_hot, draft_large_y_hot},
+  {draft_large_mask_bits, draft_large_mask_width, draft_large_mask_height, draft_large_mask_x_hot, draft_large_mask_y_hot},
+  {draft_small_bits, draft_small_width, draft_small_height, draft_small_x_hot, draft_small_y_hot},
+  {draft_small_mask_bits, draft_small_mask_width, draft_small_mask_height, draft_small_mask_x_hot, draft_small_mask_y_hot},
+  {draped_box_bits, draped_box_width, draped_box_height, draped_box_x_hot, draped_box_y_hot},
+  {draped_box_mask_bits, draped_box_mask_width, draped_box_mask_height, draped_box_mask_x_hot, draped_box_mask_y_hot},
+  {exchange_bits, exchange_width, exchange_height, exchange_x_hot, exchange_y_hot},
+  {exchange_mask_bits, exchange_mask_width, exchange_mask_height, exchange_mask_x_hot, exchange_mask_y_hot},
+  {fleur_bits, fleur_width, fleur_height, fleur_x_hot, fleur_y_hot},
+  {fleur_mask_bits, fleur_mask_width, fleur_mask_height, fleur_mask_x_hot, fleur_mask_y_hot},
+  {gobbler_bits, gobbler_width, gobbler_height, gobbler_x_hot, gobbler_y_hot},
+  {gobbler_mask_bits, gobbler_mask_width, gobbler_mask_height, gobbler_mask_x_hot, gobbler_mask_y_hot},
+  {gumby_bits, gumby_width, gumby_height, gumby_x_hot, gumby_y_hot},
+  {gumby_mask_bits, gumby_mask_width, gumby_mask_height, gumby_mask_x_hot, gumby_mask_y_hot},
+  {hand1_bits, hand1_width, hand1_height, hand1_x_hot, hand1_y_hot},
+  {hand1_mask_bits, hand1_mask_width, hand1_mask_height, hand1_mask_x_hot, hand1_mask_y_hot},
+  {hand2_bits, hand2_width, hand2_height, hand2_x_hot, hand2_y_hot},
+  {hand2_mask_bits, hand2_mask_width, hand2_mask_height, hand2_mask_x_hot, hand2_mask_y_hot},
+  {heart_bits, heart_width, heart_height, heart_x_hot, heart_y_hot},
+  {heart_mask_bits, heart_mask_width, heart_mask_height, heart_mask_x_hot, heart_mask_y_hot},
+  {icon_bits, icon_width, icon_height, icon_x_hot, icon_y_hot},
+  {icon_mask_bits, icon_mask_width, icon_mask_height, icon_mask_x_hot, icon_mask_y_hot},
+  {iron_cross_bits, iron_cross_width, iron_cross_height, iron_cross_x_hot, iron_cross_y_hot},
+  {iron_cross_mask_bits, iron_cross_mask_width, iron_cross_mask_height, iron_cross_mask_x_hot, iron_cross_mask_y_hot},
+  {left_ptr_bits, left_ptr_width, left_ptr_height, left_ptr_x_hot, left_ptr_y_hot},
+  {left_ptr_mask_bits, left_ptr_mask_width, left_ptr_mask_height, left_ptr_mask_x_hot, left_ptr_mask_y_hot},
+  {left_side_bits, left_side_width, left_side_height, left_side_x_hot, left_side_y_hot},
+  {left_side_mask_bits, left_side_mask_width, left_side_mask_height, left_side_mask_x_hot, left_side_mask_y_hot},
+  {left_tee_bits, left_tee_width, left_tee_height, left_tee_x_hot, left_tee_y_hot},
+  {left_tee_mask_bits, left_tee_mask_width, left_tee_mask_height, left_tee_mask_x_hot, left_tee_mask_y_hot},
+  {leftbutton_bits, leftbutton_width, leftbutton_height, leftbutton_x_hot, leftbutton_y_hot},
+  {leftbutton_mask_bits, leftbutton_mask_width, leftbutton_mask_height, leftbutton_mask_x_hot, leftbutton_mask_y_hot},
+  {ll_angle_bits, ll_angle_width, ll_angle_height, ll_angle_x_hot, ll_angle_y_hot},
+  {ll_angle_mask_bits, ll_angle_mask_width, ll_angle_mask_height, ll_angle_mask_x_hot, ll_angle_mask_y_hot},
+  {lr_angle_bits, lr_angle_width, lr_angle_height, lr_angle_x_hot, lr_angle_y_hot},
+  {lr_angle_mask_bits, lr_angle_mask_width, lr_angle_mask_height, lr_angle_mask_x_hot, lr_angle_mask_y_hot},
+  {man_bits, man_width, man_height, man_x_hot, man_y_hot},
+  {man_mask_bits, man_mask_width, man_mask_height, man_mask_x_hot, man_mask_y_hot},
+  {middlebutton_bits, middlebutton_width, middlebutton_height, middlebutton_x_hot, middlebutton_y_hot},
+  {middlebutton_mask_bits, middlebutton_mask_width, middlebutton_mask_height, middlebutton_mask_x_hot, middlebutton_mask_y_hot},
+  {mouse_bits, mouse_width, mouse_height, mouse_x_hot, mouse_y_hot},
+  {mouse_mask_bits, mouse_mask_width, mouse_mask_height, mouse_mask_x_hot, mouse_mask_y_hot},
+  {pencil_bits, pencil_width, pencil_height, pencil_x_hot, pencil_y_hot},
+  {pencil_mask_bits, pencil_mask_width, pencil_mask_height, pencil_mask_x_hot, pencil_mask_y_hot},
+  {pirate_bits, pirate_width, pirate_height, pirate_x_hot, pirate_y_hot},
+  {pirate_mask_bits, pirate_mask_width, pirate_mask_height, pirate_mask_x_hot, pirate_mask_y_hot},
+  {plus_bits, plus_width, plus_height, plus_x_hot, plus_y_hot},
+  {plus_mask_bits, plus_mask_width, plus_mask_height, plus_mask_x_hot, plus_mask_y_hot},
+  {question_arrow_bits, question_arrow_width, question_arrow_height, question_arrow_x_hot, question_arrow_y_hot},
+  {question_arrow_mask_bits, question_arrow_mask_width, question_arrow_mask_height, question_arrow_mask_x_hot, question_arrow_mask_y_hot},
+  {right_ptr_bits, right_ptr_width, right_ptr_height, right_ptr_x_hot, right_ptr_y_hot},
+  {right_ptr_mask_bits, right_ptr_mask_width, right_ptr_mask_height, right_ptr_mask_x_hot, right_ptr_mask_y_hot},
+  {right_side_bits, right_side_width, right_side_height, right_side_x_hot, right_side_y_hot},
+  {right_side_mask_bits, right_side_mask_width, right_side_mask_height, right_side_mask_x_hot, right_side_mask_y_hot},
+  {right_tee_bits, right_tee_width, right_tee_height, right_tee_x_hot, right_tee_y_hot},
+  {right_tee_mask_bits, right_tee_mask_width, right_tee_mask_height, right_tee_mask_x_hot, right_tee_mask_y_hot},
+  {rightbutton_bits, rightbutton_width, rightbutton_height, rightbutton_x_hot, rightbutton_y_hot},
+  {rightbutton_mask_bits, rightbutton_mask_width, rightbutton_mask_height, rightbutton_mask_x_hot, rightbutton_mask_y_hot},
+  {rtl_logo_bits, rtl_logo_width, rtl_logo_height, rtl_logo_x_hot, rtl_logo_y_hot},
+  {rtl_logo_mask_bits, rtl_logo_mask_width, rtl_logo_mask_height, rtl_logo_mask_x_hot, rtl_logo_mask_y_hot},
+  {sailboat_bits, sailboat_width, sailboat_height, sailboat_x_hot, sailboat_y_hot},
+  {sailboat_mask_bits, sailboat_mask_width, sailboat_mask_height, sailboat_mask_x_hot, sailboat_mask_y_hot},
+  {sb_down_arrow_bits, sb_down_arrow_width, sb_down_arrow_height, sb_down_arrow_x_hot, sb_down_arrow_y_hot},
+  {sb_down_arrow_mask_bits, sb_down_arrow_mask_width, sb_down_arrow_mask_height, sb_down_arrow_mask_x_hot, sb_down_arrow_mask_y_hot},
+  {sb_h_double_arrow_bits, sb_h_double_arrow_width, sb_h_double_arrow_height, sb_h_double_arrow_x_hot, sb_h_double_arrow_y_hot},
+  {sb_h_double_arrow_mask_bits, sb_h_double_arrow_mask_width, sb_h_double_arrow_mask_height, sb_h_double_arrow_mask_x_hot, sb_h_double_arrow_mask_y_hot},
+  {sb_left_arrow_bits, sb_left_arrow_width, sb_left_arrow_height, sb_left_arrow_x_hot, sb_left_arrow_y_hot},
+  {sb_left_arrow_mask_bits, sb_left_arrow_mask_width, sb_left_arrow_mask_height, sb_left_arrow_mask_x_hot, sb_left_arrow_mask_y_hot},
+  {sb_right_arrow_bits, sb_right_arrow_width, sb_right_arrow_height, sb_right_arrow_x_hot, sb_right_arrow_y_hot},
+  {sb_right_arrow_mask_bits, sb_right_arrow_mask_width, sb_right_arrow_mask_height, sb_right_arrow_mask_x_hot, sb_right_arrow_mask_y_hot},
+  {sb_up_arrow_bits, sb_up_arrow_width, sb_up_arrow_height, sb_up_arrow_x_hot, sb_up_arrow_y_hot},
+  {sb_up_arrow_mask_bits, sb_up_arrow_mask_width, sb_up_arrow_mask_height, sb_up_arrow_mask_x_hot, sb_up_arrow_mask_y_hot},
+  {sb_v_double_arrow_bits, sb_v_double_arrow_width, sb_v_double_arrow_height, sb_v_double_arrow_x_hot, sb_v_double_arrow_y_hot},
+  {sb_v_double_arrow_mask_bits, sb_v_double_arrow_mask_width, sb_v_double_arrow_mask_height, sb_v_double_arrow_mask_x_hot, sb_v_double_arrow_mask_y_hot},
+  {shuttle_bits, shuttle_width, shuttle_height, shuttle_x_hot, shuttle_y_hot},
+  {shuttle_mask_bits, shuttle_mask_width, shuttle_mask_height, shuttle_mask_x_hot, shuttle_mask_y_hot},
+  {sizing_bits, sizing_width, sizing_height, sizing_x_hot, sizing_y_hot},
+  {sizing_mask_bits, sizing_mask_width, sizing_mask_height, sizing_mask_x_hot, sizing_mask_y_hot},
+  {spider_bits, spider_width, spider_height, spider_x_hot, spider_y_hot},
+  {spider_mask_bits, spider_mask_width, spider_mask_height, spider_mask_x_hot, spider_mask_y_hot},
+  {spraycan_bits, spraycan_width, spraycan_height, spraycan_x_hot, spraycan_y_hot},
+  {spraycan_mask_bits, spraycan_mask_width, spraycan_mask_height, spraycan_mask_x_hot, spraycan_mask_y_hot},
+  {star_bits, star_width, star_height, star_x_hot, star_y_hot},
+  {star_mask_bits, star_mask_width, star_mask_height, star_mask_x_hot, star_mask_y_hot},
+  {target_bits, target_width, target_height, target_x_hot, target_y_hot},
+  {target_mask_bits, target_mask_width, target_mask_height, target_mask_x_hot, target_mask_y_hot},
+  {tcross_bits, tcross_width, tcross_height, tcross_x_hot, tcross_y_hot},
+  {tcross_mask_bits, tcross_mask_width, tcross_mask_height, tcross_mask_x_hot, tcross_mask_y_hot},
+  {top_left_arrow_bits, top_left_arrow_width, top_left_arrow_height, top_left_arrow_x_hot, top_left_arrow_y_hot},
+  {top_left_arrow_mask_bits, top_left_arrow_mask_width, top_left_arrow_mask_height, top_left_arrow_mask_x_hot, top_left_arrow_mask_y_hot},
+  {top_left_corner_bits, top_left_corner_width, top_left_corner_height, top_left_corner_x_hot, top_left_corner_y_hot},
+  {top_left_corner_mask_bits, top_left_corner_mask_width, top_left_corner_mask_height, top_left_corner_mask_x_hot, top_left_corner_mask_y_hot},
+  {top_right_corner_bits, top_right_corner_width, top_right_corner_height, top_right_corner_x_hot, top_right_corner_y_hot},
+  {top_right_corner_mask_bits, top_right_corner_mask_width, top_right_corner_mask_height, top_right_corner_mask_x_hot, top_right_corner_mask_y_hot},
+  {top_side_bits, top_side_width, top_side_height, top_side_x_hot, top_side_y_hot},
+  {top_side_mask_bits, top_side_mask_width, top_side_mask_height, top_side_mask_x_hot, top_side_mask_y_hot},
+  {top_tee_bits, top_tee_width, top_tee_height, top_tee_x_hot, top_tee_y_hot},
+  {top_tee_mask_bits, top_tee_mask_width, top_tee_mask_height, top_tee_mask_x_hot, top_tee_mask_y_hot},
+  {trek_bits, trek_width, trek_height, trek_x_hot, trek_y_hot},
+  {trek_mask_bits, trek_mask_width, trek_mask_height, trek_mask_x_hot, trek_mask_y_hot},
+  {ul_angle_bits, ul_angle_width, ul_angle_height, ul_angle_x_hot, ul_angle_y_hot},
+  {ul_angle_mask_bits, ul_angle_mask_width, ul_angle_mask_height, ul_angle_mask_x_hot, ul_angle_mask_y_hot},
+  {umbrella_bits, umbrella_width, umbrella_height, umbrella_x_hot, umbrella_y_hot},
+  {umbrella_mask_bits, umbrella_mask_width, umbrella_mask_height, umbrella_mask_x_hot, umbrella_mask_y_hot},
+  {ur_angle_bits, ur_angle_width, ur_angle_height, ur_angle_x_hot, ur_angle_y_hot},
+  {ur_angle_mask_bits, ur_angle_mask_width, ur_angle_mask_height, ur_angle_mask_x_hot, ur_angle_mask_y_hot},
+  {watch_bits, watch_width, watch_height, watch_x_hot, watch_y_hot},
+  {watch_mask_bits, watch_mask_width, watch_mask_height, watch_mask_x_hot, watch_mask_y_hot},
+  {xterm_bits, xterm_width, xterm_height, xterm_x_hot, xterm_y_hot},
+  {xterm_mask_bits, xterm_mask_width, xterm_mask_height, xterm_mask_x_hot, xterm_mask_y_hot}
+};
+
+GdkCursor *
+gdk_cursor_new_for_display (GdkDisplay *display,GdkCursorType cursor_type)
+{
+  GdkCursor *cursor;
+  GdkDisplayDFB *dfb_display  = GDK_DISPLAY_DFB(display);
+
+  if (cursor_type >= sizeof(stock_cursors)/sizeof(stock_cursors[0]))
+    return NULL;
+
+  cursor = stock_cursors[cursor_type].cursor;
+  if (!cursor)
+    {
+      GdkCursorDirectFB     *private;
+      DFBResult              ret;
+      IDirectFBSurface      *temp;
+      IDirectFBSurface      *shape;
+
+      int width       = stock_cursors[cursor_type+1].width;
+      int height      = stock_cursors[cursor_type+1].height;
+
+      temp =gdk_display_dfb_create_surface(dfb_display,DSPF_ARGB,width,height);
+
+      if (!temp)
+        {
+          return NULL;
+        }
+      else
+        {
+          __u32  *dst;
+          int     pitch;
+
+          ret = temp->Lock (temp, DSLF_WRITE, (void**)&dst, &pitch);
+          if (ret)
+            {
+              DirectFBError ("gdkcursor-directfb.c (gdk_cursor_new): "
+                             "temp->Lock", ret);
+
+              temp->Release (temp);
+
+              return NULL;
+            }
+          else
+            {
+              gint x, y;
+              gint mx, my;
+              gint  p = ((stock_cursors[cursor_type].width + 7) / 8) * 8;
+              gint mp = ((stock_cursors[cursor_type+1].width + 7) / 8) * 8;
+
+              const guchar *src;
+              const guchar *mask;
+
+              pitch >>= 2;
+
+              src  = stock_cursors[cursor_type].bits;
+              mask = stock_cursors[cursor_type+1].bits;
+
+              mx = stock_cursors[cursor_type+1].hotx - stock_cursors[cursor_type].hotx;
+              my = stock_cursors[cursor_type+1].hoty - stock_cursors[cursor_type].hoty;
+
+              for (y = 0; y < height; y++)
+                {
+                  for (x = 0; x < width; x++)
+                    {
+                      gint  bit = x-mx + (y-my) * p;
+                      gint mbit =    x +     y  * mp;
+
+                      __u32 color = (x-mx < 0  ||  y-my < 0  ||
+                                     x-mx >= stock_cursors[cursor_type].width  ||
+                                     y-my >= stock_cursors[cursor_type].height)
+                        ? 0x00FFFFFF : (src[bit/8] & (1 << bit%8) ? 0 : 0x00FFFFFF);
+
+		      __u8  a     = color ? 0xE0 : 0xFF;
+                      __u32 alpha = mask[mbit/8] & (1 << mbit%8) ? (a << 24) : 0;
+
+                      dst[x + y*pitch] = alpha | color;
+                    }
+                }
+
+              temp->Unlock (temp);
+            }
+        }
+
+
+      width  += 2;
+      height += 2;
+
+      shape=gdk_display_dfb_create_surface(dfb_display,DSPF_ARGB,width,height);
+
+      if( !shape ) {
+	temp->Release(temp);
+	return NULL;
+      }
+
+      shape->Clear (shape, 0x80, 0x80, 0x80, 0);
+
+      shape->SetBlittingFlags (shape, (DSBLIT_BLEND_COLORALPHA |
+                                       DSBLIT_BLEND_ALPHACHANNEL));
+
+      shape->SetColor (shape, 0, 0, 0, 0x30);
+      shape->Blit (shape, temp, NULL, 0, 0);
+      shape->Blit (shape, temp, NULL, 0, 2);
+      shape->Blit (shape, temp, NULL, 2, 0);
+      shape->Blit (shape, temp, NULL, 2, 2);
+
+      shape->SetColor (shape, 0, 0, 0, 0xA0);
+      shape->Blit (shape, temp, NULL, 1, 0);
+      shape->Blit (shape, temp, NULL, 0, 1);
+      shape->Blit (shape, temp, NULL, 2, 1);
+      shape->Blit (shape, temp, NULL, 1, 2);
+
+      shape->SetColor (shape, 0, 0, 0, 0xE0);
+      shape->Blit (shape, temp, NULL, 1, 1);
+
+      temp->Release (temp);
+
+      private = g_new0 (GdkCursorDirectFB, 1);
+      cursor = (GdkCursor *) private;
+      cursor->type = GDK_CURSOR_IS_PIXMAP;
+      cursor->ref_count = 1;
+
+      private->shape = shape;
+      private->hot_x = stock_cursors[cursor_type].hotx;
+      private->hot_y = stock_cursors[cursor_type].hoty;
+
+      stock_cursors[cursor_type].cursor = cursor;
+    }
+
+  return gdk_cursor_ref (cursor);
+}
+
+GdkCursor *
+gdk_cursor_new_from_pixmap (GdkPixmap      *source,
+                            GdkPixmap      *mask,
+                            const GdkColor *fg,
+                            const GdkColor *bg,
+                            gint            x,
+                            gint            y)
+{
+  GdkCursor               *cursor;
+  GdkCursorDirectFB       *private;
+  GdkDrawableImplDirectFB *impl;
+  GdkDrawableImplDirectFB *mask_impl;
+  IDirectFBSurface        *shape;
+
+  g_return_val_if_fail (GDK_IS_PIXMAP (source), NULL);
+  g_return_val_if_fail (GDK_IS_PIXMAP (mask), NULL);
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (source)->impl);
+  mask_impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (mask)->impl);
+
+  int width       = impl->width;
+  int height      = impl->height;
+
+  shape=gdk_display_dfb_create_surface(_gdk_display,DSPF_ARGB,width,height);
+            
+  if (!shape)
+    {
+      return NULL;
+    }
+
+  /*
+   *  The following code assumes that pixmap and mask are A8 surfaces
+   *  that correspond to X11 bitmaps. This is the traditional usage of
+   *  gdk_cursor_new_from_pixmap(). For GTK+-DirectFB it might make
+   *  sense to allow arbitrary ARGB cursors.
+   */
+
+  shape->Clear (shape, bg->red >> 8, bg->green >> 8, bg->blue >> 8, 0xFF);
+
+  shape->SetColor (shape, fg->red >> 8, fg->green >> 8, fg->blue >> 8, 0xFF);
+  shape->SetBlittingFlags (shape,
+                           DSBLIT_BLEND_ALPHACHANNEL | DSBLIT_COLORIZE);
+  shape->Blit (shape, impl->surface, NULL, 0, 0);
+
+  shape->SetPorterDuff (shape, DSPD_DST_IN);
+  shape->Blit (shape, mask_impl->surface, NULL, 0, 0);
+
+  shape->SetBlittingFlags (shape, DSBLIT_NOFX);
+  shape->SetPorterDuff (shape, DSPD_NONE);
+
+  private = g_new (GdkCursorDirectFB, 1);
+  cursor = (GdkCursor *) private;
+  cursor->type = GDK_CURSOR_IS_PIXMAP;
+  cursor->ref_count = 1;
+
+  private->shape = shape;
+  private->hot_x = x;
+  private->hot_y = y;
+
+  return cursor;
+}
+
+GdkCursor *
+gdk_cursor_new_from_pixbuf (GdkDisplay *display,
+                            GdkPixbuf  *pixbuf,
+                            gint        x,
+                            gint        y)
+{
+GdkPixmap *pixmap, *mask;
+ GdkCursor  *cursor;
+ gint width, height, depth = 8;
+ GdkVisual* visual;
+
+ /* FIXME: this is not the right way to set colours */
+ GdkColor fg = { 0, 65535, 65535, 65535 };
+ GdkColor bg = { 0, 65535, 65535, 65535 };
+
+ g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
+ g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
+ g_return_val_if_fail (0 <= x && x < gdk_pixbuf_get_width (pixbuf), NULL);
+ g_return_val_if_fail (0 <= y && y < gdk_pixbuf_get_height (pixbuf), NULL);
+
+ width = gdk_pixbuf_get_width(pixbuf);
+ height = gdk_pixbuf_get_height(pixbuf);
+
+ pixmap = gdk_pixmap_new ( NULL, width, height, depth);
+ mask = gdk_pixmap_new ( NULL, width, height, 1);
+ visual = gdk_rgb_get_visual ();
+ depth = visual->depth;
+
+ gdk_pixbuf_render_pixmap_and_mask (pixbuf, &pixmap, &mask, 0);
+
+ g_return_val_if_fail (GDK_IS_PIXMAP (pixmap), NULL);
+ g_return_val_if_fail (GDK_IS_PIXMAP (mask), NULL);
+
+ cursor = gdk_cursor_new_from_pixmap (pixmap, mask, &fg, &bg, x, y) ;
+
+ g_object_unref (pixmap);
+ g_object_unref (mask);
+
+ /* a cursor of type GDK_CURSOR_IS_PIXMAP is returned */
+ return cursor;
+
+}
+
+GdkCursor*
+gdk_cursor_new_from_name (GdkDisplay  *display,
+                          const gchar *name)
+{
+ GdkCursor *cursor;
+ GdkPixbuf *pixbuf;
+
+ g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
+ pixbuf = gdk_pixbuf_new_from_file(name, NULL);
+ g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
+ cursor = gdk_cursor_new_from_pixbuf (display, pixbuf, 1, 1);
+ g_object_unref (pixbuf);
+
+ return cursor;
+}
+
+
+GdkPixbuf*
+gdk_cursor_get_image (GdkCursor *cursor)
+{
+  g_return_val_if_fail (cursor != NULL, NULL);
+
+  return NULL;
+}
+
+
+
+void
+_gdk_cursor_destroy (GdkCursor *cursor)
+{
+  GdkCursorDirectFB *private;
+
+  g_return_if_fail (cursor != NULL);
+  g_return_if_fail (cursor->ref_count == 0);
+
+  private = (GdkCursorDirectFB *) cursor;
+
+  private->shape->Release (private->shape);
+
+  g_free (private);
+}
+
+GdkDisplay *
+gdk_cursor_get_display (GdkCursor *cursor)
+{
+  return gdk_display_get_default ();
+}
+
+guint
+gdk_display_get_default_cursor_size (GdkDisplay    *display)
+{
+  return 16;
+}
+
+/**
+ * gdk_display_get_maximal_cursor_size:
+ * @display: a #GdkDisplay
+ * @width: the return location for the maximal cursor width
+ * @height: the return location for the maximal cursor height
+ *
+ * Gets the maximal size to use for cursors on @display.
+ *
+ * Since: 2.4
+ */
+void
+gdk_display_get_maximal_cursor_size (GdkDisplay *display,
+                                     guint       *width,
+                                     guint       *height)
+{
+  *width=gdk_display_get_default_cursor_size(display);
+  *height=*width;
+}
+
+/**
+ * gdk_display_supports_cursor_alpha:
+ * @display: a #GdkDisplay
+ *
+ * Returns %TRUE if cursors can use an 8bit alpha channel
+ * on @display. Otherwise, cursors are restricted to bilevel
+ * alpha (i.e. a mask).
+ *
+ * Returns: whether cursors can have alpha channels.
+ *
+ * Since: 2.4
+ */
+gboolean
+gdk_display_supports_cursor_alpha (GdkDisplay *display)
+{
+  g_return_val_if_fail (GDK_IS_DISPLAY (display), FALSE);
+  return TRUE;
+}
+
+gboolean
+gdk_display_supports_cursor_color (GdkDisplay *display)
+{
+  g_return_val_if_fail (GDK_IS_DISPLAY (display), FALSE);
+  return TRUE;
+}
+
+#define __GDK_CURSOR_X11_C__
+#include "gdkaliasdef.c"
+
diff -ruN old/gdk/directfb/gdkdirectfb.h gtk+/gdk/directfb/gdkdirectfb.h
--- old/gdk/directfb/gdkdirectfb.h	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkdirectfb.h	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,90 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002       convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#ifndef __GDK_DIRECTFB_H__
+#define __GDK_DIRECTFB_H__
+
+#include <cairo.h>
+#include <directfb.h>
+#include "gdk/gdkprivate.h"
+//#include "gdk/gdkwindow.h"
+#include "gdkdisplay-directfb.h"
+
+/* macro for a safe call to DirectFB functions */
+#define DFBCHECK(x...) \
+     {                                                                \
+          int err = x;                                                    \
+          if (err != DFB_OK) {                                        \
+               fprintf( stderr, "%s <%d>:\n\t", __FILE__, __LINE__ ); \
+               DirectFBErrorFatal( #x, err );                         \
+          }                                                           \
+     }
+
+
+extern GdkWindow * _gdk_parent_root;
+
+G_BEGIN_DECLS
+
+#define GDK_ROOT_WINDOW()      _gdk_parent_root 
+
+#define GDK_WINDOW_DFB_ID(win) (GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (win)->impl)->dfb_id)
+
+
+/* used for the --transparent-unfocused hack */
+extern gboolean            gdk_directfb_apply_focus_opacity;
+
+/* used for the --enable-color-keying hack */
+extern gboolean            gdk_directfb_enable_color_keying;
+extern DFBColor            gdk_directfb_bg_color;
+extern DFBColor            gdk_directfb_bg_color_key;
+
+/* to disable antialiasing */
+extern gboolean            gdk_directfb_monochrome_fonts;
+
+
+/* GTK+-DirectFB specific functions */
+
+void        gdk_directfb_window_set_opacity (GdkWindow             *window,
+                                             guchar                 opacity);
+
+GdkWindow * gdk_directfb_window_new         (GdkWindow             *parent,
+                                             GdkWindowAttr         *attributes,
+                                             gint                   attributes_mask,
+                                             DFBWindowCapabilities  window_caps,
+                                             DFBWindowOptions       window_options,
+                                             DFBSurfaceCapabilities surface_caps);
+
+GdkVisual * gdk_directfb_visual_by_format   (DFBSurfacePixelFormat  pixel_format);
+
+G_END_DECLS
+
+#endif /* __GDK_DIRECTFB_H__ */
diff -ruN old/gdk/directfb/gdkdisplay-directfb.c gtk+/gdk/directfb/gdkdisplay-directfb.c
--- old/gdk/directfb/gdkdisplay-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkdisplay-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,495 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
+ */
+
+#include <config.h>
+
+#include <glib.h>
+#include "gdk.h"
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+#include "gdkscreen.h"
+#include "gdkdisplaymanager.h"
+#include "gdkintl.h"
+#include "gdkalias.h"
+
+
+
+extern void _gdk_visual_init (void);
+extern void _gdk_events_init (void);
+extern void _gdk_input_init (void);
+extern void _gdk_dnd_init (void);
+extern void _gdk_windowing_window_init (void);
+extern void _gdk_windowing_image_init (void);
+extern void _gdk_directfb_keyboard_init      (void);
+
+static gboolean   gdk_directfb_argb_font           = FALSE;
+static gint       gdk_directfb_glyph_surface_cache = 8;
+static gchar 	 *directfb_args;
+
+
+GOptionEntry _gdk_windowing_args[] =
+{
+  { "dfb",0,0,G_OPTION_ARG_STRING,&directfb_args,N_("directfb arg"),N_("sdl|system")}, 
+  { "dfb-help",0,0,G_OPTION_ARG_NONE, NULL,NULL},
+  { "disable-aa-fonts",0,0,G_OPTION_ARG_INT,&gdk_directfb_monochrome_fonts,NULL,NULL    },
+  { "argb-font",0,0, G_OPTION_ARG_INT, &gdk_directfb_argb_font,NULL,NULL},
+  { "transparent-unfocused",0,0, G_OPTION_ARG_INT, &gdk_directfb_apply_focus_opacity,NULL,NULL },
+  { "glyph-surface-cache",0,0,G_OPTION_ARG_INT,&gdk_directfb_glyph_surface_cache,NULL,NULL },
+  { "enable-color-keying",0,0,G_OPTION_ARG_INT,&gdk_directfb_enable_color_keying,NULL,NULL },
+  { NULL}
+};
+
+/**
+  Main entry point for gdk in 2.6 args are parsed
+**/
+GdkDisplay * gdk_display_open (const gchar *display_name)
+{
+
+  if (_gdk_display) {
+    return GDK_DISPLAY_OBJECT(_gdk_display); /* single display only */
+  }
+  DFBResult  ret;
+  IDirectFB              *directfb;
+  IDirectFBDisplayLayer  *layer;
+  IDirectFBInputDevice   *keyboard;
+
+  int argc=0;
+  char **argv=NULL;
+
+#if 0  /* arg hack arg support broken*/
+  if(directfb_args ) {
+	argc=2;
+	argv = (char **)g_malloc(sizeof(char *)*argc);
+	argv[0] = "simple";
+	argv[1] = "--dfb:system=SDL";
+  }
+#endif
+
+  ret = DirectFBInit (&argc,&argv);
+  if (ret != DFB_OK)
+{
+      DirectFBError ("gdk_display_open: DirectFBInit", ret);
+      return NULL;
+    }
+
+    ret = DirectFBCreate (&directfb);
+
+  if (ret != DFB_OK)
+    {
+      DirectFBError ("gdk_display_open: DirectFBCreate", ret);
+      return NULL;
+    }
+  _gdk_display = g_object_new(GDK_TYPE_DISPLAY_DFB,NULL);
+  _gdk_display->directfb=directfb;
+  _gdk_events_init ();
+
+  ret = directfb->GetDisplayLayer (directfb, DLID_PRIMARY, &layer);
+  if (ret != DFB_OK)
+    {
+      DirectFBError ("gdk_display_open: GetDisplayLayer", ret);
+      directfb->Release (directfb);
+	  directfb = NULL;
+      return NULL;
+    }
+
+  layer->EnableCursor (layer, 1);
+
+  ret=directfb->GetInputDevice (directfb, DIDID_KEYBOARD, &keyboard);
+
+  if (ret != DFB_OK){
+      DirectFBError ("gdk_display_open: GetDisplayLayer", ret);
+   	return NULL;
+  }
+
+  _gdk_display->layer=layer;
+  _gdk_display->keyboard=keyboard;
+
+    _gdk_directfb_keyboard_init ();
+
+  _gdk_screen = g_object_new (GDK_TYPE_SCREEN, NULL);
+
+  _gdk_windowing_window_init ();
+
+  _gdk_visual_init ();
+  gdk_screen_set_default_colormap (_gdk_screen,
+                                   gdk_screen_get_system_colormap (_gdk_screen));
+  _gdk_windowing_image_init ();
+
+  _gdk_input_init ();
+  _gdk_dnd_init ();
+
+  g_signal_emit_by_name (gdk_display_manager_get (),
+			 "display_opened", _gdk_display);
+
+  return GDK_DISPLAY_OBJECT(_gdk_display);
+}
+
+GType
+gdk_display_dfb_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+        {
+          sizeof (GdkDisplayDFBClass),
+          (GBaseInitFunc) NULL,
+          (GBaseFinalizeFunc) NULL,
+          (GClassInitFunc) NULL,
+          NULL,                 /* class_finalize */
+          NULL,                 /* class_data */
+          sizeof (GdkDisplayDFB),
+          0,                    /* n_preallocs */
+          (GInstanceInitFunc) NULL,
+        };
+
+      object_type = g_type_register_static (GDK_TYPE_DISPLAY,
+                                            "GdkDisplayDFB",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+IDirectFBSurface * gdk_display_dfb_create_surface (GdkDisplayDFB *display,int format,int width, int height) { 
+	DFBResult              ret;
+	IDirectFBSurface      *temp;
+	DFBSurfaceDescription  dsc;
+	dsc.flags = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
+      	dsc.width       = width;
+      	dsc.height      = height;
+      	dsc.pixelformat = format;
+	ret = display->directfb->CreateSurface (display->directfb, &dsc, &temp);
+        if (ret)
+        {
+          DirectFBError ("gdk_display_dfb_create_surface ", ret);
+          return NULL;
+        }
+	return temp;
+
+}
+
+
+
+void
+_gdk_windowing_set_default_display (GdkDisplay *display)
+{
+	_gdk_display=GDK_DISPLAY_DFB(display);
+}
+
+G_CONST_RETURN gchar *
+gdk_display_get_name (GdkDisplay *display)
+{
+  return gdk_get_display_arg_name ();
+}
+
+int
+gdk_display_get_n_screens (GdkDisplay *display)
+{
+  return 1;
+}
+
+GdkScreen *
+gdk_display_get_screen (GdkDisplay *display,
+			gint        screen_num)
+{
+  return _gdk_screen;
+}
+
+GdkScreen *
+gdk_display_get_default_screen (GdkDisplay *display)
+{
+  return _gdk_screen;
+}
+
+gboolean
+gdk_display_supports_selection_notification (GdkDisplay *display)
+{
+	return FALSE;
+}
+
+gboolean gdk_display_request_selection_notification  (GdkDisplay *display,
+                                                      GdkAtom     selection)
+
+{
+
+	g_warning("gdk_display_request_selection_notification Unimplemented function \n");
+	return FALSE;
+}
+
+gboolean
+gdk_display_supports_clipboard_persistence (GdkDisplay *display)
+{
+	g_warning("gdk_display_supports_clipboard_persistence Unimplemented function \n");
+	return FALSE;
+}
+
+void
+gdk_display_store_clipboard (GdkDisplay *display,
+                             GdkWindow  *clipboard_window,
+                             guint32     time_,
+                             GdkAtom    *targets,
+                             gint        n_targets)
+{
+
+	g_warning("gdk_display_store_clipboard Unimplemented function \n");
+
+}
+
+
+gboolean
+gdk_display_supports_shapes (GdkDisplay *display)
+{
+       return FALSE;
+}
+
+
+gboolean
+gdk_display_supports_input_shapes (GdkDisplay *display)
+{
+       return FALSE;
+}
+
+
+GdkWindow *gdk_display_get_default_group (GdkDisplay *display)
+{
+  g_return_val_if_fail (GDK_IS_DISPLAY (display), NULL);
+  return  _gdk_parent_root;
+}
+
+
+
+
+static gboolean _gdk_directfb_pointer_implicit_grab = FALSE;
+
+GdkGrabStatus
+gdk_directfb_pointer_grab (GdkWindow    *window,
+                           gint          owner_events,
+                           GdkEventMask  event_mask,
+                           GdkWindow    *confine_to,
+                           GdkCursor    *cursor,
+                           guint32       time,
+                           gboolean      implicit_grab)
+{
+  GdkWindow             *toplevel;
+  GdkWindowImplDirectFB *impl;
+  if (_gdk_directfb_pointer_grab_window)
+    {
+      if (implicit_grab && !_gdk_directfb_pointer_implicit_grab)
+        return GDK_GRAB_ALREADY_GRABBED;
+
+      gdk_pointer_ungrab (time);
+    }
+
+  toplevel = gdk_directfb_window_find_toplevel (window);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
+
+  if (impl->window)
+    {
+      if (impl->window->GrabPointer (impl->window) == DFB_LOCKED)
+        return GDK_GRAB_ALREADY_GRABBED;
+    }
+
+  if (event_mask & GDK_BUTTON_MOTION_MASK)
+    event_mask |= (GDK_BUTTON1_MOTION_MASK |
+                   GDK_BUTTON2_MOTION_MASK |
+                   GDK_BUTTON3_MOTION_MASK);
+
+  _gdk_directfb_pointer_implicit_grab     = implicit_grab;
+  _gdk_directfb_pointer_grab_window       = g_object_ref (window);
+  _gdk_directfb_pointer_grab_owner_events = owner_events;
+
+  _gdk_directfb_pointer_grab_confine      = (confine_to ?
+                                             g_object_ref (confine_to) : NULL);
+  _gdk_directfb_pointer_grab_events       = event_mask;
+  _gdk_directfb_pointer_grab_cursor       = (cursor ?
+                                             gdk_cursor_ref (cursor) : NULL);
+
+
+  gdk_directfb_window_send_crossing_events (NULL,
+                                            window,
+                                            GDK_CROSSING_GRAB);
+
+  return GDK_GRAB_SUCCESS;
+}
+
+
+
+
+void
+gdk_directfb_pointer_ungrab (guint32  time,
+                             gboolean implicit_grab)
+{
+  GdkWindow             *toplevel;
+  GdkWindow             *mousewin;
+  GdkWindow             *old_grab_window;
+  GdkWindowImplDirectFB *impl;
+
+  if (implicit_grab && !_gdk_directfb_pointer_implicit_grab)
+    return;
+
+  if (!_gdk_directfb_pointer_grab_window)
+    return;
+
+  toplevel =
+    gdk_directfb_window_find_toplevel (_gdk_directfb_pointer_grab_window);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
+
+  if (impl->window)
+    impl->window->UngrabPointer (impl->window);
+
+  if (_gdk_directfb_pointer_grab_confine)
+    {
+      g_object_unref (_gdk_directfb_pointer_grab_confine);
+      _gdk_directfb_pointer_grab_confine = NULL;
+    }
+
+  if (_gdk_directfb_pointer_grab_cursor)
+    {
+      gdk_cursor_unref (_gdk_directfb_pointer_grab_cursor);
+      _gdk_directfb_pointer_grab_cursor = NULL;
+    }
+
+  old_grab_window = _gdk_directfb_pointer_grab_window;
+
+  _gdk_directfb_pointer_grab_window   = NULL;
+  _gdk_directfb_pointer_implicit_grab = FALSE;
+
+  mousewin = gdk_window_at_pointer (NULL, NULL);
+  gdk_directfb_window_send_crossing_events (old_grab_window,
+                                            mousewin,
+                                            GDK_CROSSING_UNGRAB);
+  g_object_unref (old_grab_window);
+}
+
+
+
+
+/*
+ *--------------------------------------------------------------
+ * gdk_keyboard_grab
+ *
+ *   Grabs the keyboard to a specific window
+ *
+ * Arguments:
+ *   "window" is the window which will receive the grab
+ *   "owner_events" specifies whether events will be reported as is,
+ *     or relative to "window"
+ *   "time" specifies the time
+ *
+ * Results:
+ *
+ * Side effects:
+ *   requires a corresponding call to gdk_keyboard_ungrab
+ *
+ *--------------------------------------------------------------
+ */
+
+GdkGrabStatus
+gdk_display_keyboard_grab (GdkDisplay *display,GdkWindow *window,
+                   gint       owner_events,
+                   guint32    time)
+{
+  GdkWindow             *toplevel;
+  GdkWindowImplDirectFB *impl;
+
+  g_return_val_if_fail (GDK_IS_WINDOW (window), 0);
+
+  if (_gdk_directfb_keyboard_grab_window)
+    gdk_keyboard_ungrab (time);
+
+  toplevel = gdk_directfb_window_find_toplevel (window);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
+
+  if (impl->window)
+    {
+      if (impl->window->GrabKeyboard (impl->window) == DFB_LOCKED)
+        return GDK_GRAB_ALREADY_GRABBED;
+    }
+
+  _gdk_directfb_keyboard_grab_window = g_object_ref (window);
+  _gdk_directfb_keyboard_grab_owner_events = owner_events;
+  return GDK_GRAB_SUCCESS;
+}
+
+void
+gdk_display_keyboard_ungrab (GdkDisplay *display,guint32 time)
+{
+  GdkWindow             *toplevel;
+  GdkWindowImplDirectFB *impl;
+
+  if (!_gdk_directfb_keyboard_grab_window)
+    return;
+
+  toplevel =
+    gdk_directfb_window_find_toplevel (_gdk_directfb_keyboard_grab_window);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
+
+  if (impl->window)
+    impl->window->UngrabKeyboard (impl->window);
+
+  g_object_unref (_gdk_directfb_keyboard_grab_window);
+  _gdk_directfb_keyboard_grab_window = NULL;
+}
+
+gint
+gdk_display_pointer_is_grabbed (GdkDisplay *display)
+{
+  return _gdk_directfb_pointer_grab_window != NULL;
+}
+
+void
+gdk_display_pointer_ungrab (GdkDisplay *display,guint32 time)
+{
+  gdk_directfb_pointer_ungrab (time, _gdk_directfb_pointer_implicit_grab);
+}
+
+void
+gdk_display_beep (GdkDisplay *display)
+{
+}
+
+void
+gdk_display_sync (GdkDisplay *display)
+{
+}
+
+void
+gdk_display_flush (GdkDisplay *display)
+{
+}
+
+
+
+void
+gdk_notify_startup_complete (void)
+{
+}
+
+#define __GDK_DISPLAY_X11_C__
+#include "gdkaliasdef.c"
+
diff -ruN old/gdk/directfb/gdkdisplay-directfb.h gtk+/gdk/directfb/gdkdisplay-directfb.h
--- old/gdk/directfb/gdkdisplay-directfb.h	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkdisplay-directfb.h	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GDK_DISPLAY_DFB_H
+#define GDK_DISPLAY_DFB_H
+
+#include <directfb.h>
+#include <gdk/gdkdisplay.h>
+#include <gdk/gdkkeys.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GdkDisplayDFB GdkDisplayDFB;
+typedef struct _GdkDisplayDFBClass GdkDisplayDFBClass;
+
+
+#define GDK_TYPE_DISPLAY_DFB              (gdk_display_dfb_get_type())
+#define GDK_DISPLAY_DFB(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_DISPLAY_DFB, GdkDisplayDFB))
+#define GDK_DISPLAY_DFB_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GDK_TYPE_DISPLAY_DFB, GdkDisplayDFBClass))
+#define GDK_IS_DISPLAY_DFB(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_DISPLAY_DFB))
+#define GDK_IS_DISPLAY_DFB_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GDK_TYPE_DISPLAY_DFB))
+#define GDK_DISPLAY_DFB_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), GDK_TYPE_DISPLAY_DFB, GdkDisplayDFBClass))
+
+struct _GdkDisplayDFB
+{
+  GdkDisplay parent;
+  IDirectFB              *directfb;
+  IDirectFBDisplayLayer  *layer;
+  IDirectFBEventBuffer   *buffer;
+  IDirectFBInputDevice   *keyboard;
+  GdkKeymap *keymap;
+};
+
+struct _GdkDisplayDFBClass
+{
+  GdkDisplayClass parent;
+};
+
+GType      gdk_display_dfb_get_type            (void);
+
+IDirectFBSurface * gdk_display_dfb_create_surface (GdkDisplayDFB *display,int format,int width, int height);
+
+G_END_DECLS
+
+#endif /* GDK_DISPLAY_DFB_H */
diff -ruN old/gdk/directfb/gdkdnd-directfb.c gtk+/gdk/directfb/gdkdnd-directfb.c
--- old/gdk/directfb/gdkdnd-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkdnd-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,680 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1999 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkdnd.h"
+#include "gdkproperty.h"
+#include "gdkalias.h"
+
+typedef struct _GdkDragContextPrivate GdkDragContextPrivate;
+
+typedef enum
+{
+  GDK_DRAG_STATUS_DRAG,
+  GDK_DRAG_STATUS_MOTION_WAIT,
+  GDK_DRAG_STATUS_ACTION_WAIT,
+  GDK_DRAG_STATUS_DROP
+} GtkDragStatus;
+
+/* Structure that holds information about a drag in progress.
+ * this is used on both source and destination sides.
+ */
+struct _GdkDragContextPrivate
+{
+  GdkAtom local_selection;
+
+  guint16 last_x;		/* Coordinates from last event */
+  guint16 last_y;
+  guint   drag_status : 4;	/* current status of drag      */
+};
+
+/* Drag Contexts */
+
+static GList          *contexts          = NULL;
+static GdkDragContext *current_dest_drag = NULL;
+
+#define GDK_DRAG_CONTEXT_PRIVATE_DATA(ctx) ((GdkDragContextPrivate *) GDK_DRAG_CONTEXT (ctx)->windowing_data)
+
+
+static gpointer  parent_class = NULL;
+
+
+static void
+gdk_drag_context_init (GdkDragContext *dragcontext)
+{
+  dragcontext->windowing_data = g_new (GdkDragContextPrivate, 1);
+
+  contexts = g_list_prepend (contexts, dragcontext);
+}
+
+static void
+gdk_drag_context_finalize (GObject *object)
+{
+  GdkDragContext        *context = GDK_DRAG_CONTEXT (object);
+  GdkDragContextPrivate *private = GDK_DRAG_CONTEXT_PRIVATE_DATA (object);
+
+  g_list_free (context->targets);
+
+  if (context->source_window)
+    g_object_unref (context->source_window);
+
+  if (context->dest_window)
+    g_object_unref (context->dest_window);
+
+
+  if (private)
+    {
+      g_free (private);
+      context->windowing_data = NULL;
+    }
+
+  contexts = g_list_remove (contexts, context);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gdk_drag_context_class_init (GdkDragContextClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = gdk_drag_context_finalize;
+}
+
+GType
+gdk_drag_context_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+      {
+        sizeof (GdkDragContextClass),
+        (GBaseInitFunc) NULL,
+        (GBaseFinalizeFunc) NULL,
+        (GClassInitFunc) gdk_drag_context_class_init,
+        NULL,           /* class_finalize */
+        NULL,           /* class_data */
+        sizeof (GdkDragContext),
+        0,              /* n_preallocs */
+        (GInstanceInitFunc) gdk_drag_context_init,
+      };
+
+      object_type = g_type_register_static (G_TYPE_OBJECT,
+                                            "GdkDragContext",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+GdkDragContext *
+gdk_drag_context_new (void)
+{
+  return (GdkDragContext *) g_object_new (gdk_drag_context_get_type (), NULL);
+}
+
+void
+gdk_drag_context_ref (GdkDragContext *context)
+{
+  g_object_ref (context);
+}
+
+void
+gdk_drag_context_unref (GdkDragContext *context)
+{
+  g_object_unref (context);
+}
+
+static GdkDragContext *
+gdk_drag_context_find (gboolean     is_source,
+		       GdkWindow   *source,
+		       GdkWindow   *dest)
+{
+  GdkDragContext        *context;
+  GdkDragContextPrivate *private;
+  GList                 *list;
+
+  for (list = contexts; list; list = list->next)
+    {
+      context = (GdkDragContext *) list->data;
+      private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
+
+      if ((!context->is_source == !is_source) &&
+	  ((source == NULL) ||
+           (context->source_window && (context->source_window == source))) &&
+	  ((dest == NULL) ||
+           (context->dest_window && (context->dest_window == dest))))
+	  return context;
+    }
+
+  return NULL;
+}
+
+
+/************************** Public API ***********************/
+
+void
+_gdk_dnd_init (void)
+{
+}
+
+/* Source side */
+
+static void
+local_send_leave (GdkDragContext  *context,
+		  guint32          time)
+{
+  GdkEvent event;
+
+  if ((current_dest_drag != NULL) &&
+      (current_dest_drag->protocol == GDK_DRAG_PROTO_LOCAL) &&
+      (current_dest_drag->source_window == context->source_window))
+    {
+      event.dnd.type       = GDK_DRAG_LEAVE;
+      event.dnd.window     = context->dest_window;
+      /* Pass ownership of context to the event */
+      event.dnd.context    = current_dest_drag;
+      event.dnd.send_event = FALSE;
+      event.dnd.time       = time;
+
+      current_dest_drag = NULL;
+
+      gdk_event_put (&event);
+    }
+}
+
+static void
+local_send_enter (GdkDragContext *context,
+		  guint32         time)
+{
+  GdkDragContextPrivate *private;
+  GdkDragContext        *new_context;
+  GdkEvent event;
+
+  private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
+
+  if (!private->local_selection)
+    private->local_selection = gdk_atom_intern ("LocalDndSelection", FALSE);
+
+  if (current_dest_drag != NULL)
+    {
+      gdk_drag_context_unref (current_dest_drag);
+      current_dest_drag = NULL;
+    }
+
+  new_context = gdk_drag_context_new ();
+  new_context->protocol  = GDK_DRAG_PROTO_LOCAL;
+  new_context->is_source = FALSE;
+
+  new_context->source_window = context->source_window;
+  g_object_ref (new_context->source_window);
+
+  new_context->dest_window   = context->dest_window;
+  g_object_ref (new_context->dest_window);
+
+  new_context->targets = g_list_copy (context->targets);
+
+  gdk_window_set_events (new_context->source_window,
+			 gdk_window_get_events (new_context->source_window) |
+			 GDK_PROPERTY_CHANGE_MASK);
+  new_context->actions = context->actions;
+
+  event.dnd.type       = GDK_DRAG_ENTER;
+  event.dnd.window     = context->dest_window;
+  event.dnd.send_event = FALSE;
+  event.dnd.context    = new_context;
+  event.dnd.time       = time;
+
+  current_dest_drag = new_context;
+
+  (GDK_DRAG_CONTEXT_PRIVATE_DATA (new_context))->local_selection =
+    private->local_selection;
+
+  gdk_event_put (&event);
+}
+
+static void
+local_send_motion (GdkDragContext  *context,
+		    gint            x_root,
+		    gint            y_root,
+		    GdkDragAction   action,
+		    guint32         time)
+{
+  GdkEvent event;
+
+  if ((current_dest_drag != NULL) &&
+      (current_dest_drag->protocol == GDK_DRAG_PROTO_LOCAL) &&
+      (current_dest_drag->source_window == context->source_window))
+    {
+      event.dnd.type       = GDK_DRAG_MOTION;
+      event.dnd.window     = current_dest_drag->dest_window;
+      event.dnd.send_event = FALSE;
+      event.dnd.context    = current_dest_drag;
+      event.dnd.time       = time;
+      event.dnd.x_root     = x_root;
+      event.dnd.y_root     = y_root;
+
+      current_dest_drag->suggested_action = action;
+      current_dest_drag->actions          = action;
+
+      (GDK_DRAG_CONTEXT_PRIVATE_DATA (current_dest_drag))->last_x = x_root;
+      (GDK_DRAG_CONTEXT_PRIVATE_DATA (current_dest_drag))->last_y = y_root;
+
+      GDK_DRAG_CONTEXT_PRIVATE_DATA (context)->drag_status = GDK_DRAG_STATUS_MOTION_WAIT;
+
+      gdk_event_put (&event);
+    }
+}
+
+static void
+local_send_drop (GdkDragContext *context,
+                 guint32         time)
+{
+  GdkEvent event;
+
+  if ((current_dest_drag != NULL) &&
+      (current_dest_drag->protocol == GDK_DRAG_PROTO_LOCAL) &&
+      (current_dest_drag->source_window == context->source_window))
+    {
+      GdkDragContextPrivate *private;
+      private = GDK_DRAG_CONTEXT_PRIVATE_DATA (current_dest_drag);
+
+      event.dnd.type       = GDK_DROP_START;
+      event.dnd.window     = current_dest_drag->dest_window;
+      event.dnd.send_event = FALSE;
+      event.dnd.context    = current_dest_drag;
+      event.dnd.time       = time;
+      event.dnd.x_root     = private->last_x;
+      event.dnd.y_root     = private->last_y;
+
+      gdk_event_put (&event);
+    }
+}
+
+static void
+gdk_drag_do_leave (GdkDragContext *context,
+                   guint32         time)
+{
+  if (context->dest_window)
+    {
+      switch (context->protocol)
+	{
+	case GDK_DRAG_PROTO_LOCAL:
+	  local_send_leave (context, time);
+	  break;
+
+	default:
+	  break;
+	}
+
+      g_object_unref (context->dest_window);
+      context->dest_window = NULL;
+    }
+}
+
+GdkDragContext *
+gdk_drag_begin (GdkWindow *window,
+		GList     *targets)
+{
+  GList          *list;
+  GdkDragContext *new_context;
+
+  g_return_val_if_fail (window != NULL, NULL);
+
+  g_object_ref (window);
+
+  new_context = gdk_drag_context_new ();
+  new_context->is_source     = TRUE;
+  new_context->source_window = window;
+  new_context->targets       = NULL;
+  new_context->actions       = 0;
+
+  for (list = targets; list; list = list->next)
+    new_context->targets = g_list_append (new_context->targets, list->data);
+
+  return new_context;
+}
+
+guint32
+gdk_drag_get_protocol_for_display(GdkDisplay *display, guint32          xid,
+                                   GdkDragProtocol *protocol)
+{
+  GdkWindow *window;
+
+  window = gdk_window_lookup ((GdkNativeWindow) xid);
+
+  if (window &&
+      GPOINTER_TO_INT (gdk_drawable_get_data (window, "gdk-dnd-registered")))
+    {
+      *protocol = GDK_DRAG_PROTO_LOCAL;
+      return xid;
+    }
+
+  *protocol = GDK_DRAG_PROTO_NONE;
+  return 0;
+}
+
+void
+gdk_drag_find_window_for_screen (GdkDragContext   *context,
+                                 GdkWindow        *drag_window,
+                                 GdkScreen        *screen,
+                                 gint              x_root,
+                                 gint              y_root,
+                                 GdkWindow       **dest_window,
+                                 GdkDragProtocol  *protocol)
+{
+  GdkWindow *dest;
+
+  g_return_if_fail (context != NULL);
+
+  dest = gdk_window_get_pointer (NULL, &x_root, &y_root, NULL);
+
+  if (context->dest_window != dest)
+    {
+      guint32 recipient;
+
+      /* Check if new destination accepts drags, and which protocol */
+      if ((recipient = gdk_drag_get_protocol (GDK_WINDOW_DFB_ID (dest),
+                                              protocol)))
+	{
+	  *dest_window = gdk_window_lookup ((GdkNativeWindow) recipient);
+	  if (dest_window)
+            g_object_ref (*dest_window);
+	}
+      else
+	*dest_window = NULL;
+    }
+  else
+    {
+      *dest_window = context->dest_window;
+      if (*dest_window)
+	g_object_ref (*dest_window);
+
+      *protocol = context->protocol;
+    }
+
+}
+
+gboolean
+gdk_drag_motion (GdkDragContext  *context,
+		 GdkWindow       *dest_window,
+		 GdkDragProtocol  protocol,
+		 gint             x_root,
+		 gint             y_root,
+		 GdkDragAction    suggested_action,
+		 GdkDragAction    possible_actions,
+		 guint32          time)
+{
+  GdkDragContextPrivate *private;
+
+  g_return_val_if_fail (context != NULL, FALSE);
+
+  private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
+
+  if (context->dest_window != dest_window)
+    {
+      GdkEvent  event;
+
+      /* Send a leave to the last destination */
+      gdk_drag_do_leave (context, time);
+      private->drag_status = GDK_DRAG_STATUS_DRAG;
+
+      /* Check if new destination accepts drags, and which protocol */
+      if (dest_window)
+	{
+	  context->dest_window = dest_window;
+	  g_object_ref (context->dest_window);
+	  context->protocol = protocol;
+
+	  switch (protocol)
+	    {
+	    case GDK_DRAG_PROTO_LOCAL:
+	      local_send_enter (context, time);
+	      break;
+
+	    default:
+	      break;
+	    }
+	  context->suggested_action = suggested_action;
+	}
+      else
+	{
+	  context->dest_window = NULL;
+	  context->action = 0;
+	}
+
+      /* Push a status event, to let the client know that
+       * the drag changed
+       */
+
+      event.dnd.type       = GDK_DRAG_STATUS;
+      event.dnd.window     = context->source_window;
+      /* We use this to signal a synthetic status. Perhaps
+       * we should use an extra field...
+       */
+      event.dnd.send_event = TRUE;
+      event.dnd.context    = context;
+      event.dnd.time       = time;
+
+      gdk_event_put (&event);
+    }
+  else
+    {
+      context->suggested_action = suggested_action;
+    }
+
+  /* Send a drag-motion event */
+
+  private->last_x = x_root;
+  private->last_y = y_root;
+
+  if (context->dest_window)
+    {
+      if (private->drag_status == GDK_DRAG_STATUS_DRAG)
+	{
+	  switch (context->protocol)
+	    {
+	    case GDK_DRAG_PROTO_LOCAL:
+	      local_send_motion (context,
+                                 x_root, y_root, suggested_action, time);
+	      break;
+
+	    case GDK_DRAG_PROTO_NONE:
+	      g_warning ("GDK_DRAG_PROTO_NONE is not valid in gdk_drag_motion()");
+	      break;
+	    default:
+	      break;
+	    }
+	}
+      else
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+void
+gdk_drag_drop (GdkDragContext *context,
+	       guint32         time)
+{
+  g_return_if_fail (context != NULL);
+
+  if (context->dest_window)
+    {
+      switch (context->protocol)
+	{
+	case GDK_DRAG_PROTO_LOCAL:
+	  local_send_drop (context, time);
+	  break;
+	case GDK_DRAG_PROTO_NONE:
+	  g_warning ("GDK_DRAG_PROTO_NONE is not valid in gdk_drag_drop()");
+	  break;
+	default:
+	  break;
+	}
+    }
+}
+
+void
+gdk_drag_abort (GdkDragContext *context,
+		guint32         time)
+{
+  g_return_if_fail (context != NULL);
+
+  gdk_drag_do_leave (context, time);
+}
+
+/* Destination side */
+
+void
+gdk_drag_status (GdkDragContext   *context,
+		 GdkDragAction     action,
+		 guint32           time)
+{
+  GdkDragContextPrivate *private;
+  GdkDragContext        *src_context;
+  GdkEvent event;
+
+  g_return_if_fail (context != NULL);
+
+  private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
+
+  src_context = gdk_drag_context_find (TRUE,
+				       context->source_window,
+				       context->dest_window);
+
+  if (src_context)
+    {
+      GdkDragContextPrivate *private;
+
+      private = GDK_DRAG_CONTEXT_PRIVATE_DATA (src_context);
+
+      if (private->drag_status == GDK_DRAG_STATUS_MOTION_WAIT)
+	private->drag_status = GDK_DRAG_STATUS_DRAG;
+
+      event.dnd.type       = GDK_DRAG_STATUS;
+      event.dnd.window     = src_context->source_window;
+      event.dnd.send_event = FALSE;
+      event.dnd.context    = src_context;
+      event.dnd.time       = time;
+
+      src_context->action = action;
+
+      gdk_event_put (&event);
+    }
+}
+
+void
+gdk_drop_reply (GdkDragContext   *context,
+		gboolean          ok,
+		guint32           time)
+{
+  g_return_if_fail (context != NULL);
+}
+
+void
+gdk_drop_finish (GdkDragContext   *context,
+		 gboolean          success,
+		 guint32           time)
+{
+  GdkDragContextPrivate *private;
+  GdkDragContext        *src_context;
+  GdkEvent event;
+
+  g_return_if_fail (context != NULL);
+
+  private = GDK_DRAG_CONTEXT_PRIVATE_DATA (context);
+
+  src_context = gdk_drag_context_find (TRUE,
+				       context->source_window,
+				       context->dest_window);
+  if (src_context)
+    {
+      gdk_drag_context_ref (src_context);
+
+      event.dnd.type       = GDK_DROP_FINISHED;
+      event.dnd.window     = src_context->source_window;
+      event.dnd.send_event = FALSE;
+      event.dnd.context    = src_context;
+
+      gdk_event_put (&event);
+    }
+}
+
+gboolean
+gdk_drag_drop_succeeded (GdkDragContext *context)
+{
+	g_warning("gdk_drag_drop_succeeded unimplemented \n");
+	return TRUE;
+}
+
+void
+gdk_window_register_dnd (GdkWindow      *window)
+{
+  g_return_if_fail (window != NULL);
+
+  if (GPOINTER_TO_INT (gdk_drawable_get_data (window, "gdk-dnd-registered")))
+    return;
+
+  gdk_drawable_set_data (window, "gdk-dnd-registered",
+                         GINT_TO_POINTER (TRUE), NULL);
+}
+
+/*************************************************************
+ * gdk_drag_get_selection:
+ *     Returns the selection atom for the current source window
+ *   arguments:
+ *
+ *   results:
+ *************************************************************/
+
+GdkAtom
+gdk_drag_get_selection (GdkDragContext *context)
+{
+  g_return_val_if_fail (context != NULL, GDK_NONE);
+
+  if (context->protocol == GDK_DRAG_PROTO_LOCAL)
+    return (GDK_DRAG_CONTEXT_PRIVATE_DATA (context))->local_selection;
+  else
+    return GDK_NONE;
+}
+
+#define __GDK_DND_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkdrawable-directfb.c gtk+/gdk/directfb/gdkdrawable-directfb.c
--- old/gdk/directfb/gdkdrawable-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkdrawable-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,1095 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+
+#include <string.h>
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+
+
+#include "gdkregion-generic.h"
+#include "gdkalias.h"
+
+#include "cairo-directfb.h"
+
+#define WARN_UNIMPLEMENTED(func)\
+{\
+  static gboolean first_call = TRUE;\
+  if (first_call)\
+    {\
+                        g_message ("unimplemented " func);\
+      first_call = FALSE;\
+    }\
+}
+
+static GdkScreen * gdk_directfb_get_screen (GdkDrawable    *drawable);
+static void gdk_drawable_impl_directfb_class_init (GdkDrawableImplDirectFBClass *klass);
+static void gdk_directfb_draw_lines (GdkDrawable *drawable,
+                                     GdkGC       *gc,
+                                     GdkPoint    *points,
+                                     gint         npoints);
+
+static void inline gdk_directfb_update_region (GdkDrawableImplDirectFB *impl,
+                                               GdkRegion               *region);
+
+static cairo_surface_t *gdk_directfb_ref_cairo_surface (GdkDrawable *drawable);
+
+
+static gboolean  accelerated_alpha_blending = FALSE;
+static gpointer  parent_class               = NULL;
+static const cairo_user_data_key_t gdk_directfb_cairo_key;
+
+
+/**********************************************************
+ * DirectFB specific implementations of generic functions *
+ **********************************************************/
+
+
+static void
+gdk_directfb_set_colormap (GdkDrawable *drawable,
+                           GdkColormap *colormap)
+{
+  GdkDrawableImplDirectFB *impl;
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (impl->colormap == colormap)
+    return;
+
+  if (impl->colormap)
+    g_object_unref (impl->colormap);
+
+  impl->colormap = colormap;
+
+  if (colormap)
+    g_object_ref (colormap);
+}
+
+static GdkColormap*
+gdk_directfb_get_colormap (GdkDrawable *drawable)
+{
+  GdkColormap *retval;
+
+  retval = GDK_DRAWABLE_IMPL_DIRECTFB (drawable)->colormap;
+
+  if (!retval) {
+    retval = gdk_colormap_get_system ();
+	gdk_directfb_set_colormap(drawable,retval);
+  }
+
+  return retval;
+}
+
+static gint
+gdk_directfb_get_depth (GdkDrawable *drawable)
+{
+  GdkDrawableImplDirectFB *impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  return DFB_BITS_PER_PIXEL (impl->format);
+}
+
+static void
+gdk_directfb_get_size (GdkDrawable *drawable,
+                       gint        *width,
+                       gint        *height)
+{
+  GdkDrawableImplDirectFB *impl;
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (width)
+    *width = impl->width;
+
+  if (height)
+    *height = impl->height;
+}
+
+static GdkVisual*
+gdk_directfb_get_visual (GdkDrawable *drawable)
+{
+  return gdk_visual_get_system ();
+}
+
+/* Calculates the real clipping region for a drawable, taking into account
+ * other windows and the gc clip region.
+ */
+static GdkRegion *
+gdk_directfb_clip_region (GdkDrawable  *drawable,
+                          GdkGC        *gc,
+                          GdkRectangle *draw_rect)
+{
+  GdkDrawableImplDirectFB *private;
+  GdkRegion               *clip_region;
+  GdkRegion               *tmpreg;
+  GdkRectangle             rect;
+
+  g_return_val_if_fail (GDK_IS_DRAWABLE (drawable), NULL);
+  g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable), NULL);
+
+  private = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (!draw_rect)
+    {
+      rect.x      = 0;
+      rect.y      = 0;
+      rect.width  = private->width;
+      rect.height = private->height;
+
+      draw_rect = &rect;
+    }
+
+  clip_region = gdk_region_rectangle (draw_rect);
+
+  if (private->buffered && private->paint_region)
+    gdk_region_intersect (clip_region, private->paint_region);
+
+  if (gc)
+    {
+      GdkGCDirectFB *gc_private = GDK_GC_DIRECTFB (gc);
+      GdkRegion     *region     = gc_private->clip_region;
+
+      if (region)
+        {
+          if (gc->clip_x_origin || gc->clip_y_origin)
+            {
+              tmpreg = gdk_region_copy (region);
+
+              gdk_region_offset (tmpreg, gc->clip_x_origin, gc->clip_y_origin);
+              gdk_region_intersect (clip_region, tmpreg);
+              gdk_region_destroy (tmpreg);
+            }
+          else
+            {
+              gdk_region_intersect (clip_region, region);
+            }
+        }
+
+      if (gc_private->values_mask & GDK_GC_SUBWINDOW &&
+          gc_private->values.subwindow_mode == GDK_INCLUDE_INFERIORS)
+        return clip_region;
+    }
+
+  if (GDK_IS_WINDOW (private->wrapper) &&
+      GDK_WINDOW_IS_MAPPED (private->wrapper) &&
+      !GDK_WINDOW_OBJECT (private->wrapper)->input_only)
+    {
+      GList *cur;
+
+      for (cur = GDK_WINDOW_OBJECT (private->wrapper)->children;
+           cur;
+           cur = cur->next)
+        {
+          GdkWindowObject         *cur_private;
+          GdkDrawableImplDirectFB *cur_impl;
+
+          cur_private = GDK_WINDOW_OBJECT (cur->data);
+
+          if (!GDK_WINDOW_IS_MAPPED (cur_private) || cur_private->input_only)
+            continue;
+
+          cur_impl = GDK_DRAWABLE_IMPL_DIRECTFB (cur_private->impl);
+
+          rect.x      = cur_private->x;
+          rect.y      = cur_private->y;
+          rect.width  = cur_impl->width;
+          rect.height = cur_impl->height;
+
+          tmpreg = gdk_region_rectangle (&rect);
+          gdk_region_subtract (clip_region, tmpreg);
+          gdk_region_destroy (tmpreg);
+        }
+    }
+
+  return clip_region;
+}
+
+/* Drawing
+ */
+
+static inline void
+gdk_directfb_set_color (GdkDrawableImplDirectFB *impl,
+                        GdkColor                *color,
+                        guchar                   alpha)
+{
+  if (DFB_PIXELFORMAT_IS_INDEXED (impl->format))
+    {
+      impl->surface->SetColorIndex (impl->surface, color->pixel);
+    }
+  else
+    {
+      impl->surface->SetColor (impl->surface,
+                               color->red   >> 8,
+                               color->green >> 8,
+                               color->blue  >> 8,
+                               alpha);
+    }
+}
+
+static gboolean
+gdk_directfb_setup_for_drawing (GdkDrawableImplDirectFB *impl,
+                                GdkGCDirectFB           *gc_private)
+{
+  DFBSurfaceDrawingFlags flags = DSDRAW_NOFX;
+  GdkColor               color = { 0, 0, 0, 0 };
+  guchar                 alpha = 0xFF;
+
+  if (!impl->surface)
+    return FALSE;
+
+  if (gc_private && gc_private->values_mask & GDK_GC_FOREGROUND)
+    color = gc_private->values.foreground;
+
+  if (gc_private && gc_private->values_mask & GDK_GC_FUNCTION)
+    {
+      switch (gc_private->values.function)
+        {
+        case GDK_COPY:
+          flags = DSDRAW_NOFX;
+          break;
+
+        case GDK_INVERT:
+          color.red = color.green = color.blue = 0xFFFF;
+          alpha = 0x0;
+          flags = DSDRAW_XOR;
+          break;
+
+        case GDK_XOR:
+          alpha = 0x0;
+          flags = DSDRAW_XOR;
+          break;
+
+        case GDK_CLEAR:
+          color.red = color.green = color.blue = 0x0;
+          flags = DSDRAW_NOFX;
+          break;
+
+        case GDK_NOOP:
+          return FALSE;
+
+        case GDK_SET:
+          color.red = color.green = color.blue = 0xFFFF;
+          flags = DSDRAW_NOFX;
+          break;
+
+        default:
+          g_message ("unsupported GC function %d",
+                     gc_private->values.function);
+          flags = DSDRAW_NOFX;
+          break;
+        }
+    }
+
+  gdk_directfb_set_color (impl, &color, alpha);
+
+  impl->surface->SetDrawingFlags (impl->surface, flags);
+
+  return TRUE;
+}
+
+void
+_gdk_directfb_draw_rectangle (GdkDrawable *drawable,
+                              GdkGC       *gc,
+                              gint         filled,
+                              gint         x,
+                              gint         y,
+                              gint         width,
+                              gint         height)
+{
+  GdkDrawableImplDirectFB *impl;
+  GdkRegion               *clip;
+  GdkGCDirectFB           *gc_private = NULL;
+  IDirectFBSurface        *surface    = NULL;
+  gint  i;
+
+  g_return_if_fail (GDK_IS_DRAWABLE (drawable));
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (!impl->surface)
+    return;
+
+
+  if (gc)
+    gc_private = GDK_GC_DIRECTFB (gc);
+
+  if (gc_private)
+    {
+      if (gdk_directfb_enable_color_keying &&
+	  (gc_private->values.foreground.red   >> 8) == gdk_directfb_bg_color_key.r &&
+	  (gc_private->values.foreground.green >> 8) == gdk_directfb_bg_color_key.g &&
+	  (gc_private->values.foreground.blue  >> 8) == gdk_directfb_bg_color_key.b)
+	{
+          if (DFB_PIXELFORMAT_IS_INDEXED (impl->format))
+            impl->surface->SetColorIndex (impl->surface, 255);
+          else
+            impl->surface->SetColor (impl->surface,
+                                     gdk_directfb_bg_color.r,
+                                     gdk_directfb_bg_color.g,
+                                     gdk_directfb_bg_color.b,
+                                     gdk_directfb_bg_color.a);
+	}
+      else
+	{
+          if (!gdk_directfb_setup_for_drawing (impl, gc_private)){
+            return;
+		  }
+	}
+    }
+  else
+    {
+      GdkWindowObject *win = GDK_WINDOW_OBJECT (impl->wrapper);
+
+      if (gdk_directfb_enable_color_keying)
+	{
+          if (DFB_PIXELFORMAT_IS_INDEXED (impl->format))
+            impl->surface->SetColorIndex (impl->surface, 255);
+          else
+            impl->surface->SetColor (impl->surface,
+                                     gdk_directfb_bg_color.r,
+                                     gdk_directfb_bg_color.b,
+                                     gdk_directfb_bg_color.g,
+                                     gdk_directfb_bg_color.a);
+	}
+      else
+	{
+          gdk_directfb_set_color (impl, &win->bg_color, 0xFF);
+	}
+    }
+
+  if (filled)
+    {
+      GdkRectangle  rect = { x, y, width, height };
+
+      clip = gdk_directfb_clip_region (drawable, gc, &rect);
+
+      if (gc_private && gc_private->values_mask & GDK_GC_FILL)
+        {
+          if (gc_private->values.fill == GDK_STIPPLED  &&
+              gc_private->values_mask & GDK_GC_STIPPLE &&
+              gc_private->values.stipple)
+            {
+              surface = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (gc_private->values.stipple)->impl)->surface;
+
+              if (surface)
+                impl->surface->SetBlittingFlags (impl->surface,
+                                                 (DSBLIT_BLEND_ALPHACHANNEL |
+                                                  DSBLIT_COLORIZE));
+            }
+          else if (gc_private->values.fill == GDK_TILED  &&
+                   gc_private->values_mask & GDK_GC_TILE &&
+                   gc_private->values.tile)
+            {
+              surface = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (gc_private->values.tile)->impl)->surface;
+            }
+        }
+
+      if (surface)
+        {
+          if (gc_private->values_mask & GDK_GC_TS_X_ORIGIN)
+            x = gc_private->values.ts_x_origin;
+          if (gc_private->values_mask & GDK_GC_TS_Y_ORIGIN)
+            y = gc_private->values.ts_y_origin;
+
+          for (i = 0; i < clip->numRects; i++)
+            {
+              DFBRegion reg = { clip->rects[i].x1,     clip->rects[i].y1,
+                                clip->rects[i].x2, clip->rects[i].y2 };
+
+              impl->surface->SetClip (impl->surface, &reg);
+              impl->surface->TileBlit (impl->surface, surface, NULL, x, y);
+            }
+
+          impl->surface->SetBlittingFlags (impl->surface, DSBLIT_NOFX);
+          impl->surface->SetClip (impl->surface, NULL);
+        }
+      else  /* normal rectangle filling */
+        {
+          for (i = 0; i < clip->numRects; i++)
+            {
+              DFBRegion *region = (DFBRegion *) &clip->rects[i];
+
+              impl->surface->FillRectangle (impl->surface,
+                                            region->x1,
+                                            region->y1,
+                                            region->x2 - region->x1,
+                                            region->y2 - region->y1);
+            }
+        }
+
+      gdk_directfb_update_region (impl, clip);
+      gdk_region_destroy (clip);
+    }
+  else
+    {
+
+      DFBRegion region = { x, y, x + width+1, y + height+1 };
+      impl->surface->SetClip (impl->surface, &region);
+
+      /*  DirectFB does not draw rectangles the X way. Using DirectFB,
+          a filled Rectangle has the same size as a drawn one, while
+          X draws the rectangle one pixel taller and wider.  */
+      impl->surface->DrawRectangle (impl->surface,
+                                    x, y, width + 1, height + 1);
+      impl->surface->SetClip (impl->surface, NULL);
+
+      _gdk_directfb_update (impl, &region);
+    }
+}
+
+static void
+gdk_directfb_draw_arc (GdkDrawable *drawable,
+                       GdkGC       *gc,
+                       gint         filled,
+                       gint         x,
+                       gint         y,
+                       gint         width,
+                       gint         height,
+                       gint         angle1,
+                       gint         angle2)
+{
+  WARN_UNIMPLEMENTED (G_GNUC_FUNCTION);
+}
+
+static void
+gdk_directfb_draw_polygon (GdkDrawable *drawable,
+                           GdkGC       *gc,
+                           gint         filled,
+                           GdkPoint    *points,
+                           gint         npoints)
+{
+  g_return_if_fail (GDK_IS_DRAWABLE (drawable));
+
+  if (npoints < 3)
+    return;
+
+  if (filled)
+    {
+                if (npoints == 3 ||
+                                (npoints == 4 && 
+                                 points[0].x == points[npoints-1].x &&
+                                 points[0].y == points[npoints-1].y))
+          {
+            GdkDrawableImplDirectFB *impl;
+            GdkRegion               *clip;
+            gint                     i;
+
+            impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+            if (!gdk_directfb_setup_for_drawing (impl, GDK_GC_DIRECTFB (gc)))
+              return;
+
+            clip = gdk_directfb_clip_region (drawable, gc, NULL);
+
+            for (i = 0; i < clip->numRects; i++)
+              {
+                                DFBRegion reg = { clip->rects[i].x1,     clip->rects[i].y1, 
+                    clip->rects[i].x2 , clip->rects[i].y2  };
+
+                impl->surface->SetClip (impl->surface, &reg);
+                impl->surface->FillTriangle (impl->surface,
+                                             points[0].x, points[0].y,
+                                             points[1].x, points[1].y,
+                                             points[2].x, points[2].y);
+
+              }
+            impl->surface->SetClip (impl->surface, NULL);
+
+            gdk_directfb_update_region (impl, clip);
+            gdk_region_destroy (clip);
+
+            return;
+          }
+                else
+                        g_message ("filled polygons with n > 3 are not yet supported, "
+                     "drawing outlines");
+    }
+
+  if (points[0].x != points[npoints-1].x ||
+      points[0].y != points[npoints-1].y)
+    {
+      GdkPoint *tmp_points;
+
+      tmp_points = g_new (GdkPoint, npoints + 1);
+      memcpy (tmp_points, points, npoints * sizeof (GdkPoint));
+      tmp_points[npoints].x = points[0].x;
+      tmp_points[npoints].y = points[0].y;
+
+      gdk_directfb_draw_lines (drawable, gc, tmp_points, npoints + 1);
+
+      g_free (tmp_points);
+    }
+  else
+    {
+      gdk_directfb_draw_lines (drawable, gc, points, npoints);
+    }
+}
+
+static void
+gdk_directfb_draw_text (GdkDrawable *drawable,
+                        GdkFont     *font,
+                        GdkGC       *gc,
+                        gint         x,
+                        gint         y,
+                        const gchar *text,
+                        gint         text_length)
+{
+  WARN_UNIMPLEMENTED (G_GNUC_FUNCTION);
+}
+
+static void
+gdk_directfb_draw_text_wc (GdkDrawable    *drawable,
+                           GdkFont        *font,
+                           GdkGC          *gc,
+                           gint            x,
+                           gint            y,
+                           const GdkWChar *text,
+                           gint            text_length)
+{
+  WARN_UNIMPLEMENTED (G_GNUC_FUNCTION);
+}
+
+static void
+gdk_directfb_draw_drawable (GdkDrawable *drawable,
+                            GdkGC       *gc,
+                            GdkDrawable *src,
+                            gint         xsrc,
+                            gint         ysrc,
+                            gint         xdest,
+                            gint         ydest,
+                            gint         width,
+                            gint         height)
+{
+  GdkDrawableImplDirectFB *impl;
+  GdkDrawableImplDirectFB *src_impl;
+  GdkRegion               *clip;
+  GdkRectangle             dest_rect = { xdest,
+                                         ydest,
+                xdest + width ,
+                ydest + height};
+
+  DFBRectangle rect = { xsrc, ysrc, width, height };
+  gint i;
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (!impl->surface)
+    return;
+
+  if (GDK_IS_PIXMAP (src))
+    src_impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (src)->impl);
+  else if (GDK_IS_WINDOW (src))
+    src_impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (src)->impl);
+  else if (GDK_IS_DRAWABLE_IMPL_DIRECTFB (src))
+    src_impl = GDK_DRAWABLE_IMPL_DIRECTFB (src);
+  else
+    return;
+
+  clip = gdk_directfb_clip_region (drawable, gc, &dest_rect);
+
+  for (i = 0; i < clip->numRects; i++)
+    {
+      DFBRegion reg = { clip->rects[i].x1,     clip->rects[i].y1,
+                        clip->rects[i].x2 , clip->rects[i].y2 };
+
+      impl->surface->SetClip (impl->surface, &reg);
+      impl->surface->Blit (impl->surface, src_impl->surface, &rect,
+                           xdest, ydest);
+    }
+  impl->surface->SetClip (impl->surface, NULL);
+  gdk_directfb_update_region (impl, clip);
+  gdk_region_destroy (clip);
+}
+
+static void
+gdk_directfb_draw_points (GdkDrawable *drawable,
+                          GdkGC       *gc,
+                          GdkPoint    *points,
+                          gint         npoints)
+{
+  GdkDrawableImplDirectFB *impl;
+  GdkRegion               *clip;
+
+  DFBRegion region = { points->x, points->y, points->x, points->y };
+
+  if (npoints < 1)
+    return;
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (!gdk_directfb_setup_for_drawing (impl, GDK_GC_DIRECTFB (gc)))
+    return;
+
+  clip = gdk_directfb_clip_region (drawable, gc, NULL);
+
+  while (npoints > 0)
+    {
+      if (gdk_region_point_in (clip, points->x, points->y))
+        {
+          impl->surface->FillRectangle (impl->surface,
+                                        points->x, points->y, 1, 1);
+
+          if (points->x < region.x1)
+            region.x1 = points->x;
+          if (points->x > region.x2)
+            region.x2 = points->x;
+
+          if (points->y < region.y1)
+            region.y1 = points->y;
+          if (points->y > region.y2)
+            region.y2 = points->y;
+        }
+
+      npoints--;
+      points++;
+    }
+
+  gdk_region_destroy (clip);
+
+  _gdk_directfb_update (impl, &region);
+}
+
+static void
+gdk_directfb_draw_segments (GdkDrawable *drawable,
+                            GdkGC       *gc,
+                            GdkSegment  *segs,
+                            gint         nsegs)
+{
+  GdkDrawableImplDirectFB *impl;
+  GdkRegion               *clip;
+  gint                     i;
+
+  DFBRegion region = { segs->x1, segs->y1, segs->x2, segs->y2 };
+
+  if (nsegs < 1)
+    return;
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (!gdk_directfb_setup_for_drawing (impl, GDK_GC_DIRECTFB (gc)))
+    return;
+
+  clip = gdk_directfb_clip_region (drawable, gc, NULL);
+
+  for (i = 0; i < clip->numRects; i++)
+    {
+      DFBRegion reg = { clip->rects[i].x1,   clip->rects[i].y1,
+                        clip->rects[i].x2, clip->rects[i].y2 };
+
+      impl->surface->SetClip (impl->surface, &reg);
+
+      impl->surface->DrawLines (impl->surface, (DFBRegion *)segs, nsegs);
+    }
+
+  impl->surface->SetClip (impl->surface, NULL);
+
+  gdk_region_destroy (clip);
+
+  /* everything below can be omitted if the drawing is buffered */
+  if (impl->buffered)
+    return;
+
+  if (region.x1 > region.x2)
+    {
+      region.x1 = segs->x2;
+      region.x2 = segs->x1;
+    }
+  if (region.y1 > region.y2)
+    {
+      region.y1 = segs->y2;
+      region.y2 = segs->y1;
+    }
+
+  while (nsegs > 1)
+    {
+      nsegs--;
+      segs++;
+
+      if (segs->x1 < region.x1)
+        region.x1 = segs->x1;
+      if (segs->x2 < region.x1)
+        region.x1 = segs->x2;
+
+      if (segs->y1 < region.y1)
+        region.y1 = segs->y1;
+      if (segs->y2 < region.y1)
+        region.y1 = segs->y2;
+
+      if (segs->x1 > region.x2)
+        region.x2 = segs->x1;
+      if (segs->x2 > region.x2)
+        region.x2 = segs->x2;
+
+      if (segs->y1 > region.y2)
+        region.y2 = segs->y1;
+      if (segs->y2 > region.y2)
+        region.y2 = segs->y2;
+    }
+
+  _gdk_directfb_update (impl, &region);
+}
+
+static void
+gdk_directfb_draw_lines (GdkDrawable *drawable,
+                         GdkGC       *gc,
+                         GdkPoint    *points,
+                         gint         npoints)
+{
+  GdkDrawableImplDirectFB *impl;
+  GdkRegion               *clip;
+  gint                     i;
+
+  DFBRegion lines[npoints > 1 ? npoints - 1 : 1];
+
+  DFBRegion region = { points->x, points->y, points->x, points->y };
+
+  if (npoints < 2)
+    return;
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (!gdk_directfb_setup_for_drawing (impl, GDK_GC_DIRECTFB (gc)))
+    return;
+
+  /* create an array of DFBRegions so we can use DrawLines */
+
+  lines[0].x1 = points->x;
+  lines[0].y1 = points->y;
+
+  for (i = 0; i < npoints - 2; i++)
+    {
+      points++;
+
+      lines[i].x2 = lines[i+1].x1 = points->x;
+      lines[i].y2 = lines[i+1].y1 = points->y;
+
+      if (points->x < region.x1)
+        region.x1 = points->x;
+
+      if (points->y < region.y1)
+        region.y1 = points->y;
+
+      if (points->x > region.x2)
+        region.x2 = points->x;
+
+      if (points->y > region.y2)
+        region.y2 = points->y;
+    }
+
+  points++;
+  lines[i].x2 = points->x;
+  lines[i].y2 = points->y;
+
+  clip = gdk_directfb_clip_region (drawable, gc, NULL);
+
+  for (i = 0; i < clip->numRects; i++)
+    {
+      DFBRegion reg = { clip->rects[i].x1,   clip->rects[i].y1,
+                        clip->rects[i].x2, clip->rects[i].y2 };
+
+      impl->surface->SetClip (impl->surface, &reg);
+      impl->surface->DrawLines (impl->surface, lines, npoints - 1);
+    }
+
+  impl->surface->SetClip (impl->surface, NULL);
+
+  gdk_region_destroy (clip);
+
+  _gdk_directfb_update (impl, &region);
+}
+
+static void
+gdk_directfb_draw_image (GdkDrawable *drawable,
+                         GdkGC       *gc,
+                         GdkImage    *image,
+                         gint         xsrc,
+                         gint         ysrc,
+                         gint         xdest,
+                         gint         ydest,
+                         gint         width,
+                         gint         height)
+{
+  GdkDrawableImplDirectFB *impl;
+  GdkImageDirectFB        *image_private;
+  GdkRegion               *clip;
+  GdkRectangle             dest_rect = { xdest, ydest, width, height };
+
+  gint pitch = 0;
+  gint i;
+
+  g_return_if_fail (GDK_IS_DRAWABLE (drawable));
+  g_return_if_fail (image != NULL);
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+  image_private = image->windowing_data;
+
+  if (!impl->surface)
+    return;
+
+  clip = gdk_directfb_clip_region (drawable, gc, &dest_rect);
+
+  if (!gdk_region_empty (clip))
+    {
+      DFBRectangle  src_rect = { xsrc, ysrc, width, height };
+
+      image_private->surface->Unlock (image_private->surface);
+
+      for (i = 0; i < clip->numRects; i++)
+        {
+          DFBRegion reg = { clip->rects[i].x1,     clip->rects[i].y1,
+                            clip->rects[i].x2 , clip->rects[i].y2  };
+
+          impl->surface->SetClip (impl->surface, &reg);
+          impl->surface->Blit (impl->surface,
+                               image_private->surface, &src_rect,
+                               xdest, ydest);
+        }
+      impl->surface->SetClip (impl->surface, NULL);
+
+      image_private->surface->Lock (image_private->surface, DSLF_WRITE,
+                                    &image->mem, &pitch);
+      image->bpl = pitch;
+
+      gdk_directfb_update_region (impl, clip);
+    }
+
+  gdk_region_destroy (clip);
+}
+
+static inline void
+convert_rgba_pixbuf_to_image (guint32 *src,
+                              guint    src_pitch,
+                              guint32 *dest,
+                              guint    dest_pitch,
+                              guint    width,
+                              guint    height)
+{
+  guint i;
+
+  while (height--)
+    {
+      for (i = 0; i < width; i++)
+        {
+          guint32 pixel = GUINT32_FROM_BE (src[i]);
+          dest[i] = (pixel >> 8) | (pixel << 24);
+        }
+
+      src  += src_pitch;
+      dest += dest_pitch;
+    }
+}
+
+static inline void
+convert_rgb_pixbuf_to_image (guchar  *src,
+                             guint    src_pitch,
+                             guint32 *dest,
+                             guint    dest_pitch,
+                             guint    width,
+                             guint    height)
+{
+  guint   i;
+  guchar *s;
+
+  while (height--)
+    {
+      s = src;
+
+      for (i = 0; i < width; i++, s += 3)
+        dest[i] = 0xFF000000 | (s[0] << 16) | (s[1] << 8) | s[2];
+
+      src  += src_pitch;
+      dest += dest_pitch;
+    }
+}
+
+/*
+ * Object stuff
+ */
+
+static void
+gdk_drawable_impl_directfb_finalize (GObject *object)
+{
+  GdkDrawableImplDirectFB *impl;
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (object);
+
+  gdk_directfb_set_colormap (GDK_DRAWABLE (object), NULL);
+  if( impl->cairo_surface ) {
+	cairo_surface_finish(impl->cairo_surface);
+  }
+  if( impl->surface )
+  	impl->surface->Release (impl->surface);
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gdk_drawable_impl_directfb_class_init (GdkDrawableImplDirectFBClass *klass)
+{
+  GdkDrawableClass *drawable_class = GDK_DRAWABLE_CLASS (klass);
+  GObjectClass     *object_class   = G_OBJECT_CLASS (klass);
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = gdk_drawable_impl_directfb_finalize;
+
+  drawable_class->create_gc      = _gdk_directfb_gc_new;
+  drawable_class->draw_rectangle = _gdk_directfb_draw_rectangle;
+  drawable_class->draw_arc       = gdk_directfb_draw_arc;
+  drawable_class->draw_polygon   = gdk_directfb_draw_polygon;
+  drawable_class->draw_text      = gdk_directfb_draw_text;
+  drawable_class->draw_text_wc   = gdk_directfb_draw_text_wc;
+  drawable_class->draw_drawable  = gdk_directfb_draw_drawable;
+  drawable_class->draw_points    = gdk_directfb_draw_points;
+  drawable_class->draw_segments  = gdk_directfb_draw_segments;
+  drawable_class->draw_lines     = gdk_directfb_draw_lines;
+#if 0
+  drawable_class->draw_glyphs    = NULL;
+  drawable_class->draw_glyphs_transformed    = NULL;
+#endif
+  drawable_class->draw_image     = gdk_directfb_draw_image;
+
+  drawable_class->ref_cairo_surface = gdk_directfb_ref_cairo_surface;
+  drawable_class->set_colormap   = gdk_directfb_set_colormap;
+  drawable_class->get_colormap   = gdk_directfb_get_colormap;
+
+  drawable_class->get_depth      = gdk_directfb_get_depth;
+  drawable_class->get_visual     = gdk_directfb_get_visual;
+
+  drawable_class->get_size       = gdk_directfb_get_size;
+
+  drawable_class->_copy_to_image = _gdk_directfb_copy_to_image;
+        drawable_class->get_screen = gdk_directfb_get_screen;
+
+  /* check for hardware-accelerated alpha-blending */
+  {
+    DFBGraphicsDeviceDescription desc;
+                _gdk_display->directfb->GetDeviceDescription ( _gdk_display->directfb, &desc);
+
+    accelerated_alpha_blending =
+      ((desc.acceleration_mask & DFXL_BLIT) &&
+       (desc.blitting_flags & DSBLIT_BLEND_ALPHACHANNEL));
+  }
+}
+
+GType
+gdk_drawable_impl_directfb_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+        {
+          sizeof (GdkDrawableImplDirectFBClass),
+          (GBaseInitFunc) NULL,
+          (GBaseFinalizeFunc) NULL,
+          (GClassInitFunc) gdk_drawable_impl_directfb_class_init,
+          NULL,           /* class_finalize */
+          NULL,           /* class_data */
+          sizeof (GdkDrawableImplDirectFB),
+          0,              /* n_preallocs */
+          (GInstanceInitFunc) NULL,
+        };
+
+      object_type = g_type_register_static (GDK_TYPE_DRAWABLE,
+                                            "GdkDrawableImplDirectFB",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+static inline void
+gdk_directfb_update_region (GdkDrawableImplDirectFB *impl,
+                            GdkRegion               *region)
+{
+  DFBRegion reg = { region->extents.x1,     region->extents.y1,
+                    region->extents.x2 , region->extents.y2  };
+
+  _gdk_directfb_update (impl, &reg);
+}
+
+void
+_gdk_directfb_update (GdkDrawableImplDirectFB *impl,
+                      DFBRegion               *region)
+{
+  g_return_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (impl));
+
+  if (impl->buffered)
+    return;
+
+  if (!impl->surface)
+    return;
+
+  impl->surface->Flip (impl->surface, region, 0);
+}
+
+
+static GdkScreen * gdk_directfb_get_screen (GdkDrawable    *drawable){
+        return gdk_screen_get_default();
+}
+
+static void
+gdk_directfb_cairo_surface_destroy (void *data)
+{
+  GdkDrawableImplDirectFB *impl = data;
+  impl->cairo_surface = NULL;
+}
+
+
+static cairo_surface_t *
+gdk_directfb_ref_cairo_surface (GdkDrawable *drawable)
+{
+    g_return_val_if_fail (GDK_IS_DRAWABLE (drawable), NULL);
+    g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable), NULL);
+
+    GdkDrawableImplDirectFB *impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+	IDirectFB *dfb = GDK_DISPLAY_DFB(gdk_drawable_get_display(drawable))->directfb;
+    if (!impl->cairo_surface) {
+	impl->cairo_surface = cairo_directfb_surface_create(dfb ,impl->surface);
+      	cairo_surface_set_user_data (impl->cairo_surface, 
+			             &gdk_directfb_cairo_key,drawable, 
+				     gdk_directfb_cairo_surface_destroy);
+		//XXX!!! MAJOR HACK so cairo coexists with direct drawing
+		//impl->surface->Unlock( impl->surface );
+    } else {
+        cairo_surface_reference (impl->cairo_surface);
+    }
+  g_assert( impl->cairo_surface != NULL);
+  return impl->cairo_surface;
+}
+
+#define __GDK_DRAWABLE_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkevents-directfb.c gtk+/gdk/directfb/gdkevents-directfb.c
--- old/gdk/directfb/gdkevents-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkevents-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,829 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include "config.h"
+#include "gdk.h"
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+
+#include "gdkkeysyms.h"
+
+#include "gdkinput-directfb.h"
+#include <string.h>
+
+#ifndef __GDK_X_H__
+#define __GDK_X_H__
+gboolean gdk_net_wm_supports (GdkAtom property);
+#endif
+
+#include "gdkalias.h"
+
+#define EventBuffer _gdk_display->buffer
+#define DirectFB _gdk_display->directfb
+
+
+
+
+#include "gdkaliasdef.c"
+
+/*********************************************
+ * Functions for maintaining the event queue *
+ *********************************************/
+
+static GdkEvent * gdk_event_translate  (DFBWindowEvent  *dfbevent,
+                                        GdkWindow       *window);
+
+/*
+ * Private variable declarations
+ */
+static GList *client_filters;  /* Filters for client messages */
+
+static void
+dfb_events_process_window_event (DFBWindowEvent *event)
+{
+  GdkWindow *window = gdk_directfb_window_id_table_lookup (event->window_id);
+
+  if (! window)
+     return;
+
+  gdk_event_translate (event, window);
+}
+
+static gboolean
+gdk_event_send_client_message_by_window (GdkEvent *event,
+                                        GdkWindow *window)
+{
+  GdkEvent *new_event;
+
+  g_return_val_if_fail(event != NULL, FALSE);
+  g_return_val_if_fail(GDK_IS_WINDOW(window), FALSE);
+
+  new_event = gdk_directfb_event_make (window, GDK_CLIENT_EVENT);
+  new_event->client.message_type = event->client.message_type;
+  new_event->client.data_format = event->client.data_format;
+  memcpy(&new_event->client.data,
+        &event->client.data,
+        sizeof(event->client.data));
+
+  return TRUE;
+}
+
+
+static void
+dfb_events_dispatch (void)
+{
+  GdkDisplay *display = gdk_display_get_default ();
+  GdkEvent   *event;
+
+  while ((event = _gdk_event_unqueue (display)) != NULL)
+    {
+      if (_gdk_event_func)
+        (*_gdk_event_func) (event, _gdk_event_data);
+
+      gdk_event_free (event);
+    }
+}
+
+static gboolean
+dfb_events_io_func (GIOChannel   *channel,
+                    GIOCondition  condition,
+                    gpointer      data)
+{
+  gsize      i;
+  gsize      read;
+  GIOStatus  result;
+  DFBEvent   buf[23];
+  DFBEvent  *event;
+
+  result = g_io_channel_read_chars (channel,
+                                    (gchar *) buf, sizeof (buf), &read, NULL);
+
+  if (result == G_IO_STATUS_ERROR)
+    {
+      g_warning ("%s: GIOError occured", __FUNCTION__);
+      return TRUE;
+    }
+
+  read /= sizeof (DFBEvent);
+
+  for (i = 0, event = buf; i < read; i++, event++)
+    {
+      switch (event->clazz)
+        {
+        case DFEC_WINDOW:
+          dfb_events_process_window_event (&event->window);
+          break;
+        default:
+          break;
+        }
+    }
+
+  EventBuffer->Reset (EventBuffer);
+
+  dfb_events_dispatch ();
+
+  return TRUE;
+}
+
+void
+_gdk_events_init (void)
+{
+  GIOChannel *channel;
+  GSource    *source;
+  DFBResult   ret;
+  gint        fd;
+
+  ret = DirectFB->CreateEventBuffer (DirectFB, &EventBuffer);
+  if (ret)
+    {
+      DirectFBError ("_gdk_events_init: "
+                     "IDirectFB::CreateEventBuffer() failed", ret);
+      return;
+    }
+
+  ret = EventBuffer->CreateFileDescriptor (EventBuffer, &fd);
+  if (ret)
+    {
+      DirectFBError ("_gdk_events_init: "
+                     "IDirectFBEventBuffer::CreateFileDescriptor() failed",
+                     ret);
+      return;
+    }
+
+  channel = g_io_channel_unix_new (fd);
+
+  g_io_channel_set_encoding (channel, NULL, NULL);
+  g_io_channel_set_buffered (channel, FALSE);
+
+  source = g_io_create_watch (channel, G_IO_IN);
+
+  g_source_set_priority (source, G_PRIORITY_DEFAULT);
+  g_source_set_can_recurse (source, TRUE);
+  g_source_set_callback (source, (GSourceFunc) dfb_events_io_func, NULL, NULL);
+
+  g_source_attach (source, NULL);
+  g_source_unref (source);
+}
+
+gboolean
+gdk_events_pending (void)
+{
+  GdkDisplay *display = gdk_display_get_default ();
+
+  return _gdk_event_queue_find_first (display) ? TRUE : FALSE;
+}
+
+GdkEvent *
+gdk_event_get_graphics_expose (GdkWindow *window)
+{
+  GdkDisplay *display;
+  GList      *list;
+
+  g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
+
+  display = gdk_drawable_get_display (GDK_DRAWABLE (window));
+
+  for (list = _gdk_event_queue_find_first (display); list; list = list->next)
+    {
+      GdkEvent *event = list->data;
+      if (event->type == GDK_EXPOSE && event->expose.window == window)
+        break;
+    }
+
+  if (list)
+    {
+      GdkEvent *retval = list->data;
+
+      _gdk_event_queue_remove_link (display, list);
+      g_list_free_1 (list);
+
+      return retval;
+    }
+
+  return NULL;
+}
+
+void
+_gdk_events_queue (GdkDisplay *display)
+{
+}
+
+void
+gdk_flush (void)
+{
+gdk_display_flush ( GDK_DISPLAY_OBJECT(_gdk_display));
+}
+
+/* Sends a ClientMessage to all toplevel client windows */
+gboolean
+gdk_event_send_client_message_for_display (GdkDisplay *display,
+                                           GdkEvent   *event,
+                                           guint32     xid)
+{
+  GdkWindow *win = NULL;
+  gboolean ret = TRUE;
+
+  g_return_val_if_fail(event != NULL, FALSE);
+
+  win = gdk_window_lookup_for_display (display, (GdkNativeWindow) xid);
+
+  g_return_val_if_fail(win != NULL, FALSE);
+
+  if ((GDK_WINDOW_OBJECT(win)->window_type != GDK_WINDOW_CHILD) &&
+      (g_object_get_data (G_OBJECT (win), "gdk-window-child-handler")))
+    {
+      /* Managed window, check children */
+      GList *ltmp = NULL;
+      for (ltmp = GDK_WINDOW_OBJECT(win)->children; ltmp; ltmp = ltmp->next)
+       {
+         ret &= gdk_event_send_client_message_by_window (event,
+                                                         GDK_WINDOW(ltmp->data));
+       }
+    }
+  else
+    {
+      ret &= gdk_event_send_client_message_by_window (event, win);
+    }
+
+  return ret;
+}
+
+/*****/
+
+guint32
+gdk_directfb_get_time (void)
+{
+  GTimeVal tv;
+
+  g_get_current_time (&tv);
+
+  return (guint32) tv.tv_sec * 1000 + tv.tv_usec / 1000;
+}
+
+void
+gdk_directfb_event_windows_add (GdkWindow *window)
+{
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  if (!impl->window)
+    return;
+
+  if (EventBuffer)
+    impl->window->AttachEventBuffer (impl->window, EventBuffer);
+  else
+    impl->window->CreateEventBuffer (impl->window, &EventBuffer);
+}
+
+GdkWindow *
+gdk_directfb_child_at (GdkWindow *window,
+                       gint      *winx,
+                       gint      *winy)
+{
+  GdkWindowObject *private;
+  GList           *list;
+
+  g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
+
+  private = GDK_WINDOW_OBJECT (window);
+  for (list = private->children; list; list = list->next)
+    {
+      GdkWindowObject *win = list->data;
+
+      if (GDK_WINDOW_IS_MAPPED (win) &&
+          *winx >= win->x  &&
+          *winx <  win->x + GDK_DRAWABLE_IMPL_DIRECTFB (win->impl)->width  &&
+          *winy >= win->y  &&
+          *winy <  win->y + GDK_DRAWABLE_IMPL_DIRECTFB (win->impl)->height)
+        {
+          *winx -= win->x;
+          *winy -= win->y;
+
+          return gdk_directfb_child_at (GDK_WINDOW (win), winx, winy );
+        }
+    }
+
+  return window;
+}
+
+static GdkEvent *
+gdk_event_translate (DFBWindowEvent *dfbevent,
+                     GdkWindow      *window)
+{
+  GdkWindowObject *private;
+  GdkDisplay      *display;
+  GdkEvent        *event    = NULL;
+
+  g_return_val_if_fail (dfbevent != NULL, NULL);
+  g_return_val_if_fail (GDK_IS_WINDOW (window), NULL);
+
+  private = GDK_WINDOW_OBJECT (window);
+
+  g_object_ref (G_OBJECT (window));
+  display = gdk_drawable_get_display (GDK_DRAWABLE (window));
+
+  switch (dfbevent->type)
+    {
+    case DWET_BUTTONDOWN:
+    case DWET_BUTTONUP:
+      {
+        static gboolean  click_grab = FALSE;
+        GdkWindow       *child;
+        gint             wx, wy;
+        guint            mask;
+        guint            button;
+
+        _gdk_directfb_mouse_x = wx = dfbevent->cx;
+        _gdk_directfb_mouse_y = wy = dfbevent->cy;
+
+        switch (dfbevent->button)
+          {
+          case DIBI_LEFT:
+            button = 1;
+            mask   = GDK_BUTTON1_MASK;
+            break;
+          case DIBI_MIDDLE:
+            button = 2;
+            mask   = GDK_BUTTON2_MASK;
+            break;
+          case DIBI_RIGHT:
+            button = 3;
+            mask   = GDK_BUTTON3_MASK;
+            break;
+          default:
+            button = dfbevent->button + 1;
+            mask   = 0;
+            break;
+          }
+
+        child = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+
+        if (_gdk_directfb_pointer_grab_window &&
+            (_gdk_directfb_pointer_grab_events & (dfbevent->type ==
+                                                  DWET_BUTTONDOWN ?
+                                                  GDK_BUTTON_PRESS_MASK :
+                                                  GDK_BUTTON_RELEASE_MASK)) &&
+            (_gdk_directfb_pointer_grab_owner_events == FALSE ||
+             child == _gdk_parent_root) )
+          {
+            GdkDrawableImplDirectFB *impl;
+
+            child = _gdk_directfb_pointer_grab_window;
+            impl  = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (child)->impl);
+
+            dfbevent->x = dfbevent->cx - impl->abs_x;
+            dfbevent->y = dfbevent->cy - impl->abs_y;
+          }
+        else if (!_gdk_directfb_pointer_grab_window ||
+                 (_gdk_directfb_pointer_grab_owner_events == TRUE))
+          {
+            dfbevent->x = wx;
+            dfbevent->y = wy;
+          }
+        else
+          {
+            child = NULL;
+          }
+
+        if (dfbevent->type == DWET_BUTTONDOWN)
+          _gdk_directfb_modifiers |= mask;
+        else
+          _gdk_directfb_modifiers &= ~mask;
+
+        if (child)
+          {
+            event =
+              gdk_directfb_event_make (child,
+                                       dfbevent->type == DWET_BUTTONDOWN ?
+                                       GDK_BUTTON_PRESS : GDK_BUTTON_RELEASE);
+
+            event->button.x_root = _gdk_directfb_mouse_x;
+            event->button.y_root = _gdk_directfb_mouse_y;
+
+            event->button.x = dfbevent->x;
+            event->button.y = dfbevent->y;
+
+            event->button.state  = _gdk_directfb_modifiers;
+            event->button.button = button;
+            event->button.device = display->core_pointer;
+
+            GDK_NOTE (EVENTS,
+                      g_message ("button: %d at %d,%d %s with state 0x%08x",
+                                 event->button.button,
+                                 (int)event->button.x, (int)event->button.y,
+                                 dfbevent->type == DWET_BUTTONDOWN ?
+                                 "pressed" : "released",
+                                 _gdk_directfb_modifiers));
+
+            if (dfbevent->type == DWET_BUTTONDOWN)
+              _gdk_event_button_generate (display, event);
+          }
+
+        /* Handle implicit button grabs: */
+        if (dfbevent->type == DWET_BUTTONDOWN  &&  !click_grab  &&  child)
+          {
+            if (gdk_directfb_pointer_grab (child, FALSE,
+                                           gdk_window_get_events (child),
+                                           NULL, NULL,
+                                           GDK_CURRENT_TIME,
+                                           TRUE) == GDK_GRAB_SUCCESS)
+              click_grab = TRUE;
+          }
+        else if (dfbevent->type == DWET_BUTTONUP &&
+                 !(_gdk_directfb_modifiers & (GDK_BUTTON1_MASK |
+                                              GDK_BUTTON2_MASK |
+                                              GDK_BUTTON3_MASK)) && click_grab)
+          {
+            gdk_directfb_pointer_ungrab (GDK_CURRENT_TIME, TRUE);
+            click_grab = FALSE;
+          }
+      }
+      break;
+
+    case DWET_MOTION:
+      {
+        GdkWindow *event_win=NULL;
+        GdkWindow *child;
+
+        _gdk_directfb_mouse_x = dfbevent->cx;
+        _gdk_directfb_mouse_y = dfbevent->cy;
+
+	//child = gdk_directfb_child_at (window, &dfbevent->x, &dfbevent->y);
+    /* Go all the way to root to catch popup menus */
+    int wx=_gdk_directfb_mouse_x;
+    int wy=_gdk_directfb_mouse_y;
+	child = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+
+	event_win = gdk_directfb_pointer_event_window (child, GDK_MOTION_NOTIFY);
+
+
+	if (event_win)
+	  {
+
+	    if (event_win == _gdk_directfb_pointer_grab_window) {
+		GdkDrawableImplDirectFB *impl;
+
+		child = _gdk_directfb_pointer_grab_window;
+		impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (child)->impl);
+
+		dfbevent->x = _gdk_directfb_mouse_x - impl->abs_x;
+		dfbevent->y = _gdk_directfb_mouse_y - impl->abs_y;
+	      }
+
+	    event = gdk_directfb_event_make (child, GDK_MOTION_NOTIFY);
+
+	    event->motion.x_root = _gdk_directfb_mouse_x;
+	    event->motion.y_root = _gdk_directfb_mouse_y;
+
+	    //event->motion.x = dfbevent->x;
+	    //event->motion.y = dfbevent->y;
+	    event->motion.x = wx;
+	    event->motion.y = wy;
+
+	    event->motion.state   = _gdk_directfb_modifiers;
+	    event->motion.is_hint = FALSE;
+	    event->motion.device  = display->core_pointer;
+
+	    if (GDK_WINDOW_OBJECT (event_win)->event_mask &
+		GDK_POINTER_MOTION_HINT_MASK)
+	      {
+		while (EventBuffer->PeekEvent (EventBuffer,
+					       DFB_EVENT (dfbevent)) == DFB_OK
+		       && dfbevent->type == DWET_MOTION)
+		  {
+		    EventBuffer->GetEvent (EventBuffer, DFB_EVENT (dfbevent));
+		    event->motion.is_hint = TRUE;
+		  }
+	      }
+	  }
+          /* make sure crossing events go to the event window found */
+        GdkWindow *ev_win = ( event_win == NULL ) ? gdk_window_at_pointer (NULL,NULL) :event_win;
+	     gdk_directfb_window_send_crossing_events (NULL,ev_win,GDK_CROSSING_NORMAL);
+      }
+      break;
+
+    case DWET_GOTFOCUS:
+      gdk_directfb_change_focus (window);
+
+      break;
+
+    case DWET_LOSTFOCUS:
+      gdk_directfb_change_focus (_gdk_parent_root);
+
+      break;
+
+    case DWET_POSITION:
+      {
+        GdkWindow *event_win;
+
+        private->x = dfbevent->x;
+        private->y = dfbevent->y;
+
+        event_win = gdk_directfb_other_event_window (window, GDK_CONFIGURE);
+
+        if (event_win)
+          {
+            event = gdk_directfb_event_make (event_win, GDK_CONFIGURE);
+            event->configure.x = dfbevent->x;
+            event->configure.y = dfbevent->y;
+            event->configure.width =
+              GDK_DRAWABLE_IMPL_DIRECTFB (private->impl)->width;
+            event->configure.height =
+              GDK_DRAWABLE_IMPL_DIRECTFB (private->impl)->height;
+          }
+
+        _gdk_directfb_calc_abs (window);
+      }
+      break;
+
+    case DWET_POSITION_SIZE:
+      private->x = dfbevent->x;
+      private->y = dfbevent->y;
+      /* fallthru */
+
+    case DWET_SIZE:
+      {
+        GdkDrawableImplDirectFB *impl;
+        GdkWindow               *event_win;
+        GList                   *list;
+
+        impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+
+        event_win = gdk_directfb_other_event_window (window, GDK_CONFIGURE);
+
+        if (event_win)
+          {
+            event = gdk_directfb_event_make (event_win, GDK_CONFIGURE);
+            event->configure.x      = private->x;
+            event->configure.y      = private->y;
+            event->configure.width  = dfbevent->w;
+            event->configure.height = dfbevent->h;
+          }
+
+        impl->width  = dfbevent->w;
+        impl->height = dfbevent->h;
+
+        for (list = private->children; list; list = list->next)
+          {
+            GdkWindowObject         *win;
+            GdkDrawableImplDirectFB *impl;
+
+            win  = GDK_WINDOW_OBJECT (list->data);
+            impl = GDK_DRAWABLE_IMPL_DIRECTFB (win->impl);
+
+            _gdk_directfb_move_resize_child (GDK_WINDOW (win),
+                                             win->x, win->y,
+                                             impl->width, impl->height);
+          }
+
+        _gdk_directfb_calc_abs (window);
+
+        gdk_window_clear (window);
+        gdk_window_invalidate_rect (window, NULL, TRUE);
+      }
+      break;
+
+    case DWET_KEYDOWN:
+    case DWET_KEYUP:
+      {
+
+        GdkEventType type = (dfbevent->type == DWET_KEYUP ?
+                             GDK_KEY_RELEASE : GDK_KEY_PRESS);
+        GdkWindow *event_win =
+          gdk_directfb_keyboard_event_window (gdk_directfb_window_find_focus (),
+                                              type);
+        if (event_win)
+          {
+            event = gdk_directfb_event_make (event_win, type);
+            gdk_directfb_translate_key_event (dfbevent, &event->key);
+          }
+      }
+      break;
+
+    case DWET_LEAVE:
+      _gdk_directfb_mouse_x = dfbevent->cx;
+      _gdk_directfb_mouse_y = dfbevent->cy;
+
+      gdk_directfb_window_send_crossing_events (NULL, _gdk_parent_root,
+                                                GDK_CROSSING_NORMAL);
+
+      if (gdk_directfb_apply_focus_opacity)
+        {
+          if (GDK_WINDOW_IS_MAPPED (window))
+            GDK_WINDOW_IMPL_DIRECTFB (private->impl)->window->SetOpacity
+              (GDK_WINDOW_IMPL_DIRECTFB (private->impl)->window,
+               (GDK_WINDOW_IMPL_DIRECTFB (private->impl)->opacity >> 1) +
+               (GDK_WINDOW_IMPL_DIRECTFB (private->impl)->opacity >> 2));
+        }
+      break;
+
+    case DWET_ENTER:
+      {
+        GdkWindow *child;
+
+        _gdk_directfb_mouse_x = dfbevent->cx;
+        _gdk_directfb_mouse_y = dfbevent->cy;
+
+        child = gdk_directfb_child_at (window, &dfbevent->x, &dfbevent->y);
+
+        gdk_directfb_window_send_crossing_events (NULL, child,
+                                                  GDK_CROSSING_NORMAL);
+
+        if (gdk_directfb_apply_focus_opacity)
+          {
+            GDK_WINDOW_IMPL_DIRECTFB (private->impl)->window->SetOpacity
+              (GDK_WINDOW_IMPL_DIRECTFB (private->impl)->window,
+               GDK_WINDOW_IMPL_DIRECTFB (private->impl)->opacity);
+          }
+      }
+      break;
+
+    case DWET_CLOSE:
+      {
+ 
+        GdkWindow *event_win;
+
+        event_win = gdk_directfb_other_event_window (window, GDK_DELETE);
+
+        if (event_win)
+          event = gdk_directfb_event_make (event_win, GDK_DELETE);
+      }
+      break;
+
+    case DWET_DESTROYED:
+      {
+        GdkWindow *event_win;
+
+        event_win = gdk_directfb_other_event_window (window, GDK_DESTROY);
+
+        if (event_win)
+          event = gdk_directfb_event_make (event_win, GDK_DESTROY);
+
+	gdk_window_destroy_notify (window);
+      }
+      break;
+
+    case DWET_WHEEL:
+      {
+        GdkWindow *event_win;
+
+        _gdk_directfb_mouse_x = dfbevent->cx;
+        _gdk_directfb_mouse_y = dfbevent->cy;
+
+        if (_gdk_directfb_pointer_grab_window)
+          {
+            GdkDrawableImplDirectFB *impl;
+
+            event_win = _gdk_directfb_pointer_grab_window;
+            impl =
+              GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (event_win)->impl);
+
+            dfbevent->x = dfbevent->cx - impl->abs_x;
+            dfbevent->y = dfbevent->cy - impl->abs_y;
+          }
+        else
+          {
+            event_win = gdk_directfb_child_at (window,
+                                               &dfbevent->x, &dfbevent->y);
+          }
+
+        if (event_win)
+          {
+            event = gdk_directfb_event_make (event_win, GDK_SCROLL);
+
+            event->scroll.direction = (dfbevent->step < 0 ?
+                                       GDK_SCROLL_DOWN : GDK_SCROLL_UP);
+
+            event->scroll.x_root = _gdk_directfb_mouse_x;
+            event->scroll.y_root = _gdk_directfb_mouse_y;
+            event->scroll.x      = dfbevent->x;
+            event->scroll.y      = dfbevent->y;
+            event->scroll.state  = _gdk_directfb_modifiers;
+            event->scroll.device = display->core_pointer;
+          }
+      }
+      break;
+
+    default:
+      g_message ("unhandled DirectFB windowing event 0x%08x", dfbevent->type);
+    }
+
+  g_object_unref (G_OBJECT (window));
+
+  return event;
+}
+
+gboolean
+gdk_screen_get_setting (GdkScreen   *screen,
+                        const gchar *name,
+                        GValue      *value)
+{
+  return FALSE;
+}
+
+void
+gdk_display_add_client_message_filter (GdkDisplay   *display,
+                                       GdkAtom       message_type,
+                                       GdkFilterFunc func,
+                                       gpointer      data)
+{
+  /* XXX: display should be used */
+  GdkClientFilter *filter = g_new (GdkClientFilter, 1);
+
+  filter->type = message_type;
+  filter->function = func;
+  filter->data = data;
+  client_filters = g_list_append (client_filters, filter);
+}
+
+
+void
+gdk_add_client_message_filter (GdkAtom       message_type,
+                               GdkFilterFunc func,
+                               gpointer      data)
+{
+  gdk_display_add_client_message_filter (gdk_display_get_default (),
+                                         message_type, func, data);
+}
+
+void
+gdk_screen_broadcast_client_message (GdkScreen *screen,
+				     GdkEvent  *sev)
+{
+  GdkWindow *root_window;
+  GdkWindowObject *private;
+  GList *top_level = NULL;
+
+  g_return_if_fail (GDK_IS_SCREEN (screen));
+  g_return_if_fail(sev != NULL);
+
+  root_window = gdk_screen_get_root_window (screen);
+
+  g_return_if_fail(GDK_IS_WINDOW(root_window));
+
+  private = GDK_WINDOW_OBJECT (root_window);
+
+  for (top_level = private->children; top_level; top_level = top_level->next)
+    {
+      gdk_event_send_client_message_for_display (gdk_drawable_get_display(GDK_DRAWABLE(root_window)),
+                                                sev,
+                                                (guint32)(GDK_WINDOW_DFB_ID(GDK_WINDOW(top_level->data))));
+   }
+}
+
+
+/**
+ * gdk_net_wm_supports:
+ * @property: a property atom.
+ *
+ * This function is specific to the X11 backend of GDK, and indicates
+ * whether the window manager for the default screen supports a certain
+ * hint from the Extended Window Manager Hints Specification. See
+ * gdk_x11_screen_supports_net_wm_hint() for complete details.
+ *
+ * Return value: %TRUE if the window manager supports @property
+ **/
+
+
+gboolean
+gdk_net_wm_supports (GdkAtom property)
+{
+   return FALSE;
+}
+
+#define __GDK_EVENTS_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkfont-directfb.c gtk+/gdk/directfb/gdkfont-directfb.c
--- old/gdk/directfb/gdkfont-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkfont-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,278 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#undef GDK_DISABLE_DEPRECATED
+
+#include <config.h>
+#include "gdk.h"
+
+#include <string.h>
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+
+#include "gdkfont.h"
+#include "gdkalias.h"
+
+
+typedef struct _GdkFontDirectFB  GdkFontDirectFB;
+
+struct _GdkFontDirectFB
+{
+  GdkFontPrivate    base;
+  gint              size;
+  IDirectFBFont    *dfbfont;
+};
+
+
+static GdkFont *
+gdk_directfb_bogus_font (gint height)
+{
+  GdkFont         *font;
+  GdkFontDirectFB *private;
+
+  private = g_new0 (GdkFontDirectFB, 1);
+  font = (GdkFont *)private;
+
+  font->type = GDK_FONT_FONT;
+  font->ascent = height*3/4;
+  font->descent = height/4;
+  private->size = height;
+  private->base.ref_count = 1;
+  return font;
+}
+
+GdkFont*
+gdk_font_from_description_for_display (GdkDisplay * display,PangoFontDescription *font_desc)
+{
+  gint size;
+
+  g_return_val_if_fail (font_desc, NULL);
+
+  size = pango_font_description_get_size (font_desc);
+
+  return gdk_directfb_bogus_font (PANGO_PIXELS (size));
+}
+
+/* ********************* */
+
+GdkFont*
+gdk_fontset_load (const gchar *fontset_name)
+{
+  return gdk_directfb_bogus_font (10);
+}
+
+GdkFont *
+gdk_fontset_load_for_display (GdkDisplay *display,const gchar *font_name) {
+  return gdk_directfb_bogus_font (10);
+}
+
+GdkFont *
+gdk_font_load_for_display (GdkDisplay *display,const gchar *font_name)
+{
+  return gdk_directfb_bogus_font (10);
+}
+
+void
+_gdk_font_destroy (GdkFont *font)
+{
+  switch (font->type)
+    {
+    case GDK_FONT_FONT:
+      break;
+    case GDK_FONT_FONTSET:
+      break;
+    default:
+      g_error ("unknown font type.");
+      break;
+    }
+
+  g_free (font);
+}
+
+gint
+_gdk_font_strlen (GdkFont     *font,
+                  const gchar *str)
+{
+  GdkFontDirectFB *font_private;
+  gint length = 0;
+
+  g_return_val_if_fail (font != NULL, -1);
+  g_return_val_if_fail (str != NULL, -1);
+
+  font_private = (GdkFontDirectFB*) font;
+
+  if (font->type == GDK_FONT_FONT)
+    {
+      guint16 *string_2b = (guint16 *)str;
+
+      while (*(string_2b++))
+        length++;
+    }
+  else if (font->type == GDK_FONT_FONTSET)
+    {
+      length = strlen (str);
+    }
+  else
+    g_error("undefined font type\n");
+
+  return length;
+}
+
+gint
+gdk_font_id (const GdkFont *font)
+{
+  const GdkFontDirectFB *font_private;
+
+  g_return_val_if_fail (font != NULL, 0);
+
+  font_private = (const GdkFontDirectFB*) font;
+
+  if (font->type == GDK_FONT_FONT)
+    {
+      return -1;
+    }
+  else
+    {
+      return 0;
+    }
+}
+
+gint
+gdk_font_equal (const GdkFont *fonta,
+                const GdkFont *fontb)
+{
+  const GdkFontDirectFB *privatea;
+  const GdkFontDirectFB *privateb;
+
+  g_return_val_if_fail (fonta != NULL, FALSE);
+  g_return_val_if_fail (fontb != NULL, FALSE);
+
+  privatea = (const GdkFontDirectFB*) fonta;
+  privateb = (const GdkFontDirectFB*) fontb;
+
+  if(fonta == fontb)
+    return TRUE;
+
+  return FALSE;
+}
+
+gint
+gdk_text_width (GdkFont      *font,
+                const gchar  *text,
+                gint          text_length)
+{
+  GdkFontDirectFB *private;
+
+  private = (GdkFontDirectFB*) font;
+
+  return (text_length * private->size) / 2;
+}
+
+gint
+gdk_text_width_wc (GdkFont        *font,
+                   const GdkWChar *text,
+                   gint            text_length)
+{
+  return 0;
+}
+
+void
+gdk_text_extents (GdkFont     *font,
+                  const gchar *text,
+                  gint         text_length,
+                  gint        *lbearing,
+                  gint        *rbearing,
+                  gint        *width,
+                  gint        *ascent,
+                  gint        *descent)
+{
+  if(ascent)
+    *ascent = font->ascent;
+  if(descent)
+    *descent = font->descent;
+  if(width)
+    *width = gdk_text_width(font, text, text_length);
+  if(lbearing)
+    *lbearing = 0;
+  if(rbearing)
+    *rbearing = 0;
+}
+
+void
+gdk_text_extents_wc (GdkFont        *font,
+                     const GdkWChar *text,
+                     gint            text_length,
+                     gint           *lbearing,
+                     gint           *rbearing,
+                     gint           *width,
+                     gint           *ascent,
+                     gint           *descent)
+{
+  char *realstr;
+  int i;
+
+  realstr = alloca (text_length + 1);
+
+  for(i = 0; i < text_length; i++)
+    realstr[i] = text[i];
+
+  realstr[i] = '\0';
+
+  return gdk_text_extents (font,
+                           realstr,
+                           text_length,
+                           lbearing,
+                           rbearing,
+                           width,
+                           ascent,
+                           descent);
+}
+
+GdkFont *
+gdk_font_lookup (GdkNativeWindow xid)
+{
+	g_warning(" gdk_font_lookup unimplemented \n");
+  return NULL;
+}
+
+GdkDisplay*
+gdk_font_get_display (GdkFont* font)
+{
+	g_warning(" gdk_font_get_display unimplemented \n");
+  return NULL;
+}
+
+#define __GDK_FONT_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkgc-directfb.c gtk+/gdk/directfb/gdkgc-directfb.c
--- old/gdk/directfb/gdkgc-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkgc-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,438 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+
+#include <string.h>
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkgc.h"
+#include "gdkfont.h"
+#include "gdkpixmap.h"
+#include "gdkregion-generic.h"
+
+#include "gdkalias.h"
+
+static void gdk_directfb_gc_get_values (GdkGC           *gc,
+                                        GdkGCValues     *values);
+static void gdk_directfb_gc_set_values (GdkGC           *gc,
+                                        GdkGCValues     *values,
+                                        GdkGCValuesMask  values_mask);
+static void gdk_directfb_gc_set_dashes (GdkGC           *gc,
+                                        gint             dash_offset,
+                                        gint8            dash_list[],
+                                        gint             n);
+
+static void gdk_gc_directfb_class_init (GdkGCDirectFBClass *klass);
+static void gdk_gc_directfb_finalize   (GObject            *object);
+
+
+static gpointer parent_class = NULL;
+
+
+GType
+gdk_gc_directfb_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+      {
+        sizeof (GdkGCDirectFBClass),
+        (GBaseInitFunc) NULL,
+        (GBaseFinalizeFunc) NULL,
+        (GClassInitFunc) gdk_gc_directfb_class_init,
+        NULL,           /* class_finalize */
+        NULL,           /* class_data */
+        sizeof (GdkGCDirectFB),
+        0,              /* n_preallocs */
+        (GInstanceInitFunc) NULL,
+      };
+
+      object_type = g_type_register_static (GDK_TYPE_GC,
+                                            "GdkGCDirectFB",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+static void
+gdk_gc_directfb_class_init (GdkGCDirectFBClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GdkGCClass   *gc_class     = GDK_GC_CLASS (klass);
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = gdk_gc_directfb_finalize;
+
+  gc_class->get_values = gdk_directfb_gc_get_values;
+  gc_class->set_values = gdk_directfb_gc_set_values;
+  gc_class->set_dashes = gdk_directfb_gc_set_dashes;
+}
+
+static void
+gdk_gc_directfb_finalize (GObject *object)
+{
+  GdkGC         *gc      = GDK_GC (object);
+  GdkGCDirectFB *private = GDK_GC_DIRECTFB (gc);
+
+  if (private->clip_region)
+    gdk_region_destroy (private->clip_region);
+  if (private->values.clip_mask)
+    g_object_unref (private->values.clip_mask);
+  if (private->values.stipple)
+    g_object_unref (private->values.stipple);
+  if (private->values.tile)
+    g_object_unref (private->values.tile);
+
+  if (G_OBJECT_CLASS (parent_class)->finalize)
+    G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+GdkGC*
+_gdk_directfb_gc_new (GdkDrawable     *drawable,
+                      GdkGCValues     *values,
+                      GdkGCValuesMask  values_mask)
+{
+  GdkGC         *gc;
+  GdkGCDirectFB *private;
+
+  g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable), NULL);
+
+  gc = GDK_GC (g_object_new (gdk_gc_directfb_get_type (), NULL));
+
+  _gdk_gc_init (gc, drawable, values, values_mask);
+
+  private = GDK_GC_DIRECTFB (gc);
+#if 0
+  private->values.background.pixel = 0;
+  private->values.background.red   =
+  private->values.background.green =
+  private->values.background.blue  = 0;
+
+  private->values.foreground.pixel = 0;
+  private->values.foreground.red   =
+  private->values.foreground.green =
+  private->values.foreground.blue  = 0;
+#endif
+
+  private->values.cap_style = GDK_CAP_BUTT;
+
+  gdk_directfb_gc_set_values (gc, values, values_mask);
+
+  return gc;
+}
+
+static void
+gdk_directfb_gc_get_values (GdkGC       *gc,
+                            GdkGCValues *values)
+{
+  *values = GDK_GC_DIRECTFB (gc)->values;
+}
+
+#if 0
+void
+_gdk_windowing_gc_get_foreground (GdkGC    *gc,
+                                  GdkColor *color)
+{
+  GdkGCDirectFB *private;
+  private = GDK_GC_DIRECTFB (gc);
+  *color =private->values.foreground;
+
+
+}
+#endif
+
+static void
+gdk_directfb_gc_set_values (GdkGC           *gc,
+                            GdkGCValues     *values,
+                            GdkGCValuesMask  values_mask)
+{
+  GdkGCDirectFB *private = GDK_GC_DIRECTFB (gc);
+
+  if (values_mask & GDK_GC_FOREGROUND)
+    {
+      private->values.foreground = values->foreground;
+      private->values_mask |= GDK_GC_FOREGROUND;
+    }
+
+  if (values_mask & GDK_GC_BACKGROUND)
+    {
+      private->values.background = values->background;
+      private->values_mask |= GDK_GC_BACKGROUND;
+    }
+
+  if (values_mask & GDK_GC_FONT)
+    {
+      GdkFont *oldf = private->values.font;
+
+      private->values.font = gdk_font_ref (values->font);
+      private->values_mask |= GDK_GC_FONT;
+
+      if (oldf)
+        gdk_font_unref (oldf);
+    }
+
+  if (values_mask & GDK_GC_FUNCTION)
+    {
+      private->values.function = values->function;
+      private->values_mask |= GDK_GC_FUNCTION;
+    }
+
+  if (values_mask & GDK_GC_FILL)
+    {
+      private->values.fill = values->fill;
+      private->values_mask |= GDK_GC_FILL;
+    }
+
+  if (values_mask & GDK_GC_TILE)
+    {
+      GdkPixmap *oldpm = private->values.tile;
+
+      if (values->tile)
+        g_assert (GDK_PIXMAP_OBJECT (values->tile)->depth > 1);
+
+      private->values.tile = values->tile ? g_object_ref (values->tile) : NULL;
+      private->values_mask |= GDK_GC_TILE;
+
+      if (oldpm)
+        g_object_unref (oldpm);
+    }
+
+  if (values_mask & GDK_GC_STIPPLE)
+    {
+      GdkPixmap *oldpm = private->values.stipple;
+
+      if (values->stipple)
+        g_assert (GDK_PIXMAP_OBJECT (values->stipple)->depth == 1);
+
+      private->values.stipple = (values->stipple ?
+                                 g_object_ref (values->stipple) : NULL);
+      private->values_mask |= GDK_GC_STIPPLE;
+
+      if (oldpm)
+        g_object_unref (oldpm);
+    }
+
+  if (values_mask & GDK_GC_CLIP_MASK)
+    {
+      GdkPixmap *oldpm = private->values.clip_mask;
+
+      private->values.clip_mask = (values->clip_mask ?
+                                   g_object_ref (values->clip_mask) : NULL);
+      private->values_mask |= GDK_GC_CLIP_MASK;
+
+      if (oldpm)
+        g_object_unref (oldpm);
+
+      if (private->clip_region)
+        {
+          gdk_region_destroy (private->clip_region);
+          private->clip_region = NULL;
+        }
+    }
+
+  if (values_mask & GDK_GC_SUBWINDOW)
+    {
+      private->values.subwindow_mode = values->subwindow_mode;
+      private->values_mask |= GDK_GC_SUBWINDOW;
+    }
+
+  if (values_mask & GDK_GC_TS_X_ORIGIN)
+    {
+      private->values.ts_x_origin = values->ts_x_origin;
+      private->values_mask |= GDK_GC_TS_X_ORIGIN;
+    }
+
+  if (values_mask & GDK_GC_TS_Y_ORIGIN)
+    {
+      private->values.ts_y_origin = values->ts_y_origin;
+      private->values_mask |= GDK_GC_TS_Y_ORIGIN;
+    }
+
+  if (values_mask & GDK_GC_CLIP_X_ORIGIN)
+    {
+      private->values.clip_x_origin = GDK_GC (gc)->clip_x_origin = values->clip_x_origin;
+      private->values_mask |= GDK_GC_CLIP_X_ORIGIN;
+    }
+
+  if (values_mask & GDK_GC_CLIP_Y_ORIGIN)
+    {
+      private->values.clip_y_origin = GDK_GC (gc)->clip_y_origin = values->clip_y_origin;
+      private->values_mask |= GDK_GC_CLIP_Y_ORIGIN;
+    }
+
+  if (values_mask & GDK_GC_EXPOSURES)
+    {
+      private->values.graphics_exposures = values->graphics_exposures;
+      private->values_mask |= GDK_GC_EXPOSURES;
+    }
+
+  if (values_mask & GDK_GC_LINE_WIDTH)
+    {
+      private->values.line_width = values->line_width;
+      private->values_mask |= GDK_GC_LINE_WIDTH;
+    }
+
+  if (values_mask & GDK_GC_LINE_STYLE)
+    {
+      private->values.line_style = values->line_style;
+      private->values_mask |= GDK_GC_LINE_STYLE;
+    }
+
+  if (values_mask & GDK_GC_CAP_STYLE)
+    {
+      private->values.cap_style = values->cap_style;
+      private->values_mask |= GDK_GC_CAP_STYLE;
+    }
+
+  if (values_mask & GDK_GC_JOIN_STYLE)
+    {
+      private->values.join_style = values->join_style;
+      private->values_mask |= GDK_GC_JOIN_STYLE;
+    }
+}
+
+static void
+gdk_directfb_gc_set_dashes (GdkGC *gc,
+                            gint   dash_offset,
+                            gint8  dash_list[],
+                            gint   n)
+{
+  g_warning ("gdk_directfb_gc_set_dashes not implemented");
+}
+
+static void
+gc_unset_clip_mask (GdkGC *gc)
+{
+  GdkGCDirectFB *data = GDK_GC_DIRECTFB (gc);
+
+  if (data->values.clip_mask)
+    {
+      g_object_unref (data->values.clip_mask);
+      data->values.clip_mask = NULL;
+      data->values_mask &= ~ GDK_GC_CLIP_MASK;
+    }
+}
+
+
+void
+_gdk_windowing_gc_set_clip_region (GdkGC     *gc,
+                        GdkRegion *region)
+{
+  GdkGCDirectFB *data;
+
+  g_return_if_fail (gc != NULL);
+
+  data = GDK_GC_DIRECTFB (gc);
+
+  if (region == data->clip_region)
+    return;
+
+  if (data->clip_region)
+    {
+      gdk_region_destroy (data->clip_region);
+      data->clip_region = NULL;
+    }
+
+  if (region)
+    data->clip_region = gdk_region_copy (region);
+
+  gc->clip_x_origin = 0;
+  gc->clip_y_origin = 0;
+  data->values.clip_x_origin = 0;
+  data->values.clip_y_origin = 0;
+
+  gc_unset_clip_mask (gc);
+}
+
+void
+_gdk_windowing_gc_copy (GdkGC *dst_gc,
+             GdkGC *src_gc)
+{
+  GdkGCDirectFB *dst_private;
+
+  g_return_if_fail (dst_gc != NULL);
+  g_return_if_fail (src_gc != NULL);
+
+  dst_private = GDK_GC_DIRECTFB (dst_gc);
+
+  if (dst_private->clip_region)
+    gdk_region_destroy(dst_private->clip_region);
+
+  if (dst_private->values_mask & GDK_GC_FONT)
+    gdk_font_unref (dst_private->values.font);
+  if (dst_private->values_mask & GDK_GC_TILE)
+    g_object_unref (dst_private->values.tile);
+  if (dst_private->values_mask & GDK_GC_STIPPLE)
+    g_object_unref (dst_private->values.stipple);
+  if (dst_private->values_mask & GDK_GC_CLIP_MASK)
+    g_object_unref (dst_private->values.clip_mask);
+
+  *dst_gc = *src_gc;
+  if (dst_private->values_mask & GDK_GC_FONT)
+    gdk_font_ref (dst_private->values.font);
+  if (dst_private->values_mask & GDK_GC_TILE)
+    g_object_ref (dst_private->values.tile);
+  if (dst_private->values_mask & GDK_GC_STIPPLE)
+    g_object_ref (dst_private->values.stipple);
+  if (dst_private->values_mask & GDK_GC_CLIP_MASK)
+    g_object_ref (dst_private->values.clip_mask);
+  if (dst_private->clip_region)
+    dst_private->clip_region = gdk_region_copy (dst_private->clip_region);
+}
+
+/**
+ * gdk_gc_get_screen:
+ * @gc: a #GdkGC.
+ *
+ * Gets the #GdkScreen for which @gc was created
+ *
+ * Returns: the #GdkScreen for @gc.
+ *
+ * Since: 2.2
+ */
+GdkScreen *  
+gdk_gc_get_screen (GdkGC *gc)
+{
+  g_return_val_if_fail (GDK_IS_GC_DIRECTFB (gc), NULL);
+  
+  return _gdk_screen;
+}
+#define __GDK_GC_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkgeometry-directfb.c gtk+/gdk/directfb/gdkgeometry-directfb.c
--- old/gdk/directfb/gdkgeometry-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkgeometry-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,259 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include "config.h"
+#include "gdk.h"        /* For gdk_rectangle_intersect */
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+#include "gdkalias.h"
+
+
+void
+_gdk_windowing_window_get_offsets (GdkWindow *window,
+                                   gint      *x_offset,
+                                   gint      *y_offset)
+{
+  if (x_offset)
+    *x_offset = 0;
+  if (y_offset)
+    *y_offset = 0;
+}
+
+gboolean
+_gdk_windowing_window_queue_antiexpose (GdkWindow *window,
+                                        GdkRegion *area)
+{
+  return FALSE;
+}
+
+/**
+ * gdk_window_scroll:
+ * @window: a #GdkWindow
+ * @dx: Amount to scroll in the X direction
+ * @dy: Amount to scroll in the Y direction
+ *
+ * Scroll the contents of its window, both pixels and children, by
+ * the given amount. Portions of the window that the scroll operation
+ * brings in from offscreen areas are invalidated.
+ **/
+void
+gdk_window_scroll (GdkWindow *window,
+                   gint       dx,
+                   gint       dy)
+{
+  GdkWindowObject         *private;
+  GdkDrawableImplDirectFB *impl;
+  GdkRegion               *invalidate_region = NULL;
+  GList                   *list;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+
+  if (dx == 0 && dy == 0)
+    return;
+
+  /* Move the current invalid region */
+  if (private->update_area)
+    gdk_region_offset (private->update_area, dx, dy);
+
+  if (GDK_WINDOW_IS_MAPPED (window))
+    {
+      GdkRectangle  clip_rect = {  0,  0, impl->width, impl->height };
+      GdkRectangle  rect      = { dx, dy, impl->width, impl->height };
+
+      invalidate_region = gdk_region_rectangle (&clip_rect);
+
+      if (gdk_rectangle_intersect (&rect, &clip_rect, &rect) &&
+          (!private->update_area ||
+           !gdk_region_rect_in (private->update_area, &rect)))
+        {
+          GdkRegion *region;
+
+          region = gdk_region_rectangle (&rect);
+          gdk_region_subtract (invalidate_region, region);
+          gdk_region_destroy (region);
+
+          if (impl->surface)
+            {
+              DFBRegion update = { rect.x, rect.y,
+                                   rect.x + rect.width  - 1,
+                                   rect.y + rect.height - 1 };
+
+              impl->surface->SetClip (impl->surface, &update);
+              impl->surface->Blit (impl->surface, impl->surface, NULL, dx, dy);
+              impl->surface->SetClip (impl->surface, NULL);
+
+              _gdk_directfb_update (impl, &update);
+            }
+        }
+    }
+
+  for (list = private->children; list; list = list->next)
+    {
+      GdkWindowObject         *obj      = GDK_WINDOW_OBJECT (list->data);
+      GdkDrawableImplDirectFB *obj_impl = GDK_DRAWABLE_IMPL_DIRECTFB (obj->impl);
+
+      _gdk_directfb_move_resize_child (list->data,
+                                       obj->x + dx,
+                                       obj->y + dy,
+                                       obj_impl->width,
+                                       obj_impl->height);
+    }
+
+  _gdk_directfb_calc_abs (window);
+
+  if (invalidate_region)
+    {
+      gdk_window_invalidate_region (window, invalidate_region, TRUE);
+      gdk_region_destroy (invalidate_region);
+    }
+}
+
+/**
+ * gdk_window_move_region:
+ * @window: a #GdkWindow
+ * @region: The #GdkRegion to move
+ * @dx: Amount to move in the X direction
+ * @dy: Amount to move in the Y direction
+ * 
+ * Move the part of @window indicated by @region by @dy pixels in the Y 
+ * direction and @dx pixels in the X direction. The portions of @region 
+ * that not covered by the new position of @region are invalidated.
+ * 
+ * Child windows are not moved.
+ * 
+ * Since: 2.8
+ **/
+void
+gdk_window_move_region (GdkWindow *window,
+			GdkRegion *region,
+			gint       dx,
+			gint       dy)
+{
+  GdkWindowObject         *private;
+  GdkDrawableImplDirectFB *impl;
+  GdkRegion *window_clip;
+  GdkRegion *src_region;
+  GdkRegion *brought_in;
+  GdkRegion *dest_region;
+  GdkRegion *moving_invalid_region;
+  GdkRectangle dest_extents;
+  
+  g_return_if_fail (GDK_IS_WINDOW (window));
+  g_return_if_fail (region != NULL);
+  
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+  
+  private = GDK_WINDOW_OBJECT (window);
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);  
+
+  if (dx == 0 && dy == 0)
+    return;
+
+  GdkRectangle  clip_rect = {  0,  0, impl->width, impl->height };
+  window_clip = gdk_region_rectangle (&clip_rect);
+
+  /* compute source regions */
+  src_region = gdk_region_copy (region);
+  brought_in = gdk_region_copy (region);
+  gdk_region_intersect (src_region, window_clip);
+
+  gdk_region_subtract (brought_in, src_region);
+  gdk_region_offset (brought_in, dx, dy);
+
+  /* compute destination regions */
+  dest_region = gdk_region_copy (src_region);
+  gdk_region_offset (dest_region, dx, dy);
+  gdk_region_intersect (dest_region, window_clip);
+  gdk_region_get_clipbox (dest_region, &dest_extents);
+
+  gdk_region_destroy (window_clip);
+
+  /* calculating moving part of current invalid area */
+  moving_invalid_region = NULL;
+  if (private->update_area)
+    {
+      moving_invalid_region = gdk_region_copy (private->update_area);
+      gdk_region_intersect (moving_invalid_region, src_region);
+      gdk_region_offset (moving_invalid_region, dx, dy);
+    }
+  
+  /* invalidate all of the src region */
+  gdk_window_invalidate_region (window, src_region, FALSE);
+
+  /* un-invalidate destination region */
+  if (private->update_area)
+    gdk_region_subtract (private->update_area, dest_region);
+  
+  /* invalidate moving parts of existing update area */
+  if (moving_invalid_region)
+    {
+      gdk_window_invalidate_region (window, moving_invalid_region, FALSE);
+      gdk_region_destroy (moving_invalid_region);
+    }
+
+  /* invalidate area brought in from off-screen */
+  gdk_window_invalidate_region (window, brought_in, FALSE);
+  gdk_region_destroy (brought_in);
+
+  /* Actually do the moving */
+	if (impl->surface)
+	{
+    	DFBRectangle source = { dest_extents.x - dx, 
+							 dest_extents.y - dy,
+                             dest_extents.width,
+                             dest_extents.height};
+    	DFBRegion destination = { dest_extents.x, 
+							 	  dest_extents.y,
+                             	  dest_extents.width,
+                             	  dest_extents.height};
+
+              impl->surface->SetClip (impl->surface, &destination);
+              impl->surface->Blit (impl->surface, impl->surface,&source,dx,dy);
+              impl->surface->SetClip (impl->surface, NULL);
+              _gdk_directfb_update (impl, &destination);
+	}
+  gdk_region_destroy (src_region);
+  gdk_region_destroy (dest_region);
+}
+
+#define __GDK_GEOMETRY_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkglobals-directfb.c gtk+/gdk/directfb/gdkglobals-directfb.c
--- old/gdk/directfb/gdkglobals-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkglobals-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,62 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkalias.h"
+
+
+GdkDisplayDFB *_gdk_display = NULL;
+GdkScreen          * _gdk_screen                              = NULL;
+
+gboolean              gdk_directfb_apply_focus_opacity        = FALSE;
+gboolean              gdk_directfb_enable_color_keying        = FALSE;
+DFBColor              gdk_directfb_bg_color                   = { 0, 0, 0, 0 };
+DFBColor              gdk_directfb_bg_color_key               = { 0, 0, 0, 0 };
+gboolean              gdk_directfb_monochrome_fonts           = FALSE;
+
+GdkWindow          * _gdk_directfb_pointer_grab_window        = NULL;
+GdkWindow          * _gdk_directfb_keyboard_grab_window       = NULL;
+GdkWindow          * _gdk_directfb_pointer_grab_confine       = NULL;
+gboolean             _gdk_directfb_pointer_grab_owner_events  = FALSE;
+gboolean             _gdk_directfb_keyboard_grab_owner_events = FALSE;
+GdkEventMask         _gdk_directfb_pointer_grab_events        = 0;
+GdkEventMask         _gdk_directfb_keyboard_grab_events       = 0;
+GdkCursor          * _gdk_directfb_pointer_grab_cursor        = NULL;
+
+GdkAtom              _gdk_selection_property                  = 0;
+
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkim-directfb.c gtk+/gdk/directfb/gdkim-directfb.c
--- old/gdk/directfb/gdkim-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkim-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,319 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include "config.h"
+
+#include <string.h>
+#include <locale.h>
+
+#include "gdkdirectfb.h"
+
+/*
+ *--------------------------------------------------------------
+ * gdk_set_locale
+ *
+ * Arguments:
+ *
+ * Results:
+ *
+ * Side effects:
+ *
+ *--------------------------------------------------------------
+ */
+
+gchar*
+gdk_set_locale (void)
+{
+  if (!setlocale (LC_ALL,""))
+    g_warning ("locale not supported by C library");
+
+  return setlocale (LC_ALL, NULL);
+}
+/*
+ * gdk_wcstombs
+ *
+ * Returns a multi-byte string converted from the specified array
+ * of wide characters. The string is newly allocated. The array of
+ * wide characters must be null-terminated. If the conversion is
+ * failed, it returns NULL.
+ *
+ * On Win32, we always use UTF-8.
+ */
+gchar *
+gdk_wcstombs (const GdkWChar *src)
+{
+  gint len;
+  const GdkWChar *wcp;
+  guchar *mbstr, *bp;
+
+  wcp = src;
+  len = 0;
+  while (*wcp)
+    {
+      const GdkWChar c = *wcp++;
+
+      if (c < 0x80)
+        len += 1;
+      else if (c < 0x800)
+        len += 2;
+      else if (c < 0x10000)
+        len += 3;
+      else if (c < 0x200000)
+        len += 4;
+      else if (c < 0x4000000)
+        len += 5;
+      else
+        len += 6;
+    }
+
+  mbstr = g_malloc (len + 1);
+
+  wcp = src;
+  bp = mbstr;
+  while (*wcp)
+    {
+      int first;
+      GdkWChar c = *wcp++;
+
+      if (c < 0x80)
+        {
+          first = 0;
+          len = 1;
+        }
+      else if (c < 0x800)
+        {
+          first = 0xc0;
+          len = 2;
+        }
+      else if (c < 0x10000)
+        {
+          first = 0xe0;
+          len = 3;
+        }
+      else if (c < 0x200000)
+        {
+          first = 0xf0;
+          len = 4;
+        }
+      else if (c < 0x4000000)
+        {
+          first = 0xf8;
+          len = 5;
+        }
+      else
+        {
+          first = 0xfc;
+          len = 6;
+        }
+
+      /* Woo-hoo! */
+      switch (len)
+        {
+        case 6: bp[5] = (c & 0x3f) | 0x80; c >>= 6; /* Fall through */
+        case 5: bp[4] = (c & 0x3f) | 0x80; c >>= 6; /* Fall through */
+        case 4: bp[3] = (c & 0x3f) | 0x80; c >>= 6; /* Fall through */
+        case 3: bp[2] = (c & 0x3f) | 0x80; c >>= 6; /* Fall through */
+        case 2: bp[1] = (c & 0x3f) | 0x80; c >>= 6; /* Fall through */
+        case 1: bp[0] = c | first;
+        }
+
+      bp += len;
+    }
+
+  *bp = 0;
+
+  return mbstr;
+}
+
+
+/*
+ * gdk_mbstowcs
+ *
+ * Converts the specified string into GDK wide characters, and,
+ * returns the number of wide characters written. The string 'src'
+ * must be null-terminated. If the conversion is failed, it returns
+ * -1.
+ *
+ * On Win32, the string is assumed to be in UTF-8.  Also note that
+ * GdkWChar is 32 bits, while wchar_t, and the wide characters the
+ * Windows API uses, are 16 bits!
+ */
+
+/* First a helper function for not zero-terminated strings */
+gint
+gdk_nmbstowcs (GdkWChar    *dest,
+               const gchar *src,
+               gint         src_len,
+               gint         dest_max)
+{
+  guchar *cp, *end;
+  gint n;
+
+  cp = (guchar *) src;
+  end = cp + src_len;
+  n = 0;
+  while (cp != end && dest != dest + dest_max)
+    {
+      gint i, mask = 0, len;
+      guchar c = *cp;
+
+      if (c < 0x80)
+        {
+          len = 1;
+          mask = 0x7f;
+        }
+      else if ((c & 0xe0) == 0xc0)
+        {
+          len = 2;
+          mask = 0x1f;
+        }
+      else if ((c & 0xf0) == 0xe0)
+        {
+          len = 3;
+          mask = 0x0f;
+        }
+      else if ((c & 0xf8) == 0xf0)
+        {
+          len = 4;
+          mask = 0x07;
+        }
+      else if ((c & 0xfc) == 0xf8)
+        {
+          len = 5;
+          mask = 0x03;
+        }
+      else if ((c & 0xfc) == 0xfc)
+        {
+          len = 6;
+          mask = 0x01;
+        }
+      else
+        return -1;
+
+      if (cp + len > end)
+        return -1;
+
+      *dest = (cp[0] & mask);
+      for (i = 1; i < len; i++)
+        {
+          if ((cp[i] & 0xc0) != 0x80)
+            return -1;
+          *dest <<= 6;
+          *dest |= (cp[i] & 0x3f);
+        }
+
+      if (*dest == -1)
+        return -1;
+
+      cp += len;
+      dest++;
+      n++;
+    }
+
+  if (cp != end)
+    return -1;
+
+  return n;
+}
+
+gint
+gdk_mbstowcs (GdkWChar    *dest,
+              const gchar *src,
+              gint         dest_max)
+{
+  return gdk_nmbstowcs (dest, src, strlen (src), dest_max);
+}
+
+
+/* A version that converts to wchar_t wide chars */
+
+gint
+gdk_nmbstowchar_ts (wchar_t     *dest,
+                    const gchar *src,
+                    gint         src_len,
+                    gint         dest_max)
+{
+  wchar_t *wcp;
+  guchar *cp, *end;
+  gint n;
+
+  wcp = dest;
+  cp = (guchar *) src;
+  end = cp + src_len;
+  n = 0;
+  while (cp != end && wcp != dest + dest_max)
+    {
+      gint i, mask = 0, len;
+      guchar c = *cp;
+
+      if (c < 0x80)
+        {
+          len = 1;
+          mask = 0x7f;
+        }
+      else if ((c & 0xe0) == 0xc0)
+        {
+          len = 2;
+          mask = 0x1f;
+        }
+      else if ((c & 0xf0) == 0xe0)
+        {
+          len = 3;
+          mask = 0x0f;
+        }
+      else /* Other lengths are not possible with 16-bit wchar_t! */
+        return -1;
+
+      if (cp + len > end)
+        return -1;
+
+      *wcp = (cp[0] & mask);
+      for (i = 1; i < len; i++)
+        {
+          if ((cp[i] & 0xc0) != 0x80)
+            return -1;
+          *wcp <<= 6;
+          *wcp |= (cp[i] & 0x3f);
+        }
+      if (*wcp == 0xFFFF)
+        return -1;
+
+      cp += len;
+      wcp++;
+      n++;
+    }
+
+  if (cp != end)
+    return -1;
+
+  return n;
+}
diff -ruN old/gdk/directfb/gdkimage-directfb.c gtk+/gdk/directfb/gdkimage-directfb.c
--- old/gdk/directfb/gdkimage-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkimage-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,437 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+
+#include "gdkimage.h"
+#include "gdkalias.h"
+
+
+static GList    *image_list   = NULL;
+static gpointer  parent_class = NULL;
+
+static void gdk_directfb_image_destroy (GdkImage      *image);
+static void gdk_image_init             (GdkImage      *image);
+static void gdk_image_class_init       (GdkImageClass *klass);
+static void gdk_image_finalize         (GObject       *object);
+
+GType
+gdk_image_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+        {
+          sizeof (GdkImageClass),
+          (GBaseInitFunc) NULL,
+          (GBaseFinalizeFunc) NULL,
+          (GClassInitFunc) gdk_image_class_init,
+          NULL,           /* class_finalize */
+          NULL,           /* class_data */
+          sizeof (GdkImage),
+          0,              /* n_preallocs */
+          (GInstanceInitFunc) gdk_image_init,
+        };
+
+      object_type = g_type_register_static (G_TYPE_OBJECT,
+                                            "GdkImage",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+static void
+gdk_image_init (GdkImage *image)
+{
+  image->windowing_data = g_new0 (GdkImageDirectFB, 1);
+  image->mem = NULL;
+
+  image_list = g_list_prepend (image_list, image);
+}
+
+static void
+gdk_image_class_init (GdkImageClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = gdk_image_finalize;
+}
+
+static void
+gdk_image_finalize (GObject *object)
+{
+  GdkImage *image;
+
+  image = GDK_IMAGE (object);
+
+  image_list = g_list_remove (image_list, image);
+
+  if (image->depth == 1)
+    g_free (image->mem);
+
+  gdk_directfb_image_destroy (image);
+
+  if (G_OBJECT_CLASS (parent_class)->finalize)
+    G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+
+/* this function is called from the atexit handler! */
+void
+_gdk_image_exit (void)
+{
+  GObject *image;
+
+  while (image_list)
+    {
+      image = image_list->data;
+
+      gdk_image_finalize (image);
+    }
+}
+
+GdkImage *
+gdk_image_new_bitmap (GdkVisual *visual,
+                      gpointer   data,
+                      gint       w,
+                      gint       h)
+{
+  GdkImage         *image;
+  GdkImageDirectFB *private;
+
+  image = g_object_new (gdk_image_get_type (), NULL);
+  private = image->windowing_data;
+
+  image->type   = GDK_IMAGE_SHARED;
+  image->visual = visual;
+  image->width  = w;
+  image->height = h;
+  image->depth  = 1;
+
+  GDK_NOTE (MISC, g_print ("gdk_image_new_bitmap: %dx%d\n", w, h));
+
+  g_message ("not fully implemented %s", G_GNUC_FUNCTION);
+
+  image->bpl = (w + 7) / 8;
+  image->mem = g_malloc (image->bpl * h);
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  image->byte_order = GDK_MSB_FIRST;
+#else
+  image->byte_order = GDK_LSB_FIRST;
+#endif
+  image->bpp = 1;
+
+  return image;
+}
+
+void
+_gdk_windowing_image_init (void)
+{
+}
+
+GdkImage*
+_gdk_image_new_for_depth (GdkScreen    *screen,
+                          GdkImageType  type,
+                          GdkVisual    *visual,
+                          gint          width,
+                          gint          height,
+                          gint          depth)
+{
+  GdkImage              *image;
+  GdkImageDirectFB      *private;
+  DFBResult              ret;
+  gint                   pitch;
+  DFBSurfacePixelFormat  format;
+  IDirectFBSurface      *surface;
+
+  if (type == GDK_IMAGE_FASTEST || type == GDK_IMAGE_NORMAL)
+    type = GDK_IMAGE_SHARED;
+
+  if (visual)
+    depth = visual->depth;
+
+  switch (depth)
+    {
+    case 8:
+      format = DSPF_LUT8;
+      break;
+    case 15:
+      format = DSPF_ARGB1555;
+      break;
+    case 16:
+      format = DSPF_RGB16;
+      break;
+    case 24:
+      format = DSPF_RGB32;
+      break;
+    case 32:
+      format = DSPF_ARGB;
+      break;
+    default:
+      g_message ("unimplemented %s for depth %d", G_GNUC_FUNCTION, depth);
+      return NULL;
+    }
+
+  surface = gdk_display_dfb_create_surface(_gdk_display,format,width,height);
+  if (!surface)
+    {
+      return NULL;
+    }
+  surface->GetPixelFormat( surface, &format );
+
+  image = g_object_new (gdk_image_get_type (), NULL);
+  private = image->windowing_data;
+
+  private->surface = surface;
+
+  surface->Lock( surface, DSLF_WRITE, &image->mem, &pitch );
+
+  image->type           = type;
+  image->visual         = visual;
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  image->byte_order		= GDK_MSB_FIRST;
+#else
+  image->byte_order 	= GDK_LSB_FIRST;
+#endif
+  image->width          = width;
+  image->height         = height;
+  image->depth          = depth;
+  image->bpp            = DFB_BYTES_PER_PIXEL (format);
+  image->bpl            = pitch;
+  image->bits_per_pixel = DFB_BITS_PER_PIXEL (format);
+
+  image_list = g_list_prepend (image_list, image);
+
+  return image;
+}
+
+
+GdkImage*
+_gdk_directfb_copy_to_image (GdkDrawable *drawable,
+                             GdkImage    *image,
+                             gint         src_x,
+                             gint         src_y,
+                             gint         dest_x,
+                             gint         dest_y,
+                             gint         width,
+                             gint         height)
+{
+  GdkDrawableImplDirectFB *impl;
+  GdkImageDirectFB        *private;
+  int                      pitch;
+  DFBRectangle             rect = { src_x, src_y, width, height };
+  IDirectFBDisplayLayer *layer = _gdk_display->layer;
+
+  g_return_val_if_fail (GDK_IS_DRAWABLE_IMPL_DIRECTFB (drawable), NULL);
+  g_return_val_if_fail (image != NULL || (dest_x == 0 && dest_y == 0), NULL);
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+  if (impl->wrapper == _gdk_parent_root)
+    {
+      DFBResult ret;
+
+      ret = layer->SetCooperativeLevel (layer, DLSCL_EXCLUSIVE);
+      if (ret)
+        {
+          DirectFBError ("_gdk_directfb_copy_to_image - SetCooperativeLevel",
+                         ret);
+          return NULL;
+        }
+
+      ret = layer->GetSurface (layer, &impl->surface);
+      if (ret)
+        {
+          layer->SetCooperativeLevel (layer, DLSCL_SHARED);
+          DirectFBError ("_gdk_directfb_copy_to_image - GetSurface", ret);
+          return NULL;
+        }
+    }
+
+  if (! impl->surface)
+    return NULL;
+
+  if (!image)
+    image =  gdk_image_new (GDK_IMAGE_NORMAL,
+                            gdk_visual_get_system (), width, height);
+
+  private = image->windowing_data;
+
+  private->surface->Unlock( private->surface );
+
+  private->surface->Blit( private->surface,
+                          impl->surface, &rect, dest_x, dest_y );
+
+  private->surface->Lock( private->surface, DSLF_WRITE, &image->mem, &pitch );
+  image->bpl = pitch;
+
+  if (impl->wrapper == _gdk_parent_root)
+    {
+      impl->surface->Release (impl->surface);
+      impl->surface = NULL;
+      layer->SetCooperativeLevel (layer, DLSCL_SHARED);
+    }
+
+  return image;
+}
+
+guint32
+gdk_image_get_pixel (GdkImage *image,
+                     gint      x,
+                     gint      y)
+{
+  guint32 pixel = 0;
+
+  g_return_val_if_fail (GDK_IS_IMAGE (image), 0);
+
+  if (!(x >= 0 && x < image->width && y >= 0 && y < image->height))
+    return 0;
+
+  if (image->depth == 1)
+    pixel = (((guchar *) image->mem)[y * image->bpl + (x >> 3)] & (1 << (7 - (x & 0x7)))) != 0;
+  else
+    {
+      guchar *pixelp = (guchar *) image->mem + y * image->bpl + x * image->bpp;
+
+      switch (image->bpp)
+        {
+        case 1:
+          pixel = *pixelp;
+          break;
+
+        case 2:
+          pixel = pixelp[0] | (pixelp[1] << 8);
+          break;
+
+        case 3:
+          pixel = pixelp[0] | (pixelp[1] << 8) | (pixelp[2] << 16);
+          break;
+
+        case 4:
+          pixel = pixelp[0] | (pixelp[1] << 8) | (pixelp[2] << 16);
+          break;
+        }
+    }
+
+  return pixel;
+}
+
+void
+gdk_image_put_pixel (GdkImage *image,
+                     gint       x,
+                     gint       y,
+                     guint32    pixel)
+{
+  g_return_if_fail (image != NULL);
+
+  if  (!(x >= 0 && x < image->width && y >= 0 && y < image->height))
+    return;
+
+  if (image->depth == 1)
+    if (pixel & 1)
+      ((guchar *) image->mem)[y * image->bpl + (x >> 3)] |= (1 << (7 - (x & 0x7)));
+    else
+      ((guchar *) image->mem)[y * image->bpl + (x >> 3)] &= ~(1 << (7 - (x & 0x7)));
+  else
+    {
+      guchar *pixelp = (guchar *) image->mem + y * image->bpl + x * image->bpp;
+
+      switch (image->bpp)
+        {
+        case 4:
+          pixelp[3] = 0xFF;
+        case 3:
+          pixelp[2] = ((pixel >> 16) & 0xFF);
+        case 2:
+          pixelp[1] = ((pixel >> 8) & 0xFF);
+        case 1:
+          pixelp[0] = (pixel & 0xFF);
+        }
+    }
+}
+
+static void
+gdk_directfb_image_destroy (GdkImage *image)
+{
+  GdkImageDirectFB *private;
+
+  g_return_if_fail (GDK_IS_IMAGE (image));
+
+  private = image->windowing_data;
+
+  if (!private)
+    return;
+
+  GDK_NOTE (MISC, g_print ("gdk_directfb_image_destroy: %#x\n",
+                           (guint) private->surface));
+
+  private->surface->Unlock( private->surface );
+  private->surface->Release( private->surface );
+
+  g_free (private);
+  image->windowing_data = NULL;
+}
+
+gint
+_gdk_windowing_get_bits_for_depth (GdkDisplay *display,
+                                   gint        depth)
+{
+  switch (depth)
+    {
+    case 1:
+    case 8:
+      return 8;
+    case 15:
+    case 16:
+      return 16;
+    case 24:
+    case 32:
+      return 32;
+    }
+
+  return 0;
+}
+
+#define __GDK_IMAGE_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkinput-directfb.c gtk+/gdk/directfb/gdkinput-directfb.c
--- old/gdk/directfb/gdkinput-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkinput-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,332 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ * Copyright (C) 1999 Tor Lillqvist
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+#include "gdkinput-directfb.h"
+
+#include "gdkinput.h"
+#include "gdkkeysyms.h"
+#include "gdkalias.h"
+
+
+static GdkDeviceAxis gdk_input_core_axes[] =
+{
+  { GDK_AXIS_X, 0, 0 },
+  { GDK_AXIS_Y, 0, 0 }
+};
+
+
+GdkDevice     * _gdk_core_pointer       = NULL;
+GList         * _gdk_input_devices      = NULL;
+gboolean        _gdk_input_ignore_core  = FALSE;
+
+int             _gdk_directfb_mouse_x   = 0;
+int             _gdk_directfb_mouse_y   = 0;
+
+
+void
+_gdk_init_input_core (void)
+{
+ GdkDisplay *display = GDK_DISPLAY_OBJECT(_gdk_display);
+  _gdk_core_pointer = g_object_new (GDK_TYPE_DEVICE, NULL);
+
+  _gdk_core_pointer->name       = "Core Pointer";
+  _gdk_core_pointer->source     = GDK_SOURCE_MOUSE;
+  _gdk_core_pointer->mode       = GDK_MODE_SCREEN;
+  _gdk_core_pointer->has_cursor = TRUE;
+  _gdk_core_pointer->num_axes   = 2;
+  _gdk_core_pointer->axes       = gdk_input_core_axes;
+  _gdk_core_pointer->num_keys   = 0;
+  _gdk_core_pointer->keys       = NULL;
+  display->core_pointer         = _gdk_core_pointer;
+}
+
+static void
+gdk_device_finalize (GObject *object)
+{
+  g_error ("A GdkDevice object was finalized. This should not happen");
+}
+
+static void
+gdk_device_class_init (GObjectClass *class)
+{
+  class->finalize = gdk_device_finalize;
+}
+
+GType
+gdk_device_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+      {
+        sizeof (GdkDeviceClass),
+        (GBaseInitFunc) NULL,
+        (GBaseFinalizeFunc) NULL,
+        (GClassInitFunc) gdk_device_class_init,
+        NULL,           /* class_finalize */
+        NULL,           /* class_data */
+        sizeof (GdkDevice),
+        0,              /* n_preallocs */
+        (GInstanceInitFunc) NULL,
+      };
+
+      object_type = g_type_register_static (G_TYPE_OBJECT,
+                                            "GdkDevice",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+
+void
+_gdk_input_init (void)
+{
+  _gdk_init_input_core ();
+  _gdk_input_devices = g_list_append (NULL, _gdk_core_pointer);
+  _gdk_input_ignore_core = FALSE;
+}
+
+void
+_gdk_input_exit (void)
+{
+  GList     *tmp_list;
+  GdkDevice *gdkdev;
+
+  for (tmp_list = _gdk_input_devices; tmp_list; tmp_list = tmp_list->next)
+    {
+      gdkdev = (GdkDevice *)(tmp_list->data);
+      if (!GDK_IS_CORE (gdkdev))
+	{
+	  gdk_device_set_mode ((GdkDevice *)gdkdev, GDK_MODE_DISABLED);
+
+	  g_free (gdkdev->name);
+	  g_free (gdkdev->axes);
+	  g_free (gdkdev->keys);
+	  g_free (gdkdev);
+	}
+    }
+
+  g_list_free (_gdk_input_devices);
+}
+
+/**
+ * gdk_device_get_axis:
+ * @device: a #GdkDevice
+ * @axes: pointer to an array of axes
+ * @use: the use to look for
+ * @value: location to store the found value.
+ *
+ * Interprets an array of double as axis values for a given device,
+ * and locates the value in the array for a given axis use.
+ *
+ * Return value: %TRUE if the given axis use was found, otherwise %FALSE
+ **/
+gboolean
+gdk_device_get_axis (GdkDevice  *device,
+                     gdouble    *axes,
+                     GdkAxisUse  use,
+                     gdouble    *value)
+{
+  gint i;
+  g_return_val_if_fail (device != NULL, FALSE);
+
+  if (axes == NULL)
+    return FALSE;
+
+  for (i = 0; i < device->num_axes; i++)
+    if (device->axes[i].use == use)
+      {
+	if (value)
+	  *value = axes[i];
+	return TRUE;
+      }
+
+  return FALSE;
+}
+
+void
+gdk_device_set_key (GdkDevice       *device,
+                    guint            index,
+                    guint            keyval,
+                    GdkModifierType  modifiers)
+{
+  g_return_if_fail (device != NULL);
+  g_return_if_fail (index < device->num_keys);
+
+  device->keys[index].keyval    = keyval;
+  device->keys[index].modifiers = modifiers;
+}
+
+void
+gdk_device_set_axis_use (GdkDevice   *device,
+                         guint        index,
+                         GdkAxisUse   use)
+{
+  g_return_if_fail (device != NULL);
+  g_return_if_fail (index < device->num_axes);
+
+  device->axes[index].use = use;
+
+  switch (use)
+    {
+    case GDK_AXIS_X:
+    case GDK_AXIS_Y:
+      device->axes[index].min =  0.0;
+      device->axes[index].max =  0.0;
+      break;
+    case GDK_AXIS_XTILT:
+    case GDK_AXIS_YTILT:
+      device->axes[index].min = -1.0;
+      device->axes[index].max =  1.0;
+      break;
+    default:
+      device->axes[index].min =  0.0;
+      device->axes[index].max =  1.0;
+      break;
+    }
+}
+
+gboolean
+gdk_device_set_mode (GdkDevice    *device,
+                     GdkInputMode  mode)
+{
+  g_message ("unimplemented %s", G_GNUC_FUNCTION);
+
+  return FALSE;
+}
+
+gboolean
+gdk_device_get_history  (GdkDevice      *device,
+                         GdkWindow      *window,
+                         guint32         start,
+                         guint32         stop,
+                         GdkTimeCoord ***events,
+                         gint           *n_events)
+{
+  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
+  g_return_val_if_fail (events != NULL, FALSE);
+  g_return_val_if_fail (n_events != NULL, FALSE);
+
+  *n_events = 0;
+  *events = NULL;
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return FALSE;
+
+  if (GDK_IS_CORE (device))
+    return FALSE;
+  else
+    return FALSE;
+  //TODODO_gdk_device_get_history (device, window, start, stop, events, n_events);
+}
+
+void
+gdk_device_free_history (GdkTimeCoord **events,
+                         gint           n_events)
+{
+  gint i;
+
+  for (i = 0; i < n_events; i++)
+    g_free (events[i]);
+
+  g_free (events);
+}
+
+void
+gdk_device_get_state (GdkDevice       *device,
+                      GdkWindow       *window,
+                      gdouble         *axes,
+                      GdkModifierType *mask)
+{
+  g_return_if_fail (device != NULL);
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (mask)
+    *mask = _gdk_directfb_modifiers;
+}
+
+void
+gdk_directfb_mouse_get_info (gint            *x,
+                             gint            *y,
+                             GdkModifierType *mask)
+{
+  if (x)
+    *x = _gdk_directfb_mouse_x;
+
+  if (y)
+    *y = _gdk_directfb_mouse_y;
+
+  if (mask)
+    *mask = _gdk_directfb_modifiers;
+}
+
+void
+gdk_input_set_extension_events (GdkWindow        *window,
+                                gint              mask,
+                                GdkExtensionMode  mode)
+{
+  g_message ("unimplemented %s", G_GNUC_FUNCTION);
+}
+
+GList *
+gdk_devices_list (void)
+{
+  return _gdk_input_devices;
+}
+
+
+GList *
+gdk_display_list_devices (GdkDisplay *dpy)
+{
+  return _gdk_input_devices;
+}
+
+void
+gdk_device_set_source (GdkDevice      *device,
+                       GdkInputSource  source)
+{
+  g_return_if_fail (device != NULL);
+  device->source = source;
+}
+
+#define __GDK_INPUT_NONE_C__
+#define __GDK_INPUT_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkinput-directfb.h gtk+/gdk/directfb/gdkinput-directfb.h
--- old/gdk/directfb/gdkinput-directfb.h	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkinput-directfb.h	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,144 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002       convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#ifndef __GDK_INPUT_DIRECTFB_H__
+#define __GDK_INPUT_DIRECTFB_H__
+
+extern GdkModifierType _gdk_directfb_modifiers;
+extern int _gdk_directfb_mouse_x, _gdk_directfb_mouse_y;
+
+typedef struct _GdkAxisInfo      GdkAxisInfo;
+typedef struct _GdkInputWindow   GdkInputWindow;
+
+/* information about a device axis */
+struct _GdkAxisInfo
+{
+  /* reported x resolution */
+  gint xresolution;
+
+  /* reported x minimum/maximum values */
+  gint xmin_value, xmax_value;
+
+  /* calibrated resolution (for aspect ration) - only relative values
+     between axes used */
+  gint resolution;
+
+  /* calibrated minimum/maximum values */
+  gint min_value, max_value;
+};
+
+#define GDK_INPUT_NUM_EVENTC 6
+
+struct _GdkDeviceClass
+{
+  GObjectClass parent_class;
+};
+
+struct _GdkInputWindow
+{
+  /* gdk window */
+  GdkWindow *window;
+
+  /* Extension mode (GDK_EXTENSION_EVENTS_ALL/CURSOR) */
+  GdkExtensionMode mode;
+
+  /* position relative to root window */
+  gint root_x;
+  gint root_y;
+
+  /* rectangles relative to window of windows obscuring this one */
+  GdkRectangle *obscuring;
+  gint num_obscuring;
+
+  /* Is there a pointer grab for this window ? */
+  gint grabbed;
+};
+
+/* Global data */
+
+#define GDK_IS_CORE(d) (((GdkDevice *)(d)) == _gdk_core_pointer)
+
+extern GList *_gdk_input_devices;
+extern GList *_gdk_input_windows;
+
+extern gint   _gdk_input_ignore_core;
+
+/* Function declarations */
+
+/* The following functions are provided by each implementation
+ */
+gint             _gdk_input_window_none_event(GdkEvent          *event,
+                                              gchar             *msg);
+void             _gdk_input_configure_event  (GdkEventConfigure *event,
+                                              GdkWindow         *window);
+void             _gdk_input_enter_event      (GdkEventCrossing  *event,
+                                              GdkWindow         *window);
+gint             _gdk_input_other_event      (GdkEvent          *event,
+                                              gchar             *msg,
+                                              GdkWindow         *window);
+
+/* These should be in gdkinternals.h */
+
+GdkInputWindow  * gdk_input_window_find      (GdkWindow         *window);
+
+void              gdk_input_window_destroy   (GdkWindow         *window);
+
+gint             _gdk_input_enable_window    (GdkWindow         *window,
+                                              GdkDevice         *gdkdev);
+gint             _gdk_input_disable_window   (GdkWindow         *window,
+                                              GdkDevice         *gdkdev);
+gint             _gdk_input_grab_pointer     (GdkWindow         *window,
+                                              gint               owner_events,
+                                              GdkEventMask       event_mask,
+                                              GdkWindow         *confine_to,
+                                              guint32            time);
+void             _gdk_input_ungrab_pointer   (guint32            time);
+gboolean         _gdk_device_get_history     (GdkDevice         *device,
+                                              GdkWindow         *window,
+                                              guint32            start,
+                                              guint32            stop,
+                                              GdkTimeCoord    ***events,
+                                              gint              *n_events);
+
+gint             gdk_input_common_init        (gint              include_core);
+gint             gdk_input_common_other_event (GdkEvent         *event,
+                                               gchar            *msg,
+                                               GdkInputWindow   *input_window,
+                                               GdkWindow        *window);
+
+void         _gdk_directfb_keyboard_init      (void);
+void         _gdk_directfb_keyboard_exit      (void);
+
+void         gdk_directfb_translate_key_event (DFBWindowEvent   *dfb_event,
+                                               GdkEventKey      *event);
+
+#endif /* __GDK_INPUT_DIRECTFB_H__ */
diff -ruN old/gdk/directfb/gdkkeys-directfb.c gtk+/gdk/directfb/gdkkeys-directfb.c
--- old/gdk/directfb/gdkkeys-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkkeys-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,2012 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 2000 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002       convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkkeysyms.h"
+#include "gdkalias.h"
+
+static struct gdk_key *gdk_keys_by_name = NULL;
+
+GdkModifierType  _gdk_directfb_modifiers = 0;
+
+static guint     *directfb_keymap        = NULL;
+static gint       directfb_min_keycode   = 0;
+static gint       directfb_max_keycode   = 0;
+
+
+/* 
+ *  This array needs to be sorted by key values. It can be generated
+ *  from gdkkeysyms.h using a few lines of Perl. This is a bit more
+ *  complex as one would expect since GDK defines multiple names for a
+ *  few key values. We throw the most akward of them away (GDK_Ln and
+ *  GDK_Rn).  This code seems to do the trick:
+ *
+ *      while (<>) {
+ *          if (/^\#define GDK\_(\w+) 0x([0-9|a-f|A-F|]+)/) {
+ *	        push @{ $names{hex $2} }, $1;
+ *          }
+ *      }
+ *      foreach $value (sort { $a <=> $b } keys %names) {
+ *          for (@{ $names{$value} } ) {
+ * 	        next if (/^[R|L]\d+/);
+ *              print "  { GDK_$_, \"$_\" },\n";
+ *          }
+ *      }
+ */
+static const struct gdk_key
+{
+  guint        keyval;
+  const gchar *name;
+} gdk_keys_by_keyval[] = {
+  { GDK_space, "space" },
+  { GDK_exclam, "exclam" },
+  { GDK_quotedbl, "quotedbl" },
+  { GDK_numbersign, "numbersign" },
+  { GDK_dollar, "dollar" },
+  { GDK_percent, "percent" },
+  { GDK_ampersand, "ampersand" },
+  { GDK_apostrophe, "apostrophe" },
+  { GDK_quoteright, "quoteright" },
+  { GDK_parenleft, "parenleft" },
+  { GDK_parenright, "parenright" },
+  { GDK_asterisk, "asterisk" },
+  { GDK_plus, "plus" },
+  { GDK_comma, "comma" },
+  { GDK_minus, "minus" },
+  { GDK_period, "period" },
+  { GDK_slash, "slash" },
+  { GDK_0, "0" },
+  { GDK_1, "1" },
+  { GDK_2, "2" },
+  { GDK_3, "3" },
+  { GDK_4, "4" },
+  { GDK_5, "5" },
+  { GDK_6, "6" },
+  { GDK_7, "7" },
+  { GDK_8, "8" },
+  { GDK_9, "9" },
+  { GDK_colon, "colon" },
+  { GDK_semicolon, "semicolon" },
+  { GDK_less, "less" },
+  { GDK_equal, "equal" },
+  { GDK_greater, "greater" },
+  { GDK_question, "question" },
+  { GDK_at, "at" },
+  { GDK_A, "A" },
+  { GDK_B, "B" },
+  { GDK_C, "C" },
+  { GDK_D, "D" },
+  { GDK_E, "E" },
+  { GDK_F, "F" },
+  { GDK_G, "G" },
+  { GDK_H, "H" },
+  { GDK_I, "I" },
+  { GDK_J, "J" },
+  { GDK_K, "K" },
+  { GDK_L, "L" },
+  { GDK_M, "M" },
+  { GDK_N, "N" },
+  { GDK_O, "O" },
+  { GDK_P, "P" },
+  { GDK_Q, "Q" },
+  { GDK_R, "R" },
+  { GDK_S, "S" },
+  { GDK_T, "T" },
+  { GDK_U, "U" },
+  { GDK_V, "V" },
+  { GDK_W, "W" },
+  { GDK_X, "X" },
+  { GDK_Y, "Y" },
+  { GDK_Z, "Z" },
+  { GDK_bracketleft, "bracketleft" },
+  { GDK_backslash, "backslash" },
+  { GDK_bracketright, "bracketright" },
+  { GDK_asciicircum, "asciicircum" },
+  { GDK_underscore, "underscore" },
+  { GDK_grave, "grave" },
+  { GDK_quoteleft, "quoteleft" },
+  { GDK_a, "a" },
+  { GDK_b, "b" },
+  { GDK_c, "c" },
+  { GDK_d, "d" },
+  { GDK_e, "e" },
+  { GDK_f, "f" },
+  { GDK_g, "g" },
+  { GDK_h, "h" },
+  { GDK_i, "i" },
+  { GDK_j, "j" },
+  { GDK_k, "k" },
+  { GDK_l, "l" },
+  { GDK_m, "m" },
+  { GDK_n, "n" },
+  { GDK_o, "o" },
+  { GDK_p, "p" },
+  { GDK_q, "q" },
+  { GDK_r, "r" },
+  { GDK_s, "s" },
+  { GDK_t, "t" },
+  { GDK_u, "u" },
+  { GDK_v, "v" },
+  { GDK_w, "w" },
+  { GDK_x, "x" },
+  { GDK_y, "y" },
+  { GDK_z, "z" },
+  { GDK_braceleft, "braceleft" },
+  { GDK_bar, "bar" },
+  { GDK_braceright, "braceright" },
+  { GDK_asciitilde, "asciitilde" },
+  { GDK_nobreakspace, "nobreakspace" },
+  { GDK_exclamdown, "exclamdown" },
+  { GDK_cent, "cent" },
+  { GDK_sterling, "sterling" },
+  { GDK_currency, "currency" },
+  { GDK_yen, "yen" },
+  { GDK_brokenbar, "brokenbar" },
+  { GDK_section, "section" },
+  { GDK_diaeresis, "diaeresis" },
+  { GDK_copyright, "copyright" },
+  { GDK_ordfeminine, "ordfeminine" },
+  { GDK_guillemotleft, "guillemotleft" },
+  { GDK_notsign, "notsign" },
+  { GDK_hyphen, "hyphen" },
+  { GDK_registered, "registered" },
+  { GDK_macron, "macron" },
+  { GDK_degree, "degree" },
+  { GDK_plusminus, "plusminus" },
+  { GDK_twosuperior, "twosuperior" },
+  { GDK_threesuperior, "threesuperior" },
+  { GDK_acute, "acute" },
+  { GDK_mu, "mu" },
+  { GDK_paragraph, "paragraph" },
+  { GDK_periodcentered, "periodcentered" },
+  { GDK_cedilla, "cedilla" },
+  { GDK_onesuperior, "onesuperior" },
+  { GDK_masculine, "masculine" },
+  { GDK_guillemotright, "guillemotright" },
+  { GDK_onequarter, "onequarter" },
+  { GDK_onehalf, "onehalf" },
+  { GDK_threequarters, "threequarters" },
+  { GDK_questiondown, "questiondown" },
+  { GDK_Agrave, "Agrave" },
+  { GDK_Aacute, "Aacute" },
+  { GDK_Acircumflex, "Acircumflex" },
+  { GDK_Atilde, "Atilde" },
+  { GDK_Adiaeresis, "Adiaeresis" },
+  { GDK_Aring, "Aring" },
+  { GDK_AE, "AE" },
+  { GDK_Ccedilla, "Ccedilla" },
+  { GDK_Egrave, "Egrave" },
+  { GDK_Eacute, "Eacute" },
+  { GDK_Ecircumflex, "Ecircumflex" },
+  { GDK_Ediaeresis, "Ediaeresis" },
+  { GDK_Igrave, "Igrave" },
+  { GDK_Iacute, "Iacute" },
+  { GDK_Icircumflex, "Icircumflex" },
+  { GDK_Idiaeresis, "Idiaeresis" },
+  { GDK_ETH, "ETH" },
+  { GDK_Eth, "Eth" },
+  { GDK_Ntilde, "Ntilde" },
+  { GDK_Ograve, "Ograve" },
+  { GDK_Oacute, "Oacute" },
+  { GDK_Ocircumflex, "Ocircumflex" },
+  { GDK_Otilde, "Otilde" },
+  { GDK_Odiaeresis, "Odiaeresis" },
+  { GDK_multiply, "multiply" },
+  { GDK_Ooblique, "Ooblique" },
+  { GDK_Ugrave, "Ugrave" },
+  { GDK_Uacute, "Uacute" },
+  { GDK_Ucircumflex, "Ucircumflex" },
+  { GDK_Udiaeresis, "Udiaeresis" },
+  { GDK_Yacute, "Yacute" },
+  { GDK_THORN, "THORN" },
+  { GDK_Thorn, "Thorn" },
+  { GDK_ssharp, "ssharp" },
+  { GDK_agrave, "agrave" },
+  { GDK_aacute, "aacute" },
+  { GDK_acircumflex, "acircumflex" },
+  { GDK_atilde, "atilde" },
+  { GDK_adiaeresis, "adiaeresis" },
+  { GDK_aring, "aring" },
+  { GDK_ae, "ae" },
+  { GDK_ccedilla, "ccedilla" },
+  { GDK_egrave, "egrave" },
+  { GDK_eacute, "eacute" },
+  { GDK_ecircumflex, "ecircumflex" },
+  { GDK_ediaeresis, "ediaeresis" },
+  { GDK_igrave, "igrave" },
+  { GDK_iacute, "iacute" },
+  { GDK_icircumflex, "icircumflex" },
+  { GDK_idiaeresis, "idiaeresis" },
+  { GDK_eth, "eth" },
+  { GDK_ntilde, "ntilde" },
+  { GDK_ograve, "ograve" },
+  { GDK_oacute, "oacute" },
+  { GDK_ocircumflex, "ocircumflex" },
+  { GDK_otilde, "otilde" },
+  { GDK_odiaeresis, "odiaeresis" },
+  { GDK_division, "division" },
+  { GDK_oslash, "oslash" },
+  { GDK_ugrave, "ugrave" },
+  { GDK_uacute, "uacute" },
+  { GDK_ucircumflex, "ucircumflex" },
+  { GDK_udiaeresis, "udiaeresis" },
+  { GDK_yacute, "yacute" },
+  { GDK_thorn, "thorn" },
+  { GDK_ydiaeresis, "ydiaeresis" },
+  { GDK_Aogonek, "Aogonek" },
+  { GDK_breve, "breve" },
+  { GDK_Lstroke, "Lstroke" },
+  { GDK_Lcaron, "Lcaron" },
+  { GDK_Sacute, "Sacute" },
+  { GDK_Scaron, "Scaron" },
+  { GDK_Scedilla, "Scedilla" },
+  { GDK_Tcaron, "Tcaron" },
+  { GDK_Zacute, "Zacute" },
+  { GDK_Zcaron, "Zcaron" },
+  { GDK_Zabovedot, "Zabovedot" },
+  { GDK_aogonek, "aogonek" },
+  { GDK_ogonek, "ogonek" },
+  { GDK_lstroke, "lstroke" },
+  { GDK_lcaron, "lcaron" },
+  { GDK_sacute, "sacute" },
+  { GDK_caron, "caron" },
+  { GDK_scaron, "scaron" },
+  { GDK_scedilla, "scedilla" },
+  { GDK_tcaron, "tcaron" },
+  { GDK_zacute, "zacute" },
+  { GDK_doubleacute, "doubleacute" },
+  { GDK_zcaron, "zcaron" },
+  { GDK_zabovedot, "zabovedot" },
+  { GDK_Racute, "Racute" },
+  { GDK_Abreve, "Abreve" },
+  { GDK_Lacute, "Lacute" },
+  { GDK_Cacute, "Cacute" },
+  { GDK_Ccaron, "Ccaron" },
+  { GDK_Eogonek, "Eogonek" },
+  { GDK_Ecaron, "Ecaron" },
+  { GDK_Dcaron, "Dcaron" },
+  { GDK_Dstroke, "Dstroke" },
+  { GDK_Nacute, "Nacute" },
+  { GDK_Ncaron, "Ncaron" },
+  { GDK_Odoubleacute, "Odoubleacute" },
+  { GDK_Rcaron, "Rcaron" },
+  { GDK_Uring, "Uring" },
+  { GDK_Udoubleacute, "Udoubleacute" },
+  { GDK_Tcedilla, "Tcedilla" },
+  { GDK_racute, "racute" },
+  { GDK_abreve, "abreve" },
+  { GDK_lacute, "lacute" },
+  { GDK_cacute, "cacute" },
+  { GDK_ccaron, "ccaron" },
+  { GDK_eogonek, "eogonek" },
+  { GDK_ecaron, "ecaron" },
+  { GDK_dcaron, "dcaron" },
+  { GDK_dstroke, "dstroke" },
+  { GDK_nacute, "nacute" },
+  { GDK_ncaron, "ncaron" },
+  { GDK_odoubleacute, "odoubleacute" },
+  { GDK_rcaron, "rcaron" },
+  { GDK_uring, "uring" },
+  { GDK_udoubleacute, "udoubleacute" },
+  { GDK_tcedilla, "tcedilla" },
+  { GDK_abovedot, "abovedot" },
+  { GDK_Hstroke, "Hstroke" },
+  { GDK_Hcircumflex, "Hcircumflex" },
+  { GDK_Iabovedot, "Iabovedot" },
+  { GDK_Gbreve, "Gbreve" },
+  { GDK_Jcircumflex, "Jcircumflex" },
+  { GDK_hstroke, "hstroke" },
+  { GDK_hcircumflex, "hcircumflex" },
+  { GDK_idotless, "idotless" },
+  { GDK_gbreve, "gbreve" },
+  { GDK_jcircumflex, "jcircumflex" },
+  { GDK_Cabovedot, "Cabovedot" },
+  { GDK_Ccircumflex, "Ccircumflex" },
+  { GDK_Gabovedot, "Gabovedot" },
+  { GDK_Gcircumflex, "Gcircumflex" },
+  { GDK_Ubreve, "Ubreve" },
+  { GDK_Scircumflex, "Scircumflex" },
+  { GDK_cabovedot, "cabovedot" },
+  { GDK_ccircumflex, "ccircumflex" },
+  { GDK_gabovedot, "gabovedot" },
+  { GDK_gcircumflex, "gcircumflex" },
+  { GDK_ubreve, "ubreve" },
+  { GDK_scircumflex, "scircumflex" },
+  { GDK_kra, "kra" },
+  { GDK_kappa, "kappa" },
+  { GDK_Rcedilla, "Rcedilla" },
+  { GDK_Itilde, "Itilde" },
+  { GDK_Lcedilla, "Lcedilla" },
+  { GDK_Emacron, "Emacron" },
+  { GDK_Gcedilla, "Gcedilla" },
+  { GDK_Tslash, "Tslash" },
+  { GDK_rcedilla, "rcedilla" },
+  { GDK_itilde, "itilde" },
+  { GDK_lcedilla, "lcedilla" },
+  { GDK_emacron, "emacron" },
+  { GDK_gcedilla, "gcedilla" },
+  { GDK_tslash, "tslash" },
+  { GDK_ENG, "ENG" },
+  { GDK_eng, "eng" },
+  { GDK_Amacron, "Amacron" },
+  { GDK_Iogonek, "Iogonek" },
+  { GDK_Eabovedot, "Eabovedot" },
+  { GDK_Imacron, "Imacron" },
+  { GDK_Ncedilla, "Ncedilla" },
+  { GDK_Omacron, "Omacron" },
+  { GDK_Kcedilla, "Kcedilla" },
+  { GDK_Uogonek, "Uogonek" },
+  { GDK_Utilde, "Utilde" },
+  { GDK_Umacron, "Umacron" },
+  { GDK_amacron, "amacron" },
+  { GDK_iogonek, "iogonek" },
+  { GDK_eabovedot, "eabovedot" },
+  { GDK_imacron, "imacron" },
+  { GDK_ncedilla, "ncedilla" },
+  { GDK_omacron, "omacron" },
+  { GDK_kcedilla, "kcedilla" },
+  { GDK_uogonek, "uogonek" },
+  { GDK_utilde, "utilde" },
+  { GDK_umacron, "umacron" },
+  { GDK_overline, "overline" },
+  { GDK_kana_fullstop, "kana_fullstop" },
+  { GDK_kana_openingbracket, "kana_openingbracket" },
+  { GDK_kana_closingbracket, "kana_closingbracket" },
+  { GDK_kana_comma, "kana_comma" },
+  { GDK_kana_conjunctive, "kana_conjunctive" },
+  { GDK_kana_middledot, "kana_middledot" },
+  { GDK_kana_WO, "kana_WO" },
+  { GDK_kana_a, "kana_a" },
+  { GDK_kana_i, "kana_i" },
+  { GDK_kana_u, "kana_u" },
+  { GDK_kana_e, "kana_e" },
+  { GDK_kana_o, "kana_o" },
+  { GDK_kana_ya, "kana_ya" },
+  { GDK_kana_yu, "kana_yu" },
+  { GDK_kana_yo, "kana_yo" },
+  { GDK_kana_tsu, "kana_tsu" },
+  { GDK_kana_tu, "kana_tu" },
+  { GDK_prolongedsound, "prolongedsound" },
+  { GDK_kana_A, "kana_A" },
+  { GDK_kana_I, "kana_I" },
+  { GDK_kana_U, "kana_U" },
+  { GDK_kana_E, "kana_E" },
+  { GDK_kana_O, "kana_O" },
+  { GDK_kana_KA, "kana_KA" },
+  { GDK_kana_KI, "kana_KI" },
+  { GDK_kana_KU, "kana_KU" },
+  { GDK_kana_KE, "kana_KE" },
+  { GDK_kana_KO, "kana_KO" },
+  { GDK_kana_SA, "kana_SA" },
+  { GDK_kana_SHI, "kana_SHI" },
+  { GDK_kana_SU, "kana_SU" },
+  { GDK_kana_SE, "kana_SE" },
+  { GDK_kana_SO, "kana_SO" },
+  { GDK_kana_TA, "kana_TA" },
+  { GDK_kana_CHI, "kana_CHI" },
+  { GDK_kana_TI, "kana_TI" },
+  { GDK_kana_TSU, "kana_TSU" },
+  { GDK_kana_TU, "kana_TU" },
+  { GDK_kana_TE, "kana_TE" },
+  { GDK_kana_TO, "kana_TO" },
+  { GDK_kana_NA, "kana_NA" },
+  { GDK_kana_NI, "kana_NI" },
+  { GDK_kana_NU, "kana_NU" },
+  { GDK_kana_NE, "kana_NE" },
+  { GDK_kana_NO, "kana_NO" },
+  { GDK_kana_HA, "kana_HA" },
+  { GDK_kana_HI, "kana_HI" },
+  { GDK_kana_FU, "kana_FU" },
+  { GDK_kana_HU, "kana_HU" },
+  { GDK_kana_HE, "kana_HE" },
+  { GDK_kana_HO, "kana_HO" },
+  { GDK_kana_MA, "kana_MA" },
+  { GDK_kana_MI, "kana_MI" },
+  { GDK_kana_MU, "kana_MU" },
+  { GDK_kana_ME, "kana_ME" },
+  { GDK_kana_MO, "kana_MO" },
+  { GDK_kana_YA, "kana_YA" },
+  { GDK_kana_YU, "kana_YU" },
+  { GDK_kana_YO, "kana_YO" },
+  { GDK_kana_RA, "kana_RA" },
+  { GDK_kana_RI, "kana_RI" },
+  { GDK_kana_RU, "kana_RU" },
+  { GDK_kana_RE, "kana_RE" },
+  { GDK_kana_RO, "kana_RO" },
+  { GDK_kana_WA, "kana_WA" },
+  { GDK_kana_N, "kana_N" },
+  { GDK_voicedsound, "voicedsound" },
+  { GDK_semivoicedsound, "semivoicedsound" },
+  { GDK_Arabic_comma, "Arabic_comma" },
+  { GDK_Arabic_semicolon, "Arabic_semicolon" },
+  { GDK_Arabic_question_mark, "Arabic_question_mark" },
+  { GDK_Arabic_hamza, "Arabic_hamza" },
+  { GDK_Arabic_maddaonalef, "Arabic_maddaonalef" },
+  { GDK_Arabic_hamzaonalef, "Arabic_hamzaonalef" },
+  { GDK_Arabic_hamzaonwaw, "Arabic_hamzaonwaw" },
+  { GDK_Arabic_hamzaunderalef, "Arabic_hamzaunderalef" },
+  { GDK_Arabic_hamzaonyeh, "Arabic_hamzaonyeh" },
+  { GDK_Arabic_alef, "Arabic_alef" },
+  { GDK_Arabic_beh, "Arabic_beh" },
+  { GDK_Arabic_tehmarbuta, "Arabic_tehmarbuta" },
+  { GDK_Arabic_teh, "Arabic_teh" },
+  { GDK_Arabic_theh, "Arabic_theh" },
+  { GDK_Arabic_jeem, "Arabic_jeem" },
+  { GDK_Arabic_hah, "Arabic_hah" },
+  { GDK_Arabic_khah, "Arabic_khah" },
+  { GDK_Arabic_dal, "Arabic_dal" },
+  { GDK_Arabic_thal, "Arabic_thal" },
+  { GDK_Arabic_ra, "Arabic_ra" },
+  { GDK_Arabic_zain, "Arabic_zain" },
+  { GDK_Arabic_seen, "Arabic_seen" },
+  { GDK_Arabic_sheen, "Arabic_sheen" },
+  { GDK_Arabic_sad, "Arabic_sad" },
+  { GDK_Arabic_dad, "Arabic_dad" },
+  { GDK_Arabic_tah, "Arabic_tah" },
+  { GDK_Arabic_zah, "Arabic_zah" },
+  { GDK_Arabic_ain, "Arabic_ain" },
+  { GDK_Arabic_ghain, "Arabic_ghain" },
+  { GDK_Arabic_tatweel, "Arabic_tatweel" },
+  { GDK_Arabic_feh, "Arabic_feh" },
+  { GDK_Arabic_qaf, "Arabic_qaf" },
+  { GDK_Arabic_kaf, "Arabic_kaf" },
+  { GDK_Arabic_lam, "Arabic_lam" },
+  { GDK_Arabic_meem, "Arabic_meem" },
+  { GDK_Arabic_noon, "Arabic_noon" },
+  { GDK_Arabic_ha, "Arabic_ha" },
+  { GDK_Arabic_heh, "Arabic_heh" },
+  { GDK_Arabic_waw, "Arabic_waw" },
+  { GDK_Arabic_alefmaksura, "Arabic_alefmaksura" },
+  { GDK_Arabic_yeh, "Arabic_yeh" },
+  { GDK_Arabic_fathatan, "Arabic_fathatan" },
+  { GDK_Arabic_dammatan, "Arabic_dammatan" },
+  { GDK_Arabic_kasratan, "Arabic_kasratan" },
+  { GDK_Arabic_fatha, "Arabic_fatha" },
+  { GDK_Arabic_damma, "Arabic_damma" },
+  { GDK_Arabic_kasra, "Arabic_kasra" },
+  { GDK_Arabic_shadda, "Arabic_shadda" },
+  { GDK_Arabic_sukun, "Arabic_sukun" },
+  { GDK_Serbian_dje, "Serbian_dje" },
+  { GDK_Macedonia_gje, "Macedonia_gje" },
+  { GDK_Cyrillic_io, "Cyrillic_io" },
+  { GDK_Ukrainian_ie, "Ukrainian_ie" },
+  { GDK_Ukranian_je, "Ukranian_je" },
+  { GDK_Macedonia_dse, "Macedonia_dse" },
+  { GDK_Ukrainian_i, "Ukrainian_i" },
+  { GDK_Ukranian_i, "Ukranian_i" },
+  { GDK_Ukrainian_yi, "Ukrainian_yi" },
+  { GDK_Ukranian_yi, "Ukranian_yi" },
+  { GDK_Cyrillic_je, "Cyrillic_je" },
+  { GDK_Serbian_je, "Serbian_je" },
+  { GDK_Cyrillic_lje, "Cyrillic_lje" },
+  { GDK_Serbian_lje, "Serbian_lje" },
+  { GDK_Cyrillic_nje, "Cyrillic_nje" },
+  { GDK_Serbian_nje, "Serbian_nje" },
+  { GDK_Serbian_tshe, "Serbian_tshe" },
+  { GDK_Macedonia_kje, "Macedonia_kje" },
+  { GDK_Byelorussian_shortu, "Byelorussian_shortu" },
+  { GDK_Cyrillic_dzhe, "Cyrillic_dzhe" },
+  { GDK_Serbian_dze, "Serbian_dze" },
+  { GDK_numerosign, "numerosign" },
+  { GDK_Serbian_DJE, "Serbian_DJE" },
+  { GDK_Macedonia_GJE, "Macedonia_GJE" },
+  { GDK_Cyrillic_IO, "Cyrillic_IO" },
+  { GDK_Ukrainian_IE, "Ukrainian_IE" },
+  { GDK_Ukranian_JE, "Ukranian_JE" },
+  { GDK_Macedonia_DSE, "Macedonia_DSE" },
+  { GDK_Ukrainian_I, "Ukrainian_I" },
+  { GDK_Ukranian_I, "Ukranian_I" },
+  { GDK_Ukrainian_YI, "Ukrainian_YI" },
+  { GDK_Ukranian_YI, "Ukranian_YI" },
+  { GDK_Cyrillic_JE, "Cyrillic_JE" },
+  { GDK_Serbian_JE, "Serbian_JE" },
+  { GDK_Cyrillic_LJE, "Cyrillic_LJE" },
+  { GDK_Serbian_LJE, "Serbian_LJE" },
+  { GDK_Cyrillic_NJE, "Cyrillic_NJE" },
+  { GDK_Serbian_NJE, "Serbian_NJE" },
+  { GDK_Serbian_TSHE, "Serbian_TSHE" },
+  { GDK_Macedonia_KJE, "Macedonia_KJE" },
+  { GDK_Byelorussian_SHORTU, "Byelorussian_SHORTU" },
+  { GDK_Cyrillic_DZHE, "Cyrillic_DZHE" },
+  { GDK_Serbian_DZE, "Serbian_DZE" },
+  { GDK_Cyrillic_yu, "Cyrillic_yu" },
+  { GDK_Cyrillic_a, "Cyrillic_a" },
+  { GDK_Cyrillic_be, "Cyrillic_be" },
+  { GDK_Cyrillic_tse, "Cyrillic_tse" },
+  { GDK_Cyrillic_de, "Cyrillic_de" },
+  { GDK_Cyrillic_ie, "Cyrillic_ie" },
+  { GDK_Cyrillic_ef, "Cyrillic_ef" },
+  { GDK_Cyrillic_ghe, "Cyrillic_ghe" },
+  { GDK_Cyrillic_ha, "Cyrillic_ha" },
+  { GDK_Cyrillic_i, "Cyrillic_i" },
+  { GDK_Cyrillic_shorti, "Cyrillic_shorti" },
+  { GDK_Cyrillic_ka, "Cyrillic_ka" },
+  { GDK_Cyrillic_el, "Cyrillic_el" },
+  { GDK_Cyrillic_em, "Cyrillic_em" },
+  { GDK_Cyrillic_en, "Cyrillic_en" },
+  { GDK_Cyrillic_o, "Cyrillic_o" },
+  { GDK_Cyrillic_pe, "Cyrillic_pe" },
+  { GDK_Cyrillic_ya, "Cyrillic_ya" },
+  { GDK_Cyrillic_er, "Cyrillic_er" },
+  { GDK_Cyrillic_es, "Cyrillic_es" },
+  { GDK_Cyrillic_te, "Cyrillic_te" },
+  { GDK_Cyrillic_u, "Cyrillic_u" },
+  { GDK_Cyrillic_zhe, "Cyrillic_zhe" },
+  { GDK_Cyrillic_ve, "Cyrillic_ve" },
+  { GDK_Cyrillic_softsign, "Cyrillic_softsign" },
+  { GDK_Cyrillic_yeru, "Cyrillic_yeru" },
+  { GDK_Cyrillic_ze, "Cyrillic_ze" },
+  { GDK_Cyrillic_sha, "Cyrillic_sha" },
+  { GDK_Cyrillic_e, "Cyrillic_e" },
+  { GDK_Cyrillic_shcha, "Cyrillic_shcha" },
+  { GDK_Cyrillic_che, "Cyrillic_che" },
+  { GDK_Cyrillic_hardsign, "Cyrillic_hardsign" },
+  { GDK_Cyrillic_YU, "Cyrillic_YU" },
+  { GDK_Cyrillic_A, "Cyrillic_A" },
+  { GDK_Cyrillic_BE, "Cyrillic_BE" },
+  { GDK_Cyrillic_TSE, "Cyrillic_TSE" },
+  { GDK_Cyrillic_DE, "Cyrillic_DE" },
+  { GDK_Cyrillic_IE, "Cyrillic_IE" },
+  { GDK_Cyrillic_EF, "Cyrillic_EF" },
+  { GDK_Cyrillic_GHE, "Cyrillic_GHE" },
+  { GDK_Cyrillic_HA, "Cyrillic_HA" },
+  { GDK_Cyrillic_I, "Cyrillic_I" },
+  { GDK_Cyrillic_SHORTI, "Cyrillic_SHORTI" },
+  { GDK_Cyrillic_KA, "Cyrillic_KA" },
+  { GDK_Cyrillic_EL, "Cyrillic_EL" },
+  { GDK_Cyrillic_EM, "Cyrillic_EM" },
+  { GDK_Cyrillic_EN, "Cyrillic_EN" },
+  { GDK_Cyrillic_O, "Cyrillic_O" },
+  { GDK_Cyrillic_PE, "Cyrillic_PE" },
+  { GDK_Cyrillic_YA, "Cyrillic_YA" },
+  { GDK_Cyrillic_ER, "Cyrillic_ER" },
+  { GDK_Cyrillic_ES, "Cyrillic_ES" },
+  { GDK_Cyrillic_TE, "Cyrillic_TE" },
+  { GDK_Cyrillic_U, "Cyrillic_U" },
+  { GDK_Cyrillic_ZHE, "Cyrillic_ZHE" },
+  { GDK_Cyrillic_VE, "Cyrillic_VE" },
+  { GDK_Cyrillic_SOFTSIGN, "Cyrillic_SOFTSIGN" },
+  { GDK_Cyrillic_YERU, "Cyrillic_YERU" },
+  { GDK_Cyrillic_ZE, "Cyrillic_ZE" },
+  { GDK_Cyrillic_SHA, "Cyrillic_SHA" },
+  { GDK_Cyrillic_E, "Cyrillic_E" },
+  { GDK_Cyrillic_SHCHA, "Cyrillic_SHCHA" },
+  { GDK_Cyrillic_CHE, "Cyrillic_CHE" },
+  { GDK_Cyrillic_HARDSIGN, "Cyrillic_HARDSIGN" },
+  { GDK_Greek_ALPHAaccent, "Greek_ALPHAaccent" },
+  { GDK_Greek_EPSILONaccent, "Greek_EPSILONaccent" },
+  { GDK_Greek_ETAaccent, "Greek_ETAaccent" },
+  { GDK_Greek_IOTAaccent, "Greek_IOTAaccent" },
+  { GDK_Greek_IOTAdiaeresis, "Greek_IOTAdiaeresis" },
+  { GDK_Greek_OMICRONaccent, "Greek_OMICRONaccent" },
+  { GDK_Greek_UPSILONaccent, "Greek_UPSILONaccent" },
+  { GDK_Greek_UPSILONdieresis, "Greek_UPSILONdieresis" },
+  { GDK_Greek_OMEGAaccent, "Greek_OMEGAaccent" },
+  { GDK_Greek_accentdieresis, "Greek_accentdieresis" },
+  { GDK_Greek_horizbar, "Greek_horizbar" },
+  { GDK_Greek_alphaaccent, "Greek_alphaaccent" },
+  { GDK_Greek_epsilonaccent, "Greek_epsilonaccent" },
+  { GDK_Greek_etaaccent, "Greek_etaaccent" },
+  { GDK_Greek_iotaaccent, "Greek_iotaaccent" },
+  { GDK_Greek_iotadieresis, "Greek_iotadieresis" },
+  { GDK_Greek_iotaaccentdieresis, "Greek_iotaaccentdieresis" },
+  { GDK_Greek_omicronaccent, "Greek_omicronaccent" },
+  { GDK_Greek_upsilonaccent, "Greek_upsilonaccent" },
+  { GDK_Greek_upsilondieresis, "Greek_upsilondieresis" },
+  { GDK_Greek_upsilonaccentdieresis, "Greek_upsilonaccentdieresis" },
+  { GDK_Greek_omegaaccent, "Greek_omegaaccent" },
+  { GDK_Greek_ALPHA, "Greek_ALPHA" },
+  { GDK_Greek_BETA, "Greek_BETA" },
+  { GDK_Greek_GAMMA, "Greek_GAMMA" },
+  { GDK_Greek_DELTA, "Greek_DELTA" },
+  { GDK_Greek_EPSILON, "Greek_EPSILON" },
+  { GDK_Greek_ZETA, "Greek_ZETA" },
+  { GDK_Greek_ETA, "Greek_ETA" },
+  { GDK_Greek_THETA, "Greek_THETA" },
+  { GDK_Greek_IOTA, "Greek_IOTA" },
+  { GDK_Greek_KAPPA, "Greek_KAPPA" },
+  { GDK_Greek_LAMDA, "Greek_LAMDA" },
+  { GDK_Greek_LAMBDA, "Greek_LAMBDA" },
+  { GDK_Greek_MU, "Greek_MU" },
+  { GDK_Greek_NU, "Greek_NU" },
+  { GDK_Greek_XI, "Greek_XI" },
+  { GDK_Greek_OMICRON, "Greek_OMICRON" },
+  { GDK_Greek_PI, "Greek_PI" },
+  { GDK_Greek_RHO, "Greek_RHO" },
+  { GDK_Greek_SIGMA, "Greek_SIGMA" },
+  { GDK_Greek_TAU, "Greek_TAU" },
+  { GDK_Greek_UPSILON, "Greek_UPSILON" },
+  { GDK_Greek_PHI, "Greek_PHI" },
+  { GDK_Greek_CHI, "Greek_CHI" },
+  { GDK_Greek_PSI, "Greek_PSI" },
+  { GDK_Greek_OMEGA, "Greek_OMEGA" },
+  { GDK_Greek_alpha, "Greek_alpha" },
+  { GDK_Greek_beta, "Greek_beta" },
+  { GDK_Greek_gamma, "Greek_gamma" },
+  { GDK_Greek_delta, "Greek_delta" },
+  { GDK_Greek_epsilon, "Greek_epsilon" },
+  { GDK_Greek_zeta, "Greek_zeta" },
+  { GDK_Greek_eta, "Greek_eta" },
+  { GDK_Greek_theta, "Greek_theta" },
+  { GDK_Greek_iota, "Greek_iota" },
+  { GDK_Greek_kappa, "Greek_kappa" },
+  { GDK_Greek_lamda, "Greek_lamda" },
+  { GDK_Greek_lambda, "Greek_lambda" },
+  { GDK_Greek_mu, "Greek_mu" },
+  { GDK_Greek_nu, "Greek_nu" },
+  { GDK_Greek_xi, "Greek_xi" },
+  { GDK_Greek_omicron, "Greek_omicron" },
+  { GDK_Greek_pi, "Greek_pi" },
+  { GDK_Greek_rho, "Greek_rho" },
+  { GDK_Greek_sigma, "Greek_sigma" },
+  { GDK_Greek_finalsmallsigma, "Greek_finalsmallsigma" },
+  { GDK_Greek_tau, "Greek_tau" },
+  { GDK_Greek_upsilon, "Greek_upsilon" },
+  { GDK_Greek_phi, "Greek_phi" },
+  { GDK_Greek_chi, "Greek_chi" },
+  { GDK_Greek_psi, "Greek_psi" },
+  { GDK_Greek_omega, "Greek_omega" },
+  { GDK_leftradical, "leftradical" },
+  { GDK_topleftradical, "topleftradical" },
+  { GDK_horizconnector, "horizconnector" },
+  { GDK_topintegral, "topintegral" },
+  { GDK_botintegral, "botintegral" },
+  { GDK_vertconnector, "vertconnector" },
+  { GDK_topleftsqbracket, "topleftsqbracket" },
+  { GDK_botleftsqbracket, "botleftsqbracket" },
+  { GDK_toprightsqbracket, "toprightsqbracket" },
+  { GDK_botrightsqbracket, "botrightsqbracket" },
+  { GDK_topleftparens, "topleftparens" },
+  { GDK_botleftparens, "botleftparens" },
+  { GDK_toprightparens, "toprightparens" },
+  { GDK_botrightparens, "botrightparens" },
+  { GDK_leftmiddlecurlybrace, "leftmiddlecurlybrace" },
+  { GDK_rightmiddlecurlybrace, "rightmiddlecurlybrace" },
+  { GDK_topleftsummation, "topleftsummation" },
+  { GDK_botleftsummation, "botleftsummation" },
+  { GDK_topvertsummationconnector, "topvertsummationconnector" },
+  { GDK_botvertsummationconnector, "botvertsummationconnector" },
+  { GDK_toprightsummation, "toprightsummation" },
+  { GDK_botrightsummation, "botrightsummation" },
+  { GDK_rightmiddlesummation, "rightmiddlesummation" },
+  { GDK_lessthanequal, "lessthanequal" },
+  { GDK_notequal, "notequal" },
+  { GDK_greaterthanequal, "greaterthanequal" },
+  { GDK_integral, "integral" },
+  { GDK_therefore, "therefore" },
+  { GDK_variation, "variation" },
+  { GDK_infinity, "infinity" },
+  { GDK_nabla, "nabla" },
+  { GDK_approximate, "approximate" },
+  { GDK_similarequal, "similarequal" },
+  { GDK_ifonlyif, "ifonlyif" },
+  { GDK_implies, "implies" },
+  { GDK_identical, "identical" },
+  { GDK_radical, "radical" },
+  { GDK_includedin, "includedin" },
+  { GDK_includes, "includes" },
+  { GDK_intersection, "intersection" },
+  { GDK_union, "union" },
+  { GDK_logicaland, "logicaland" },
+  { GDK_logicalor, "logicalor" },
+  { GDK_partialderivative, "partialderivative" },
+  { GDK_function, "function" },
+  { GDK_leftarrow, "leftarrow" },
+  { GDK_uparrow, "uparrow" },
+  { GDK_rightarrow, "rightarrow" },
+  { GDK_downarrow, "downarrow" },
+  { GDK_blank, "blank" },
+  { GDK_soliddiamond, "soliddiamond" },
+  { GDK_checkerboard, "checkerboard" },
+  { GDK_ht, "ht" },
+  { GDK_ff, "ff" },
+  { GDK_cr, "cr" },
+  { GDK_lf, "lf" },
+  { GDK_nl, "nl" },
+  { GDK_vt, "vt" },
+  { GDK_lowrightcorner, "lowrightcorner" },
+  { GDK_uprightcorner, "uprightcorner" },
+  { GDK_upleftcorner, "upleftcorner" },
+  { GDK_lowleftcorner, "lowleftcorner" },
+  { GDK_crossinglines, "crossinglines" },
+  { GDK_horizlinescan1, "horizlinescan1" },
+  { GDK_horizlinescan3, "horizlinescan3" },
+  { GDK_horizlinescan5, "horizlinescan5" },
+  { GDK_horizlinescan7, "horizlinescan7" },
+  { GDK_horizlinescan9, "horizlinescan9" },
+  { GDK_leftt, "leftt" },
+  { GDK_rightt, "rightt" },
+  { GDK_bott, "bott" },
+  { GDK_topt, "topt" },
+  { GDK_vertbar, "vertbar" },
+  { GDK_emspace, "emspace" },
+  { GDK_enspace, "enspace" },
+  { GDK_em3space, "em3space" },
+  { GDK_em4space, "em4space" },
+  { GDK_digitspace, "digitspace" },
+  { GDK_punctspace, "punctspace" },
+  { GDK_thinspace, "thinspace" },
+  { GDK_hairspace, "hairspace" },
+  { GDK_emdash, "emdash" },
+  { GDK_endash, "endash" },
+  { GDK_signifblank, "signifblank" },
+  { GDK_ellipsis, "ellipsis" },
+  { GDK_doubbaselinedot, "doubbaselinedot" },
+  { GDK_onethird, "onethird" },
+  { GDK_twothirds, "twothirds" },
+  { GDK_onefifth, "onefifth" },
+  { GDK_twofifths, "twofifths" },
+  { GDK_threefifths, "threefifths" },
+  { GDK_fourfifths, "fourfifths" },
+  { GDK_onesixth, "onesixth" },
+  { GDK_fivesixths, "fivesixths" },
+  { GDK_careof, "careof" },
+  { GDK_figdash, "figdash" },
+  { GDK_leftanglebracket, "leftanglebracket" },
+  { GDK_decimalpoint, "decimalpoint" },
+  { GDK_rightanglebracket, "rightanglebracket" },
+  { GDK_marker, "marker" },
+  { GDK_oneeighth, "oneeighth" },
+  { GDK_threeeighths, "threeeighths" },
+  { GDK_fiveeighths, "fiveeighths" },
+  { GDK_seveneighths, "seveneighths" },
+  { GDK_trademark, "trademark" },
+  { GDK_signaturemark, "signaturemark" },
+  { GDK_trademarkincircle, "trademarkincircle" },
+  { GDK_leftopentriangle, "leftopentriangle" },
+  { GDK_rightopentriangle, "rightopentriangle" },
+  { GDK_emopencircle, "emopencircle" },
+  { GDK_emopenrectangle, "emopenrectangle" },
+  { GDK_leftsinglequotemark, "leftsinglequotemark" },
+  { GDK_rightsinglequotemark, "rightsinglequotemark" },
+  { GDK_leftdoublequotemark, "leftdoublequotemark" },
+  { GDK_rightdoublequotemark, "rightdoublequotemark" },
+  { GDK_prescription, "prescription" },
+  { GDK_minutes, "minutes" },
+  { GDK_seconds, "seconds" },
+  { GDK_latincross, "latincross" },
+  { GDK_hexagram, "hexagram" },
+  { GDK_filledrectbullet, "filledrectbullet" },
+  { GDK_filledlefttribullet, "filledlefttribullet" },
+  { GDK_filledrighttribullet, "filledrighttribullet" },
+  { GDK_emfilledcircle, "emfilledcircle" },
+  { GDK_emfilledrect, "emfilledrect" },
+  { GDK_enopencircbullet, "enopencircbullet" },
+  { GDK_enopensquarebullet, "enopensquarebullet" },
+  { GDK_openrectbullet, "openrectbullet" },
+  { GDK_opentribulletup, "opentribulletup" },
+  { GDK_opentribulletdown, "opentribulletdown" },
+  { GDK_openstar, "openstar" },
+  { GDK_enfilledcircbullet, "enfilledcircbullet" },
+  { GDK_enfilledsqbullet, "enfilledsqbullet" },
+  { GDK_filledtribulletup, "filledtribulletup" },
+  { GDK_filledtribulletdown, "filledtribulletdown" },
+  { GDK_leftpointer, "leftpointer" },
+  { GDK_rightpointer, "rightpointer" },
+  { GDK_club, "club" },
+  { GDK_diamond, "diamond" },
+  { GDK_heart, "heart" },
+  { GDK_maltesecross, "maltesecross" },
+  { GDK_dagger, "dagger" },
+  { GDK_doubledagger, "doubledagger" },
+  { GDK_checkmark, "checkmark" },
+  { GDK_ballotcross, "ballotcross" },
+  { GDK_musicalsharp, "musicalsharp" },
+  { GDK_musicalflat, "musicalflat" },
+  { GDK_malesymbol, "malesymbol" },
+  { GDK_femalesymbol, "femalesymbol" },
+  { GDK_telephone, "telephone" },
+  { GDK_telephonerecorder, "telephonerecorder" },
+  { GDK_phonographcopyright, "phonographcopyright" },
+  { GDK_caret, "caret" },
+  { GDK_singlelowquotemark, "singlelowquotemark" },
+  { GDK_doublelowquotemark, "doublelowquotemark" },
+  { GDK_cursor, "cursor" },
+  { GDK_leftcaret, "leftcaret" },
+  { GDK_rightcaret, "rightcaret" },
+  { GDK_downcaret, "downcaret" },
+  { GDK_upcaret, "upcaret" },
+  { GDK_overbar, "overbar" },
+  { GDK_downtack, "downtack" },
+  { GDK_upshoe, "upshoe" },
+  { GDK_downstile, "downstile" },
+  { GDK_underbar, "underbar" },
+  { GDK_jot, "jot" },
+  { GDK_quad, "quad" },
+  { GDK_uptack, "uptack" },
+  { GDK_circle, "circle" },
+  { GDK_upstile, "upstile" },
+  { GDK_downshoe, "downshoe" },
+  { GDK_rightshoe, "rightshoe" },
+  { GDK_leftshoe, "leftshoe" },
+  { GDK_lefttack, "lefttack" },
+  { GDK_righttack, "righttack" },
+  { GDK_hebrew_doublelowline, "hebrew_doublelowline" },
+  { GDK_hebrew_aleph, "hebrew_aleph" },
+  { GDK_hebrew_bet, "hebrew_bet" },
+  { GDK_hebrew_beth, "hebrew_beth" },
+  { GDK_hebrew_gimel, "hebrew_gimel" },
+  { GDK_hebrew_gimmel, "hebrew_gimmel" },
+  { GDK_hebrew_dalet, "hebrew_dalet" },
+  { GDK_hebrew_daleth, "hebrew_daleth" },
+  { GDK_hebrew_he, "hebrew_he" },
+  { GDK_hebrew_waw, "hebrew_waw" },
+  { GDK_hebrew_zain, "hebrew_zain" },
+  { GDK_hebrew_zayin, "hebrew_zayin" },
+  { GDK_hebrew_chet, "hebrew_chet" },
+  { GDK_hebrew_het, "hebrew_het" },
+  { GDK_hebrew_tet, "hebrew_tet" },
+  { GDK_hebrew_teth, "hebrew_teth" },
+  { GDK_hebrew_yod, "hebrew_yod" },
+  { GDK_hebrew_finalkaph, "hebrew_finalkaph" },
+  { GDK_hebrew_kaph, "hebrew_kaph" },
+  { GDK_hebrew_lamed, "hebrew_lamed" },
+  { GDK_hebrew_finalmem, "hebrew_finalmem" },
+  { GDK_hebrew_mem, "hebrew_mem" },
+  { GDK_hebrew_finalnun, "hebrew_finalnun" },
+  { GDK_hebrew_nun, "hebrew_nun" },
+  { GDK_hebrew_samech, "hebrew_samech" },
+  { GDK_hebrew_samekh, "hebrew_samekh" },
+  { GDK_hebrew_ayin, "hebrew_ayin" },
+  { GDK_hebrew_finalpe, "hebrew_finalpe" },
+  { GDK_hebrew_pe, "hebrew_pe" },
+  { GDK_hebrew_finalzade, "hebrew_finalzade" },
+  { GDK_hebrew_finalzadi, "hebrew_finalzadi" },
+  { GDK_hebrew_zade, "hebrew_zade" },
+  { GDK_hebrew_zadi, "hebrew_zadi" },
+  { GDK_hebrew_qoph, "hebrew_qoph" },
+  { GDK_hebrew_kuf, "hebrew_kuf" },
+  { GDK_hebrew_resh, "hebrew_resh" },
+  { GDK_hebrew_shin, "hebrew_shin" },
+  { GDK_hebrew_taw, "hebrew_taw" },
+  { GDK_hebrew_taf, "hebrew_taf" },
+  { GDK_Thai_kokai, "Thai_kokai" },
+  { GDK_Thai_khokhai, "Thai_khokhai" },
+  { GDK_Thai_khokhuat, "Thai_khokhuat" },
+  { GDK_Thai_khokhwai, "Thai_khokhwai" },
+  { GDK_Thai_khokhon, "Thai_khokhon" },
+  { GDK_Thai_khorakhang, "Thai_khorakhang" },
+  { GDK_Thai_ngongu, "Thai_ngongu" },
+  { GDK_Thai_chochan, "Thai_chochan" },
+  { GDK_Thai_choching, "Thai_choching" },
+  { GDK_Thai_chochang, "Thai_chochang" },
+  { GDK_Thai_soso, "Thai_soso" },
+  { GDK_Thai_chochoe, "Thai_chochoe" },
+  { GDK_Thai_yoying, "Thai_yoying" },
+  { GDK_Thai_dochada, "Thai_dochada" },
+  { GDK_Thai_topatak, "Thai_topatak" },
+  { GDK_Thai_thothan, "Thai_thothan" },
+  { GDK_Thai_thonangmontho, "Thai_thonangmontho" },
+  { GDK_Thai_thophuthao, "Thai_thophuthao" },
+  { GDK_Thai_nonen, "Thai_nonen" },
+  { GDK_Thai_dodek, "Thai_dodek" },
+  { GDK_Thai_totao, "Thai_totao" },
+  { GDK_Thai_thothung, "Thai_thothung" },
+  { GDK_Thai_thothahan, "Thai_thothahan" },
+  { GDK_Thai_thothong, "Thai_thothong" },
+  { GDK_Thai_nonu, "Thai_nonu" },
+  { GDK_Thai_bobaimai, "Thai_bobaimai" },
+  { GDK_Thai_popla, "Thai_popla" },
+  { GDK_Thai_phophung, "Thai_phophung" },
+  { GDK_Thai_fofa, "Thai_fofa" },
+  { GDK_Thai_phophan, "Thai_phophan" },
+  { GDK_Thai_fofan, "Thai_fofan" },
+  { GDK_Thai_phosamphao, "Thai_phosamphao" },
+  { GDK_Thai_moma, "Thai_moma" },
+  { GDK_Thai_yoyak, "Thai_yoyak" },
+  { GDK_Thai_rorua, "Thai_rorua" },
+  { GDK_Thai_ru, "Thai_ru" },
+  { GDK_Thai_loling, "Thai_loling" },
+  { GDK_Thai_lu, "Thai_lu" },
+  { GDK_Thai_wowaen, "Thai_wowaen" },
+  { GDK_Thai_sosala, "Thai_sosala" },
+  { GDK_Thai_sorusi, "Thai_sorusi" },
+  { GDK_Thai_sosua, "Thai_sosua" },
+  { GDK_Thai_hohip, "Thai_hohip" },
+  { GDK_Thai_lochula, "Thai_lochula" },
+  { GDK_Thai_oang, "Thai_oang" },
+  { GDK_Thai_honokhuk, "Thai_honokhuk" },
+  { GDK_Thai_paiyannoi, "Thai_paiyannoi" },
+  { GDK_Thai_saraa, "Thai_saraa" },
+  { GDK_Thai_maihanakat, "Thai_maihanakat" },
+  { GDK_Thai_saraaa, "Thai_saraaa" },
+  { GDK_Thai_saraam, "Thai_saraam" },
+  { GDK_Thai_sarai, "Thai_sarai" },
+  { GDK_Thai_saraii, "Thai_saraii" },
+  { GDK_Thai_saraue, "Thai_saraue" },
+  { GDK_Thai_sarauee, "Thai_sarauee" },
+  { GDK_Thai_sarau, "Thai_sarau" },
+  { GDK_Thai_sarauu, "Thai_sarauu" },
+  { GDK_Thai_phinthu, "Thai_phinthu" },
+  { GDK_Thai_maihanakat_maitho, "Thai_maihanakat_maitho" },
+  { GDK_Thai_baht, "Thai_baht" },
+  { GDK_Thai_sarae, "Thai_sarae" },
+  { GDK_Thai_saraae, "Thai_saraae" },
+  { GDK_Thai_sarao, "Thai_sarao" },
+  { GDK_Thai_saraaimaimuan, "Thai_saraaimaimuan" },
+  { GDK_Thai_saraaimaimalai, "Thai_saraaimaimalai" },
+  { GDK_Thai_lakkhangyao, "Thai_lakkhangyao" },
+  { GDK_Thai_maiyamok, "Thai_maiyamok" },
+  { GDK_Thai_maitaikhu, "Thai_maitaikhu" },
+  { GDK_Thai_maiek, "Thai_maiek" },
+  { GDK_Thai_maitho, "Thai_maitho" },
+  { GDK_Thai_maitri, "Thai_maitri" },
+  { GDK_Thai_maichattawa, "Thai_maichattawa" },
+  { GDK_Thai_thanthakhat, "Thai_thanthakhat" },
+  { GDK_Thai_nikhahit, "Thai_nikhahit" },
+  { GDK_Thai_leksun, "Thai_leksun" },
+  { GDK_Thai_leknung, "Thai_leknung" },
+  { GDK_Thai_leksong, "Thai_leksong" },
+  { GDK_Thai_leksam, "Thai_leksam" },
+  { GDK_Thai_leksi, "Thai_leksi" },
+  { GDK_Thai_lekha, "Thai_lekha" },
+  { GDK_Thai_lekhok, "Thai_lekhok" },
+  { GDK_Thai_lekchet, "Thai_lekchet" },
+  { GDK_Thai_lekpaet, "Thai_lekpaet" },
+  { GDK_Thai_lekkao, "Thai_lekkao" },
+  { GDK_Hangul_Kiyeog, "Hangul_Kiyeog" },
+  { GDK_Hangul_SsangKiyeog, "Hangul_SsangKiyeog" },
+  { GDK_Hangul_KiyeogSios, "Hangul_KiyeogSios" },
+  { GDK_Hangul_Nieun, "Hangul_Nieun" },
+  { GDK_Hangul_NieunJieuj, "Hangul_NieunJieuj" },
+  { GDK_Hangul_NieunHieuh, "Hangul_NieunHieuh" },
+  { GDK_Hangul_Dikeud, "Hangul_Dikeud" },
+  { GDK_Hangul_SsangDikeud, "Hangul_SsangDikeud" },
+  { GDK_Hangul_Rieul, "Hangul_Rieul" },
+  { GDK_Hangul_RieulKiyeog, "Hangul_RieulKiyeog" },
+  { GDK_Hangul_RieulMieum, "Hangul_RieulMieum" },
+  { GDK_Hangul_RieulPieub, "Hangul_RieulPieub" },
+  { GDK_Hangul_RieulSios, "Hangul_RieulSios" },
+  { GDK_Hangul_RieulTieut, "Hangul_RieulTieut" },
+  { GDK_Hangul_RieulPhieuf, "Hangul_RieulPhieuf" },
+  { GDK_Hangul_RieulHieuh, "Hangul_RieulHieuh" },
+  { GDK_Hangul_Mieum, "Hangul_Mieum" },
+  { GDK_Hangul_Pieub, "Hangul_Pieub" },
+  { GDK_Hangul_SsangPieub, "Hangul_SsangPieub" },
+  { GDK_Hangul_PieubSios, "Hangul_PieubSios" },
+  { GDK_Hangul_Sios, "Hangul_Sios" },
+  { GDK_Hangul_SsangSios, "Hangul_SsangSios" },
+  { GDK_Hangul_Ieung, "Hangul_Ieung" },
+  { GDK_Hangul_Jieuj, "Hangul_Jieuj" },
+  { GDK_Hangul_SsangJieuj, "Hangul_SsangJieuj" },
+  { GDK_Hangul_Cieuc, "Hangul_Cieuc" },
+  { GDK_Hangul_Khieuq, "Hangul_Khieuq" },
+  { GDK_Hangul_Tieut, "Hangul_Tieut" },
+  { GDK_Hangul_Phieuf, "Hangul_Phieuf" },
+  { GDK_Hangul_Hieuh, "Hangul_Hieuh" },
+  { GDK_Hangul_A, "Hangul_A" },
+  { GDK_Hangul_AE, "Hangul_AE" },
+  { GDK_Hangul_YA, "Hangul_YA" },
+  { GDK_Hangul_YAE, "Hangul_YAE" },
+  { GDK_Hangul_EO, "Hangul_EO" },
+  { GDK_Hangul_E, "Hangul_E" },
+  { GDK_Hangul_YEO, "Hangul_YEO" },
+  { GDK_Hangul_YE, "Hangul_YE" },
+  { GDK_Hangul_O, "Hangul_O" },
+  { GDK_Hangul_WA, "Hangul_WA" },
+  { GDK_Hangul_WAE, "Hangul_WAE" },
+  { GDK_Hangul_OE, "Hangul_OE" },
+  { GDK_Hangul_YO, "Hangul_YO" },
+  { GDK_Hangul_U, "Hangul_U" },
+  { GDK_Hangul_WEO, "Hangul_WEO" },
+  { GDK_Hangul_WE, "Hangul_WE" },
+  { GDK_Hangul_WI, "Hangul_WI" },
+  { GDK_Hangul_YU, "Hangul_YU" },
+  { GDK_Hangul_EU, "Hangul_EU" },
+  { GDK_Hangul_YI, "Hangul_YI" },
+  { GDK_Hangul_I, "Hangul_I" },
+  { GDK_Hangul_J_Kiyeog, "Hangul_J_Kiyeog" },
+  { GDK_Hangul_J_SsangKiyeog, "Hangul_J_SsangKiyeog" },
+  { GDK_Hangul_J_KiyeogSios, "Hangul_J_KiyeogSios" },
+  { GDK_Hangul_J_Nieun, "Hangul_J_Nieun" },
+  { GDK_Hangul_J_NieunJieuj, "Hangul_J_NieunJieuj" },
+  { GDK_Hangul_J_NieunHieuh, "Hangul_J_NieunHieuh" },
+  { GDK_Hangul_J_Dikeud, "Hangul_J_Dikeud" },
+  { GDK_Hangul_J_Rieul, "Hangul_J_Rieul" },
+  { GDK_Hangul_J_RieulKiyeog, "Hangul_J_RieulKiyeog" },
+  { GDK_Hangul_J_RieulMieum, "Hangul_J_RieulMieum" },
+  { GDK_Hangul_J_RieulPieub, "Hangul_J_RieulPieub" },
+  { GDK_Hangul_J_RieulSios, "Hangul_J_RieulSios" },
+  { GDK_Hangul_J_RieulTieut, "Hangul_J_RieulTieut" },
+  { GDK_Hangul_J_RieulPhieuf, "Hangul_J_RieulPhieuf" },
+  { GDK_Hangul_J_RieulHieuh, "Hangul_J_RieulHieuh" },
+  { GDK_Hangul_J_Mieum, "Hangul_J_Mieum" },
+  { GDK_Hangul_J_Pieub, "Hangul_J_Pieub" },
+  { GDK_Hangul_J_PieubSios, "Hangul_J_PieubSios" },
+  { GDK_Hangul_J_Sios, "Hangul_J_Sios" },
+  { GDK_Hangul_J_SsangSios, "Hangul_J_SsangSios" },
+  { GDK_Hangul_J_Ieung, "Hangul_J_Ieung" },
+  { GDK_Hangul_J_Jieuj, "Hangul_J_Jieuj" },
+  { GDK_Hangul_J_Cieuc, "Hangul_J_Cieuc" },
+  { GDK_Hangul_J_Khieuq, "Hangul_J_Khieuq" },
+  { GDK_Hangul_J_Tieut, "Hangul_J_Tieut" },
+  { GDK_Hangul_J_Phieuf, "Hangul_J_Phieuf" },
+  { GDK_Hangul_J_Hieuh, "Hangul_J_Hieuh" },
+  { GDK_Hangul_RieulYeorinHieuh, "Hangul_RieulYeorinHieuh" },
+  { GDK_Hangul_SunkyeongeumMieum, "Hangul_SunkyeongeumMieum" },
+  { GDK_Hangul_SunkyeongeumPieub, "Hangul_SunkyeongeumPieub" },
+  { GDK_Hangul_PanSios, "Hangul_PanSios" },
+  { GDK_Hangul_KkogjiDalrinIeung, "Hangul_KkogjiDalrinIeung" },
+  { GDK_Hangul_SunkyeongeumPhieuf, "Hangul_SunkyeongeumPhieuf" },
+  { GDK_Hangul_YeorinHieuh, "Hangul_YeorinHieuh" },
+  { GDK_Hangul_AraeA, "Hangul_AraeA" },
+  { GDK_Hangul_AraeAE, "Hangul_AraeAE" },
+  { GDK_Hangul_J_PanSios, "Hangul_J_PanSios" },
+  { GDK_Hangul_J_KkogjiDalrinIeung, "Hangul_J_KkogjiDalrinIeung" },
+  { GDK_Hangul_J_YeorinHieuh, "Hangul_J_YeorinHieuh" },
+  { GDK_Korean_Won, "Korean_Won" },
+  { GDK_OE, "OE" },
+  { GDK_oe, "oe" },
+  { GDK_Ydiaeresis, "Ydiaeresis" },
+  { GDK_EcuSign, "EcuSign" },
+  { GDK_ColonSign, "ColonSign" },
+  { GDK_CruzeiroSign, "CruzeiroSign" },
+  { GDK_FFrancSign, "FFrancSign" },
+  { GDK_LiraSign, "LiraSign" },
+  { GDK_MillSign, "MillSign" },
+  { GDK_NairaSign, "NairaSign" },
+  { GDK_PesetaSign, "PesetaSign" },
+  { GDK_RupeeSign, "RupeeSign" },
+  { GDK_WonSign, "WonSign" },
+  { GDK_NewSheqelSign, "NewSheqelSign" },
+  { GDK_DongSign, "DongSign" },
+  { GDK_EuroSign, "EuroSign" },
+  { GDK_3270_Duplicate, "3270_Duplicate" },
+  { GDK_3270_FieldMark, "3270_FieldMark" },
+  { GDK_3270_Right2, "3270_Right2" },
+  { GDK_3270_Left2, "3270_Left2" },
+  { GDK_3270_BackTab, "3270_BackTab" },
+  { GDK_3270_EraseEOF, "3270_EraseEOF" },
+  { GDK_3270_EraseInput, "3270_EraseInput" },
+  { GDK_3270_Reset, "3270_Reset" },
+  { GDK_3270_Quit, "3270_Quit" },
+  { GDK_3270_PA1, "3270_PA1" },
+  { GDK_3270_PA2, "3270_PA2" },
+  { GDK_3270_PA3, "3270_PA3" },
+  { GDK_3270_Test, "3270_Test" },
+  { GDK_3270_Attn, "3270_Attn" },
+  { GDK_3270_CursorBlink, "3270_CursorBlink" },
+  { GDK_3270_AltCursor, "3270_AltCursor" },
+  { GDK_3270_KeyClick, "3270_KeyClick" },
+  { GDK_3270_Jump, "3270_Jump" },
+  { GDK_3270_Ident, "3270_Ident" },
+  { GDK_3270_Rule, "3270_Rule" },
+  { GDK_3270_Copy, "3270_Copy" },
+  { GDK_3270_Play, "3270_Play" },
+  { GDK_3270_Setup, "3270_Setup" },
+  { GDK_3270_Record, "3270_Record" },
+  { GDK_3270_ChangeScreen, "3270_ChangeScreen" },
+  { GDK_3270_DeleteWord, "3270_DeleteWord" },
+  { GDK_3270_ExSelect, "3270_ExSelect" },
+  { GDK_3270_CursorSelect, "3270_CursorSelect" },
+  { GDK_3270_PrintScreen, "3270_PrintScreen" },
+  { GDK_3270_Enter, "3270_Enter" },
+  { GDK_ISO_Lock, "ISO_Lock" },
+  { GDK_ISO_Level2_Latch, "ISO_Level2_Latch" },
+  { GDK_ISO_Level3_Shift, "ISO_Level3_Shift" },
+  { GDK_ISO_Level3_Latch, "ISO_Level3_Latch" },
+  { GDK_ISO_Level3_Lock, "ISO_Level3_Lock" },
+  { GDK_ISO_Group_Latch, "ISO_Group_Latch" },
+  { GDK_ISO_Group_Lock, "ISO_Group_Lock" },
+  { GDK_ISO_Next_Group, "ISO_Next_Group" },
+  { GDK_ISO_Next_Group_Lock, "ISO_Next_Group_Lock" },
+  { GDK_ISO_Prev_Group, "ISO_Prev_Group" },
+  { GDK_ISO_Prev_Group_Lock, "ISO_Prev_Group_Lock" },
+  { GDK_ISO_First_Group, "ISO_First_Group" },
+  { GDK_ISO_First_Group_Lock, "ISO_First_Group_Lock" },
+  { GDK_ISO_Last_Group, "ISO_Last_Group" },
+  { GDK_ISO_Last_Group_Lock, "ISO_Last_Group_Lock" },
+  { GDK_ISO_Left_Tab, "ISO_Left_Tab" },
+  { GDK_ISO_Move_Line_Up, "ISO_Move_Line_Up" },
+  { GDK_ISO_Move_Line_Down, "ISO_Move_Line_Down" },
+  { GDK_ISO_Partial_Line_Up, "ISO_Partial_Line_Up" },
+  { GDK_ISO_Partial_Line_Down, "ISO_Partial_Line_Down" },
+  { GDK_ISO_Partial_Space_Left, "ISO_Partial_Space_Left" },
+  { GDK_ISO_Partial_Space_Right, "ISO_Partial_Space_Right" },
+  { GDK_ISO_Set_Margin_Left, "ISO_Set_Margin_Left" },
+  { GDK_ISO_Set_Margin_Right, "ISO_Set_Margin_Right" },
+  { GDK_ISO_Release_Margin_Left, "ISO_Release_Margin_Left" },
+  { GDK_ISO_Release_Margin_Right, "ISO_Release_Margin_Right" },
+  { GDK_ISO_Release_Both_Margins, "ISO_Release_Both_Margins" },
+  { GDK_ISO_Fast_Cursor_Left, "ISO_Fast_Cursor_Left" },
+  { GDK_ISO_Fast_Cursor_Right, "ISO_Fast_Cursor_Right" },
+  { GDK_ISO_Fast_Cursor_Up, "ISO_Fast_Cursor_Up" },
+  { GDK_ISO_Fast_Cursor_Down, "ISO_Fast_Cursor_Down" },
+  { GDK_ISO_Continuous_Underline, "ISO_Continuous_Underline" },
+  { GDK_ISO_Discontinuous_Underline, "ISO_Discontinuous_Underline" },
+  { GDK_ISO_Emphasize, "ISO_Emphasize" },
+  { GDK_ISO_Center_Object, "ISO_Center_Object" },
+  { GDK_ISO_Enter, "ISO_Enter" },
+  { GDK_dead_grave, "dead_grave" },
+  { GDK_dead_acute, "dead_acute" },
+  { GDK_dead_circumflex, "dead_circumflex" },
+  { GDK_dead_tilde, "dead_tilde" },
+  { GDK_dead_macron, "dead_macron" },
+  { GDK_dead_breve, "dead_breve" },
+  { GDK_dead_abovedot, "dead_abovedot" },
+  { GDK_dead_diaeresis, "dead_diaeresis" },
+  { GDK_dead_abovering, "dead_abovering" },
+  { GDK_dead_doubleacute, "dead_doubleacute" },
+  { GDK_dead_caron, "dead_caron" },
+  { GDK_dead_cedilla, "dead_cedilla" },
+  { GDK_dead_ogonek, "dead_ogonek" },
+  { GDK_dead_iota, "dead_iota" },
+  { GDK_dead_voiced_sound, "dead_voiced_sound" },
+  { GDK_dead_semivoiced_sound, "dead_semivoiced_sound" },
+  { GDK_dead_belowdot, "dead_belowdot" },
+  { GDK_AccessX_Enable, "AccessX_Enable" },
+  { GDK_AccessX_Feedback_Enable, "AccessX_Feedback_Enable" },
+  { GDK_RepeatKeys_Enable, "RepeatKeys_Enable" },
+  { GDK_SlowKeys_Enable, "SlowKeys_Enable" },
+  { GDK_BounceKeys_Enable, "BounceKeys_Enable" },
+  { GDK_StickyKeys_Enable, "StickyKeys_Enable" },
+  { GDK_MouseKeys_Enable, "MouseKeys_Enable" },
+  { GDK_MouseKeys_Accel_Enable, "MouseKeys_Accel_Enable" },
+  { GDK_Overlay1_Enable, "Overlay1_Enable" },
+  { GDK_Overlay2_Enable, "Overlay2_Enable" },
+  { GDK_AudibleBell_Enable, "AudibleBell_Enable" },
+  { GDK_First_Virtual_Screen, "First_Virtual_Screen" },
+  { GDK_Prev_Virtual_Screen, "Prev_Virtual_Screen" },
+  { GDK_Next_Virtual_Screen, "Next_Virtual_Screen" },
+  { GDK_Last_Virtual_Screen, "Last_Virtual_Screen" },
+  { GDK_Terminate_Server, "Terminate_Server" },
+  { GDK_Pointer_Left, "Pointer_Left" },
+  { GDK_Pointer_Right, "Pointer_Right" },
+  { GDK_Pointer_Up, "Pointer_Up" },
+  { GDK_Pointer_Down, "Pointer_Down" },
+  { GDK_Pointer_UpLeft, "Pointer_UpLeft" },
+  { GDK_Pointer_UpRight, "Pointer_UpRight" },
+  { GDK_Pointer_DownLeft, "Pointer_DownLeft" },
+  { GDK_Pointer_DownRight, "Pointer_DownRight" },
+  { GDK_Pointer_Button_Dflt, "Pointer_Button_Dflt" },
+  { GDK_Pointer_Button1, "Pointer_Button1" },
+  { GDK_Pointer_Button2, "Pointer_Button2" },
+  { GDK_Pointer_Button3, "Pointer_Button3" },
+  { GDK_Pointer_Button4, "Pointer_Button4" },
+  { GDK_Pointer_Button5, "Pointer_Button5" },
+  { GDK_Pointer_DblClick_Dflt, "Pointer_DblClick_Dflt" },
+  { GDK_Pointer_DblClick1, "Pointer_DblClick1" },
+  { GDK_Pointer_DblClick2, "Pointer_DblClick2" },
+  { GDK_Pointer_DblClick3, "Pointer_DblClick3" },
+  { GDK_Pointer_DblClick4, "Pointer_DblClick4" },
+  { GDK_Pointer_DblClick5, "Pointer_DblClick5" },
+  { GDK_Pointer_Drag_Dflt, "Pointer_Drag_Dflt" },
+  { GDK_Pointer_Drag1, "Pointer_Drag1" },
+  { GDK_Pointer_Drag2, "Pointer_Drag2" },
+  { GDK_Pointer_Drag3, "Pointer_Drag3" },
+  { GDK_Pointer_Drag4, "Pointer_Drag4" },
+  { GDK_Pointer_EnableKeys, "Pointer_EnableKeys" },
+  { GDK_Pointer_Accelerate, "Pointer_Accelerate" },
+  { GDK_Pointer_DfltBtnNext, "Pointer_DfltBtnNext" },
+  { GDK_Pointer_DfltBtnPrev, "Pointer_DfltBtnPrev" },
+  { GDK_Pointer_Drag5, "Pointer_Drag5" },
+  { GDK_BackSpace, "BackSpace" },
+  { GDK_Tab, "Tab" },
+  { GDK_Linefeed, "Linefeed" },
+  { GDK_Clear, "Clear" },
+  { GDK_Return, "Return" },
+  { GDK_Pause, "Pause" },
+  { GDK_Scroll_Lock, "Scroll_Lock" },
+  { GDK_Sys_Req, "Sys_Req" },
+  { GDK_Escape, "Escape" },
+  { GDK_Multi_key, "Multi_key" },
+  { GDK_Kanji, "Kanji" },
+  { GDK_Muhenkan, "Muhenkan" },
+  { GDK_Henkan_Mode, "Henkan_Mode" },
+  { GDK_Henkan, "Henkan" },
+  { GDK_Romaji, "Romaji" },
+  { GDK_Hiragana, "Hiragana" },
+  { GDK_Katakana, "Katakana" },
+  { GDK_Hiragana_Katakana, "Hiragana_Katakana" },
+  { GDK_Zenkaku, "Zenkaku" },
+  { GDK_Hankaku, "Hankaku" },
+  { GDK_Zenkaku_Hankaku, "Zenkaku_Hankaku" },
+  { GDK_Touroku, "Touroku" },
+  { GDK_Massyo, "Massyo" },
+  { GDK_Kana_Lock, "Kana_Lock" },
+  { GDK_Kana_Shift, "Kana_Shift" },
+  { GDK_Eisu_Shift, "Eisu_Shift" },
+  { GDK_Eisu_toggle, "Eisu_toggle" },
+  { GDK_Hangul, "Hangul" },
+  { GDK_Hangul_Start, "Hangul_Start" },
+  { GDK_Hangul_End, "Hangul_End" },
+  { GDK_Hangul_Hanja, "Hangul_Hanja" },
+  { GDK_Hangul_Jamo, "Hangul_Jamo" },
+  { GDK_Hangul_Romaja, "Hangul_Romaja" },
+  { GDK_Codeinput, "Codeinput" },
+  { GDK_Kanji_Bangou, "Kanji_Bangou" },
+  { GDK_Hangul_Codeinput, "Hangul_Codeinput" },
+  { GDK_Hangul_Jeonja, "Hangul_Jeonja" },
+  { GDK_Hangul_Banja, "Hangul_Banja" },
+  { GDK_Hangul_PreHanja, "Hangul_PreHanja" },
+  { GDK_Hangul_PostHanja, "Hangul_PostHanja" },
+  { GDK_SingleCandidate, "SingleCandidate" },
+  { GDK_Hangul_SingleCandidate, "Hangul_SingleCandidate" },
+  { GDK_MultipleCandidate, "MultipleCandidate" },
+  { GDK_Zen_Koho, "Zen_Koho" },
+  { GDK_Hangul_MultipleCandidate, "Hangul_MultipleCandidate" },
+  { GDK_PreviousCandidate, "PreviousCandidate" },
+  { GDK_Mae_Koho, "Mae_Koho" },
+  { GDK_Hangul_PreviousCandidate, "Hangul_PreviousCandidate" },
+  { GDK_Hangul_Special, "Hangul_Special" },
+  { GDK_Home, "Home" },
+  { GDK_Left, "Left" },
+  { GDK_Up, "Up" },
+  { GDK_Right, "Right" },
+  { GDK_Down, "Down" },
+  { GDK_Prior, "Prior" },
+  { GDK_Page_Up, "Page_Up" },
+  { GDK_Next, "Next" },
+  { GDK_Page_Down, "Page_Down" },
+  { GDK_End, "End" },
+  { GDK_Begin, "Begin" },
+  { GDK_Select, "Select" },
+  { GDK_Print, "Print" },
+  { GDK_Execute, "Execute" },
+  { GDK_Insert, "Insert" },
+  { GDK_Undo, "Undo" },
+  { GDK_Redo, "Redo" },
+  { GDK_Menu, "Menu" },
+  { GDK_Find, "Find" },
+  { GDK_Cancel, "Cancel" },
+  { GDK_Help, "Help" },
+  { GDK_Break, "Break" },
+  { GDK_Mode_switch, "Mode_switch" },
+  { GDK_script_switch, "script_switch" },
+  { GDK_ISO_Group_Shift, "ISO_Group_Shift" },
+  { GDK_kana_switch, "kana_switch" },
+  { GDK_Arabic_switch, "Arabic_switch" },
+  { GDK_Greek_switch, "Greek_switch" },
+  { GDK_Hebrew_switch, "Hebrew_switch" },
+  { GDK_Hangul_switch, "Hangul_switch" },
+  { GDK_Num_Lock, "Num_Lock" },
+  { GDK_KP_Space, "KP_Space" },
+  { GDK_KP_Tab, "KP_Tab" },
+  { GDK_KP_Enter, "KP_Enter" },
+  { GDK_KP_F1, "KP_F1" },
+  { GDK_KP_F2, "KP_F2" },
+  { GDK_KP_F3, "KP_F3" },
+  { GDK_KP_F4, "KP_F4" },
+  { GDK_KP_Home, "KP_Home" },
+  { GDK_KP_Left, "KP_Left" },
+  { GDK_KP_Up, "KP_Up" },
+  { GDK_KP_Right, "KP_Right" },
+  { GDK_KP_Down, "KP_Down" },
+  { GDK_KP_Prior, "KP_Prior" },
+  { GDK_KP_Page_Up, "KP_Page_Up" },
+  { GDK_KP_Next, "KP_Next" },
+  { GDK_KP_Page_Down, "KP_Page_Down" },
+  { GDK_KP_End, "KP_End" },
+  { GDK_KP_Begin, "KP_Begin" },
+  { GDK_KP_Insert, "KP_Insert" },
+  { GDK_KP_Delete, "KP_Delete" },
+  { GDK_KP_Multiply, "KP_Multiply" },
+  { GDK_KP_Add, "KP_Add" },
+  { GDK_KP_Separator, "KP_Separator" },
+  { GDK_KP_Subtract, "KP_Subtract" },
+  { GDK_KP_Decimal, "KP_Decimal" },
+  { GDK_KP_Divide, "KP_Divide" },
+  { GDK_KP_0, "KP_0" },
+  { GDK_KP_1, "KP_1" },
+  { GDK_KP_2, "KP_2" },
+  { GDK_KP_3, "KP_3" },
+  { GDK_KP_4, "KP_4" },
+  { GDK_KP_5, "KP_5" },
+  { GDK_KP_6, "KP_6" },
+  { GDK_KP_7, "KP_7" },
+  { GDK_KP_8, "KP_8" },
+  { GDK_KP_9, "KP_9" },
+  { GDK_KP_Equal, "KP_Equal" },
+  { GDK_F1, "F1" },
+  { GDK_F2, "F2" },
+  { GDK_F3, "F3" },
+  { GDK_F4, "F4" },
+  { GDK_F5, "F5" },
+  { GDK_F6, "F6" },
+  { GDK_F7, "F7" },
+  { GDK_F8, "F8" },
+  { GDK_F9, "F9" },
+  { GDK_F10, "F10" },
+  { GDK_F11, "F11" },
+  { GDK_F12, "F12" },
+  { GDK_F13, "F13" },
+  { GDK_F14, "F14" },
+  { GDK_F15, "F15" },
+  { GDK_F16, "F16" },
+  { GDK_F17, "F17" },
+  { GDK_F18, "F18" },
+  { GDK_F19, "F19" },
+  { GDK_F20, "F20" },
+  { GDK_F21, "F21" },
+  { GDK_F22, "F22" },
+  { GDK_F23, "F23" },
+  { GDK_F24, "F24" },
+  { GDK_F25, "F25" },
+  { GDK_F26, "F26" },
+  { GDK_F27, "F27" },
+  { GDK_F28, "F28" },
+  { GDK_F29, "F29" },
+  { GDK_F30, "F30" },
+  { GDK_F31, "F31" },
+  { GDK_F32, "F32" },
+  { GDK_F33, "F33" },
+  { GDK_F34, "F34" },
+  { GDK_F35, "F35" },
+  { GDK_Shift_L, "Shift_L" },
+  { GDK_Shift_R, "Shift_R" },
+  { GDK_Control_L, "Control_L" },
+  { GDK_Control_R, "Control_R" },
+  { GDK_Caps_Lock, "Caps_Lock" },
+  { GDK_Shift_Lock, "Shift_Lock" },
+  { GDK_Meta_L, "Meta_L" },
+  { GDK_Meta_R, "Meta_R" },
+  { GDK_Alt_L, "Alt_L" },
+  { GDK_Alt_R, "Alt_R" },
+  { GDK_Super_L, "Super_L" },
+  { GDK_Super_R, "Super_R" },
+  { GDK_Hyper_L, "Hyper_L" },
+  { GDK_Hyper_R, "Hyper_R" },
+  { GDK_Delete, "Delete" },
+  { GDK_VoidSymbol, "VoidSymbol" }
+};
+
+#define GDK_NUM_KEYS (G_N_ELEMENTS (gdk_keys_by_keyval))
+
+
+static gint
+gdk_keys_keyval_compare (const void *pkey,
+                         const void *pbase)
+{
+  return (*(gint *) pkey) - ((struct gdk_key *) pbase)->keyval;
+}
+
+gchar *
+gdk_keyval_name (guint keyval)
+{
+  struct gdk_key *found;
+
+  /* these keyvals have two entries (PageUp/Prior | PageDown/Next) */
+  switch (keyval)
+    {
+    case GDK_Page_Up:
+      return "Page_Up";
+    case GDK_Page_Down:
+      return "Page_Down";
+    case GDK_KP_Page_Up:
+      return "KP_Page_Up";
+    case GDK_KP_Page_Down:
+      return "KP_Page_Down";
+    }
+
+  found = bsearch (&keyval, gdk_keys_by_keyval,
+                   GDK_NUM_KEYS, sizeof (struct gdk_key),
+                   gdk_keys_keyval_compare);
+
+  if (found)
+    return (gchar *) found->name;
+  else
+    return NULL;
+}
+
+static gint
+gdk_key_compare_by_name (const void *a,
+                         const void *b)
+{
+  return strcmp (((const struct gdk_key *) a)->name,
+                 ((const struct gdk_key *) b)->name);
+}
+
+static gint
+gdk_keys_name_compare (const void *pkey,
+                       const void *pbase)
+{
+  return strcmp ((const char *) pkey,
+                 ((const struct gdk_key *) pbase)->name);
+}
+
+guint
+gdk_keyval_from_name (const gchar *keyval_name)
+{
+  struct gdk_key *found;
+
+  g_return_val_if_fail (keyval_name != NULL, 0);
+
+  if (gdk_keys_by_name == NULL)
+    {
+      gdk_keys_by_name = g_new (struct gdk_key, GDK_NUM_KEYS);
+      
+      memcpy (gdk_keys_by_name, gdk_keys_by_keyval,
+              GDK_NUM_KEYS * sizeof (struct gdk_key));
+      
+      qsort (gdk_keys_by_name, GDK_NUM_KEYS, sizeof (struct gdk_key),
+             gdk_key_compare_by_name);
+    }
+  
+  found = bsearch (keyval_name, gdk_keys_by_name,
+                   GDK_NUM_KEYS, sizeof (struct gdk_key),
+                   gdk_keys_name_compare);
+  
+  if (found)
+    return found->keyval;
+  else
+    return GDK_VoidSymbol;
+}
+
+static void
+gdk_directfb_convert_modifiers (DFBInputDeviceModifierMask dfbmod,
+		DFBInputDeviceLockState    dfblock)
+{
+	if (dfbmod & DIMM_ALT)
+		_gdk_directfb_modifiers |= GDK_MOD1_MASK;
+	else
+		_gdk_directfb_modifiers &= ~GDK_MOD1_MASK;
+
+	if (dfbmod & DIMM_ALTGR)
+		_gdk_directfb_modifiers |= GDK_MOD2_MASK;
+	else
+		_gdk_directfb_modifiers &= ~GDK_MOD2_MASK;
+
+	if (dfbmod & DIMM_CONTROL)
+		_gdk_directfb_modifiers |= GDK_CONTROL_MASK;
+	else
+		_gdk_directfb_modifiers &= ~GDK_CONTROL_MASK;
+
+	if (dfbmod & DIMM_SHIFT)
+		_gdk_directfb_modifiers |= GDK_SHIFT_MASK;
+	else
+		_gdk_directfb_modifiers &= ~GDK_SHIFT_MASK;
+
+	if (dfblock & DILS_CAPS)
+		_gdk_directfb_modifiers |= GDK_LOCK_MASK;
+	else
+		_gdk_directfb_modifiers &= ~GDK_LOCK_MASK;
+}
+
+static guint
+gdk_directfb_translate_key (DFBInputDeviceKeyIdentifier key_id,
+		DFBInputDeviceKeySymbol     key_symbol)
+{
+	guint keyval = GDK_VoidSymbol;
+
+	/* special case numpad */
+	if (key_id >= DIKI_KP_DIV && key_id <= DIKI_KP_9)
+	{
+		switch (key_symbol)
+		{
+			case DIKS_SLASH:         keyval = GDK_KP_Divide;    break;
+			case DIKS_ASTERISK:      keyval = GDK_KP_Multiply;  break;
+			case DIKS_PLUS_SIGN:     keyval = GDK_KP_Add;       break;
+			case DIKS_MINUS_SIGN:    keyval = GDK_KP_Subtract;  break;
+			case DIKS_ENTER:         keyval = GDK_KP_Enter;     break;
+			case DIKS_SPACE:         keyval = GDK_KP_Space;     break;
+			case DIKS_TAB:           keyval = GDK_KP_Tab;       break;
+			case DIKS_EQUALS_SIGN:   keyval = GDK_KP_Equal;     break;
+			case DIKS_COMMA:
+			case DIKS_PERIOD:        keyval = GDK_KP_Decimal;   break;
+			case DIKS_HOME:          keyval = GDK_KP_Home;      break;
+			case DIKS_END:           keyval = GDK_KP_End;       break;
+			case DIKS_PAGE_UP:       keyval = GDK_KP_Page_Up;   break;
+			case DIKS_PAGE_DOWN:     keyval = GDK_KP_Page_Down; break;
+			case DIKS_CURSOR_LEFT:   keyval = GDK_KP_Left;      break;
+			case DIKS_CURSOR_RIGHT:  keyval = GDK_KP_Right;     break;
+			case DIKS_CURSOR_UP:     keyval = GDK_KP_Up;        break;
+			case DIKS_CURSOR_DOWN:   keyval = GDK_KP_Down;      break;
+			case DIKS_BEGIN:         keyval = GDK_KP_Begin;     break;
+
+			case DIKS_0 ... DIKS_9:
+						 keyval = GDK_KP_0 + key_symbol - DIKS_0;
+						 break;
+			case DIKS_F1 ... DIKS_F4:
+						 keyval = GDK_KP_F1 + key_symbol - DIKS_F1;
+						 break;
+
+			default:
+						 break;
+		}
+	}
+	else
+	{
+		switch (DFB_KEY_TYPE (key_symbol))
+		{
+			case DIKT_UNICODE:
+				switch (key_symbol)
+				{
+					case DIKS_NULL:       keyval = GDK_VoidSymbol; break;
+					case DIKS_BACKSPACE:  keyval = GDK_BackSpace;  break;
+					case DIKS_TAB:        keyval = GDK_Tab;        break;
+					case DIKS_RETURN:     keyval = GDK_Return;     break;
+					case DIKS_CANCEL:     keyval = GDK_Cancel;     break;
+					case DIKS_ESCAPE:     keyval = GDK_Escape;     break;
+					case DIKS_SPACE:      keyval = GDK_space;      break;
+					case DIKS_DELETE:     keyval = GDK_Delete;     break;
+
+					default:
+							      keyval = gdk_unicode_to_keyval (key_symbol);
+							      if (keyval & 0x01000000)
+								      keyval = GDK_VoidSymbol;
+				}
+				break;
+
+			case DIKT_SPECIAL:
+				switch (key_symbol)
+				{
+					case DIKS_CURSOR_LEFT:   keyval = GDK_Left;      break;
+					case DIKS_CURSOR_RIGHT:  keyval = GDK_Right;     break;
+					case DIKS_CURSOR_UP:     keyval = GDK_Up;        break;
+					case DIKS_CURSOR_DOWN:   keyval = GDK_Down;      break;
+					case DIKS_INSERT:        keyval = GDK_Insert;    break;
+					case DIKS_HOME:          keyval = GDK_Home;      break;
+					case DIKS_END:           keyval = GDK_End;       break;
+					case DIKS_PAGE_UP:       keyval = GDK_Page_Up;   break;
+					case DIKS_PAGE_DOWN:     keyval = GDK_Page_Down; break;
+					case DIKS_PRINT:         keyval = GDK_Print;     break;
+					case DIKS_PAUSE:         keyval = GDK_Pause;     break;
+					case DIKS_SELECT:        keyval = GDK_Select;    break;
+					case DIKS_CLEAR:         keyval = GDK_Clear;     break;
+					case DIKS_MENU:          keyval = GDK_Menu;      break;
+					case DIKS_HELP:          keyval = GDK_Help;      break;
+					case DIKS_NEXT:          keyval = GDK_Next;      break;
+					case DIKS_BEGIN:         keyval = GDK_Begin;     break;
+					case DIKS_BREAK:         keyval = GDK_Break;     break;
+					default:
+								 break;
+				}
+				break;
+
+			case DIKT_FUNCTION:
+				keyval = GDK_F1 + key_symbol - DIKS_F1;
+				if (keyval > GDK_F35)
+					keyval = GDK_VoidSymbol;
+				break;
+
+			case DIKT_MODIFIER:
+				switch (key_id)
+				{
+					case DIKI_SHIFT_L:    keyval = GDK_Shift_L;     break;
+					case DIKI_SHIFT_R:    keyval = GDK_Shift_R;     break;
+					case DIKI_CONTROL_L:  keyval = GDK_Control_L;   break;
+					case DIKI_CONTROL_R:  keyval = GDK_Control_R;   break;
+					case DIKI_ALT_L:      keyval = GDK_Alt_L;       break;
+					case DIKI_ALT_R:      keyval = GDK_Alt_R;       break;
+					case DIKI_META_L:     keyval = GDK_Meta_L;      break;
+					case DIKI_META_R:     keyval = GDK_Meta_R;      break;
+					case DIKI_SUPER_L:    keyval = GDK_Super_L;     break;
+					case DIKI_SUPER_R:    keyval = GDK_Super_R;     break;
+					case DIKI_HYPER_L:    keyval = GDK_Hyper_L;     break;
+					case DIKI_HYPER_R:    keyval = GDK_Hyper_R;     break;
+					default:
+							      break;
+				}
+				break;
+
+			case DIKT_LOCK:
+				switch (key_symbol)
+				{
+					case DIKS_CAPS_LOCK:    keyval = GDK_Caps_Lock;   break;
+					case DIKS_NUM_LOCK:     keyval = GDK_Num_Lock;    break;
+					case DIKS_SCROLL_LOCK:  keyval = GDK_Scroll_Lock; break;
+					default:
+								break;
+				}
+				break;
+
+			case DIKT_DEAD:
+				switch (key_symbol)
+				{
+					case DIKS_DEAD_ABOVEDOT:     keyval = GDK_dead_abovedot;     break;
+					case DIKS_DEAD_ABOVERING:    keyval = GDK_dead_abovering;    break;
+					case DIKS_DEAD_ACUTE:        keyval = GDK_dead_acute;        break;
+					case DIKS_DEAD_BREVE:        keyval = GDK_dead_breve;        break;
+					case DIKS_DEAD_CARON:        keyval = GDK_dead_caron;        break;
+					case DIKS_DEAD_CEDILLA:      keyval = GDK_dead_cedilla;      break;
+					case DIKS_DEAD_CIRCUMFLEX:   keyval = GDK_dead_circumflex;   break;
+					case DIKS_DEAD_DIAERESIS:    keyval = GDK_dead_diaeresis;    break;
+					case DIKS_DEAD_DOUBLEACUTE:  keyval = GDK_dead_doubleacute;  break;
+					case DIKS_DEAD_GRAVE:        keyval = GDK_dead_grave;        break;
+					case DIKS_DEAD_IOTA:         keyval = GDK_dead_iota;         break;
+					case DIKS_DEAD_MACRON:       keyval = GDK_dead_macron;       break;
+					case DIKS_DEAD_OGONEK:       keyval = GDK_dead_ogonek;       break;
+					case DIKS_DEAD_SEMIVOICED_SOUND:
+								     keyval = GDK_dead_semivoiced_sound;                        break;
+					case DIKS_DEAD_TILDE:        keyval = GDK_dead_tilde;        break;
+					case DIKS_DEAD_VOICED_SOUND: keyval = GDK_dead_voiced_sound; break;
+					default:
+								     break;
+				}
+				break;
+
+			case DIKT_CUSTOM:
+				break;
+		}
+	}
+
+	return keyval;
+}
+
+	void
+_gdk_directfb_keyboard_init (void)
+{
+	DFBInputDeviceDescription desc;
+	gint i, n, length;
+	IDirectFBInputDevice   *keyboard=_gdk_display->keyboard;
+
+	if (!keyboard)
+		return;
+
+	keyboard->GetDescription (keyboard, &desc);
+	_gdk_display->keymap=g_object_new (gdk_keymap_get_type (), NULL);
+
+	if (desc.min_keycode < 0 || desc.max_keycode < desc.min_keycode)
+		return;
+
+	directfb_min_keycode = desc.min_keycode;
+	directfb_max_keycode = desc.max_keycode;
+
+	length = directfb_max_keycode - desc.min_keycode + 1;
+
+	g_assert (directfb_keymap == NULL);
+
+	directfb_keymap = g_new0 (guint, 4 * length);
+
+	for (i = 0; i < length; i++)
+	{
+		DFBInputDeviceKeymapEntry  entry;
+
+		if (keyboard->GetKeymapEntry (keyboard,
+					i + desc.min_keycode, &entry) != DFB_OK)
+			continue;
+		for (n = 0; n < 4; n++) {
+			directfb_keymap[i * 4 + n] = 
+				gdk_directfb_translate_key (entry.identifier, entry.symbols[n]);
+		}
+	}
+}
+
+	void
+_gdk_directfb_keyboard_exit (void)
+{
+	if (!directfb_keymap)
+		return;
+
+	g_free (directfb_keymap);
+	g_free(_gdk_display->keymap);
+	_gdk_display->keymap = NULL;
+	directfb_keymap = NULL;
+}
+
+void
+gdk_directfb_translate_key_event (DFBWindowEvent *dfb_event,
+		GdkEventKey    *event)
+{
+	gint  len;
+	gchar buf[6];
+
+	g_return_if_fail (dfb_event != NULL);
+	g_return_if_fail (event != NULL);
+
+	gdk_directfb_convert_modifiers (dfb_event->modifiers, dfb_event->locks);
+
+	event->state            = _gdk_directfb_modifiers;
+	event->group            = (dfb_event->modifiers & DIMM_ALTGR) ? 1 : 0;
+	event->hardware_keycode = dfb_event->key_code;
+	event->keyval           = gdk_directfb_translate_key (dfb_event->key_id,
+			dfb_event->key_symbol);
+	/* If the device driver didn't send a key_code (happens with remote
+	   controls), we try to find a suitable key_code by looking at the
+	   default keymap. */
+	if (dfb_event->key_code == -1 && directfb_keymap)
+	{
+		gint i;
+
+		for (i = directfb_min_keycode; i <= directfb_max_keycode; i++)
+		{
+			if (directfb_keymap[(i - directfb_min_keycode) * 4] == event->keyval)
+			{
+				event->hardware_keycode = i;
+				break;
+			}
+		}
+	} 
+
+	len = g_unichar_to_utf8 (dfb_event->key_symbol, buf);
+
+	event->string = g_strndup (buf, len);
+	event->length = len;
+}
+
+/**
+ * gdk_keymap_get_entries_for_keycode:
+ * @keymap: a #GdkKeymap or %NULL to use the default keymap
+ * @hardware_keycode: a keycode
+ * @keys: return location for array of #GdkKeymapKey, or NULL
+ * @keyvals: return location for array of keyvals, or NULL
+ * @n_entries: length of @keys and @keyvals
+ *
+ * Returns the keyvals bound to @hardware_keycode.
+ * The Nth #GdkKeymapKey in @keys is bound to the Nth
+ * keyval in @keyvals. Free the returned arrays with g_free().
+ * When a keycode is pressed by the user, the keyval from
+ * this list of entries is selected by considering the effective
+ * keyboard group and level. See gdk_keymap_translate_keyboard_state().
+ *
+ * Returns: %TRUE if there were any entries
+ **/
+gboolean
+gdk_keymap_get_entries_for_keycode (GdkKeymap     *keymap,
+		guint          hardware_keycode,
+		GdkKeymapKey **keys,
+		guint        **keyvals,
+		gint          *n_entries)
+{
+	gint num = 0;
+	gint i, j;
+	gint index;
+
+	index = (hardware_keycode - directfb_min_keycode) * 4;
+
+	if (directfb_keymap && (hardware_keycode >= directfb_min_keycode && 
+				hardware_keycode <= directfb_max_keycode))
+	{
+		for (i = 0; i < 4; i++)
+			if (directfb_keymap[index + i] != GDK_VoidSymbol)
+				num++;
+	}
+
+	if (keys)
+	{
+		*keys = g_new (GdkKeymapKey, num);
+
+		for (i = 0, j = 0; num > 0 && i < 4; i++)
+			if (directfb_keymap[index + i] != GDK_VoidSymbol)
+			{
+				(*keys)[j].keycode = hardware_keycode;
+				(*keys)[j].level   = j % 2;
+				(*keys)[j].group   = j > DIKSI_BASE_SHIFT ? 1 : 0;
+				j++;
+			}
+	}
+	if (keyvals)
+	{
+		*keyvals = g_new (guint, num);
+
+		for (i = 0, j = 0; num > 0 && i < 4; i++)
+			if (directfb_keymap[index + i] != GDK_VoidSymbol)
+			{
+				(*keyvals)[j] = directfb_keymap[index + i];
+				j++;
+			}
+	}
+
+	if (n_entries)
+		*n_entries = num;
+
+	return (num > 0);
+}
+
+static inline void
+append_keymap_key (GArray *array,
+		guint   keycode,
+		gint    group,
+		gint    level)
+{
+	GdkKeymapKey key = { keycode, group, level };
+
+	g_array_append_val (array, key);
+}
+
+/**
+ * gdk_keymap_get_entries_for_keyval:
+ * @keymap: a #GdkKeymap, or %NULL to use the default keymap
+ * @keyval: a keyval, such as %GDK_a, %GDK_Up, %GDK_Return, etc.
+ * @keys: return location for an array of #GdkKeymapKey
+ * @n_keys: return location for number of elements in returned array
+ * 
+ * Obtains a list of keycode/group/level combinations that will
+ * generate @keyval. Groups and levels are two kinds of keyboard mode;
+ * in general, the level determines whether the top or bottom symbol
+ * on a key is used, and the group determines whether the left or
+ * right symbol is used. On US keyboards, the shift key changes the
+ * keyboard level, and there are no groups. A group switch key might
+ * convert a keyboard between Hebrew to English modes, for example.
+ * #GdkEventKey contains a %group field that indicates the active
+ * keyboard group. The level is computed from the modifier mask.
+ * The returned array should be freed
+ * with g_free().
+ *
+ * Return value: %TRUE if keys were found and returned
+ **/
+gboolean
+gdk_keymap_get_entries_for_keyval (GdkKeymap     *keymap,
+		guint          keyval,
+		GdkKeymapKey **keys,
+		gint          *n_keys)
+{
+	GArray *retval;
+	gint    i, j;
+
+	g_return_val_if_fail (keys != NULL, FALSE);
+	g_return_val_if_fail (n_keys != NULL, FALSE);
+	g_return_val_if_fail (keyval != GDK_VoidSymbol, FALSE);
+
+	retval = g_array_new (FALSE, FALSE, sizeof (GdkKeymapKey));
+
+	for (i = directfb_min_keycode;
+			directfb_keymap && i <= directfb_max_keycode;
+			i++)
+	{
+		gint index = i - directfb_min_keycode;
+
+		for (j = 0; j < 4; j++)
+		{
+			if (directfb_keymap[index * 4 + j] == keyval)
+				append_keymap_key (retval, i, j % 2, j > DIKSI_BASE_SHIFT ? 1 : 0);
+		}
+	}
+
+	if (retval->len > 0)
+	{
+		*keys = (GdkKeymapKey *) retval->data;
+		*n_keys = retval->len;
+	}
+	else
+	{
+		*keys = NULL;
+		*n_keys = 0;
+	}
+
+	g_array_free (retval, retval->len > 0 ? FALSE : TRUE);
+
+	return (*n_keys > 0);
+}
+
+/**
+ * gdk_keymap_translate_keyboard_state:
+ * @keymap: a #GdkKeymap, or %NULL to use the default
+ * @keycode: a hardware keycode
+ * @state: a modifier state 
+ * @group: active keyboard group
+ * @keyval: return location for keyval
+ * @effective_group: return location for effective group
+ * @level: return location for level
+ * @consumed_modifiers: return location for modifiers that were used to 
+ *                      determine the group or level
+ *
+ * Translates the contents of a #GdkEventKey into a keyval, effective
+ * group, and level. Modifiers that affected the translation and
+ * are thus unavailable for application use are returned in
+ * @consumed_modifiers.  See gdk_keyval_get_keys() for an explanation of
+ * groups and levels.  The @effective_group is the group that was
+ * actually used for the translation; some keys such as Enter are not
+ * affected by the active keyboard group. The @level is derived from
+ * @state. For convenience, #GdkEventKey already contains the translated
+ * keyval, so this function isn't as useful as you might think.
+ * 
+ * Return value: %TRUE if there was a keyval bound to the keycode/state/group
+ **/
+gboolean
+gdk_keymap_translate_keyboard_state (GdkKeymap       *keymap,
+		guint            keycode,
+		GdkModifierType  state,
+		gint             group,
+		guint           *keyval,
+		gint            *effective_group,
+		gint            *level,
+		GdkModifierType *consumed_modifiers)
+{
+	if (directfb_keymap &&
+			(keycode >= directfb_min_keycode && keycode <= directfb_max_keycode) &&
+			(group == 0 || group == 1))
+	{
+		gint index = (keycode - directfb_min_keycode) * 4;
+		gint i =     (state & GDK_SHIFT_MASK) ? 1 : 0;
+
+		if (directfb_keymap[index + i + 2 * group] != GDK_VoidSymbol)
+		{
+			*keyval = directfb_keymap[index + i + 2 * group];
+
+			if (group && directfb_keymap[index + i] == *keyval)
+			{
+				*effective_group = 0;
+				*consumed_modifiers = 0;
+			}
+			else
+			{
+				*effective_group = group;
+				*consumed_modifiers = GDK_MOD2_MASK;
+			}
+
+			*level = i;
+
+			if (i && directfb_keymap[index + 2 * *effective_group] != *keyval)
+				*consumed_modifiers |= GDK_SHIFT_MASK;
+
+			return TRUE;
+		}
+	}
+
+	*keyval             = 0;
+	*effective_group    = 0;
+	*level              = 0;
+	*consumed_modifiers = 0;
+
+	return FALSE;
+}
+
+	GdkKeymap*
+gdk_keymap_get_for_display (GdkDisplay *display)
+{
+	if( display == NULL ) return NULL;
+	g_assert(GDK_IS_DISPLAY_DFB(display));
+	GdkDisplayDFB *gdisplay = GDK_DISPLAY_DFB(display);
+	g_assert( gdisplay->keymap != NULL);
+	return gdisplay->keymap;
+}
+
+	PangoDirection
+gdk_keymap_get_direction (GdkKeymap *keymap)
+{
+	return PANGO_DIRECTION_NEUTRAL;
+}
+
+/**
+ * gdk_keymap_lookup_key:
+ * @keymap: a #GdkKeymap or %NULL to use the default keymap
+ * @key: a #GdkKeymapKey with keycode, group, and level initialized
+ *
+ * Looks up the keyval mapped to a keycode/group/level triplet.
+ * If no keyval is bound to @key, returns 0. For normal user input,
+ * you want to use gdk_keymap_translate_keyboard_state() instead of
+ * this function, since the effective group/level may not be
+ * the same as the current keyboard state.
+ *
+ * Return value: a keyval, or 0 if none was mapped to the given @key
+ **/
+guint
+gdk_keymap_lookup_key (GdkKeymap          *keymap,
+		const GdkKeymapKey *key)
+{
+	g_warning("gdk_keymap_lookup_key unimplemented \n");	
+	return 0;
+}
+
+
+#define __GDK_KEYS_DIRECTFB_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkmain-directfb.c gtk+/gdk/directfb/gdkmain-directfb.c
--- old/gdk/directfb/gdkmain-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkmain-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,502 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ * Copyright (C) 1998-1999 Tor Lillqvist
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+/*
+ Main entry point for 2.6 seems to be open_display so 
+ most stuff in main is moved over to gdkdisplay-directfb.c
+ I'll move stub functions here that make no sense for directfb
+ and true globals
+ Michael Emmel
+*/
+
+#include <config.h>
+#include <string.h> 
+#include <stdlib.h> 
+#include "gdk.h"
+
+#include "gdkdisplay.h"
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+
+#include "gdkinput-directfb.h"
+
+#include "gdkintl.h"
+#include "gdkalias.h"
+
+
+void
+_gdk_windowing_init (void)
+{
+  /** 
+    Not that usable called before parse_args
+  **/
+}
+
+void
+gdk_set_use_xshm (gboolean use_xshm)
+{
+}
+
+gboolean
+gdk_get_use_xshm (void)
+{
+  return FALSE;
+}
+
+void
+_gdk_windowing_display_set_sm_client_id (GdkDisplay *display,const gchar *sm_client_id)
+{
+  g_message ("gdk_set_sm_client_id() is unimplemented.");
+}
+
+
+void
+_gdk_windowing_exit (void)
+{
+ 
+  if (_gdk_display->buffer)
+    _gdk_display->buffer->Release (_gdk_display->buffer);
+
+  _gdk_directfb_keyboard_exit ();
+
+  if (_gdk_display->keyboard)
+    _gdk_display->keyboard->Release (_gdk_display->keyboard);
+
+  _gdk_display->layer->Release (_gdk_display->layer);
+
+   _gdk_display->directfb->Release (_gdk_display->directfb);
+
+  g_free (_gdk_display);
+  _gdk_display = NULL;
+}
+
+gchar *
+gdk_get_display (void)
+{
+  return "DirectFB";
+}
+
+
+/* utils */
+static const guint type_masks[] =
+{
+  GDK_STRUCTURE_MASK,        /* GDK_DELETE            =  0, */
+  GDK_STRUCTURE_MASK,        /* GDK_DESTROY           =  1, */
+  GDK_EXPOSURE_MASK,         /* GDK_EXPOSE            =  2, */
+  GDK_POINTER_MOTION_MASK,   /* GDK_MOTION_NOTIFY     =  3, */
+  GDK_BUTTON_PRESS_MASK,     /* GDK_BUTTON_PRESS      =  4, */
+  GDK_BUTTON_PRESS_MASK,     /* GDK_2BUTTON_PRESS     =  5, */
+  GDK_BUTTON_PRESS_MASK,     /* GDK_3BUTTON_PRESS     =  6, */
+  GDK_BUTTON_RELEASE_MASK,   /* GDK_BUTTON_RELEASE    =  7, */
+  GDK_KEY_PRESS_MASK,        /* GDK_KEY_PRESS         =  8, */
+  GDK_KEY_RELEASE_MASK,      /* GDK_KEY_RELEASE       =  9, */
+  GDK_ENTER_NOTIFY_MASK,     /* GDK_ENTER_NOTIFY      = 10, */
+  GDK_LEAVE_NOTIFY_MASK,     /* GDK_LEAVE_NOTIFY      = 11, */
+  GDK_FOCUS_CHANGE_MASK,     /* GDK_FOCUS_CHANGE      = 12, */
+  GDK_STRUCTURE_MASK,        /* GDK_CONFIGURE         = 13, */
+  GDK_VISIBILITY_NOTIFY_MASK,/* GDK_MAP               = 14, */
+  GDK_VISIBILITY_NOTIFY_MASK,/* GDK_UNMAP             = 15, */
+  GDK_PROPERTY_CHANGE_MASK,  /* GDK_PROPERTY_NOTIFY   = 16, */
+  GDK_PROPERTY_CHANGE_MASK,  /* GDK_SELECTION_CLEAR   = 17, */
+  GDK_PROPERTY_CHANGE_MASK,  /* GDK_SELECTION_REQUEST = 18, */
+  GDK_PROPERTY_CHANGE_MASK,  /* GDK_SELECTION_NOTIFY  = 19, */
+  GDK_PROXIMITY_IN_MASK,     /* GDK_PROXIMITY_IN      = 20, */
+  GDK_PROXIMITY_OUT_MASK,    /* GDK_PROXIMITY_OUT     = 21, */
+  GDK_ALL_EVENTS_MASK,       /* GDK_DRAG_ENTER        = 22, */
+  GDK_ALL_EVENTS_MASK,       /* GDK_DRAG_LEAVE        = 23, */
+  GDK_ALL_EVENTS_MASK,       /* GDK_DRAG_MOTION       = 24, */
+  GDK_ALL_EVENTS_MASK,       /* GDK_DRAG_STATUS       = 25, */
+  GDK_ALL_EVENTS_MASK,       /* GDK_DROP_START        = 26, */
+  GDK_ALL_EVENTS_MASK,       /* GDK_DROP_FINISHED     = 27, */
+  GDK_ALL_EVENTS_MASK,       /* GDK_CLIENT_EVENT      = 28, */
+  GDK_VISIBILITY_NOTIFY_MASK,/* GDK_VISIBILITY_NOTIFY = 29, */
+  GDK_EXPOSURE_MASK,         /* GDK_NO_EXPOSE         = 30, */
+  GDK_SCROLL_MASK            /* GDK_SCROLL            = 31  */
+};
+
+GdkWindow *
+gdk_directfb_other_event_window (GdkWindow    *window,
+                                 GdkEventType  type)
+{
+  guint32    evmask;
+  GdkWindow *w;
+
+  w = window;
+  while (w != _gdk_parent_root)
+    {
+      /* Huge hack, so that we don't propagate events to GtkWindow->frame */
+      if ((w != window) &&
+          (GDK_WINDOW_OBJECT (w)->window_type != GDK_WINDOW_CHILD) &&
+          (g_object_get_data (G_OBJECT (w), "gdk-window-child-handler")))
+        break;
+
+      evmask = GDK_WINDOW_OBJECT (w)->event_mask;
+
+      if (evmask & type_masks[type])
+        return w;
+
+      w = gdk_window_get_parent (w);
+    }
+
+  return NULL;
+}
+
+GdkWindow *
+gdk_directfb_pointer_event_window (GdkWindow    *window,
+                                   GdkEventType  type)
+{
+  guint            evmask;
+  GdkModifierType  mask;
+  GdkWindow       *w;
+
+  gdk_directfb_mouse_get_info (NULL, NULL, &mask);
+
+  if (_gdk_directfb_pointer_grab_window && !_gdk_directfb_pointer_grab_owner_events )
+    {
+      evmask = _gdk_directfb_pointer_grab_events;
+
+      if (evmask & (GDK_BUTTON1_MOTION_MASK |
+                    GDK_BUTTON2_MOTION_MASK |
+                    GDK_BUTTON3_MOTION_MASK))
+        {
+          if (((mask & GDK_BUTTON1_MASK) &&
+               (evmask & GDK_BUTTON1_MOTION_MASK)) ||
+              ((mask & GDK_BUTTON2_MASK) &&
+               (evmask & GDK_BUTTON2_MOTION_MASK)) ||
+              ((mask & GDK_BUTTON3_MASK) &&
+               (evmask & GDK_BUTTON3_MOTION_MASK)))
+            evmask |= GDK_POINTER_MOTION_MASK;
+        }
+
+      if (evmask & type_masks[type]) {
+
+        if( _gdk_directfb_pointer_grab_owner_events ) {
+        return _gdk_directfb_pointer_grab_window;
+        }else {
+                GdkWindowObject *obj= GDK_WINDOW_OBJECT(window);
+                while (obj != NULL && 
+                    obj != GDK_WINDOW_OBJECT(_gdk_directfb_pointer_grab_window)) {
+                    obj = (GdkWindowObject *)obj->parent;
+                }
+                if( obj ==GDK_WINDOW_OBJECT(_gdk_directfb_pointer_grab_window) ) {
+                    return  window;
+                }else {
+                    //was not  child of the grab window so return the grab window
+                    return _gdk_directfb_pointer_grab_window;
+                }
+         }
+        }
+    }
+
+  w = window;
+  while (w != _gdk_parent_root)
+    {
+      /* Huge hack, so that we don't propagate events to GtkWindow->frame */
+      if ((w != window) &&
+          (GDK_WINDOW_OBJECT (w)->window_type != GDK_WINDOW_CHILD) &&
+          (g_object_get_data (G_OBJECT (w), "gdk-window-child-handler")))
+        break;
+
+      evmask = GDK_WINDOW_OBJECT (w)->event_mask;
+
+      if (evmask & (GDK_BUTTON1_MOTION_MASK |
+                    GDK_BUTTON2_MOTION_MASK |
+                    GDK_BUTTON3_MOTION_MASK))
+        {
+          if (((mask & GDK_BUTTON1_MASK) &&
+               (evmask & GDK_BUTTON1_MOTION_MASK)) ||
+              ((mask & GDK_BUTTON2_MASK) &&
+               (evmask & GDK_BUTTON2_MOTION_MASK)) ||
+              ((mask & GDK_BUTTON3_MASK) &&
+               (evmask & GDK_BUTTON3_MOTION_MASK)))
+            evmask |= GDK_POINTER_MOTION_MASK;
+        }
+
+      if (evmask & type_masks[type])
+        return w;
+
+      w = gdk_window_get_parent (w);
+    }
+
+  return NULL;
+}
+
+GdkWindow *
+gdk_directfb_keyboard_event_window (GdkWindow    *window,
+                                    GdkEventType  type)
+{
+  guint32    evmask;
+  GdkWindow *w;
+
+  if (_gdk_directfb_keyboard_grab_window &&
+      !_gdk_directfb_keyboard_grab_owner_events)
+    {
+      return _gdk_directfb_keyboard_grab_window;
+    }
+
+  w = window;
+  while (w != _gdk_parent_root)
+    {
+      /* Huge hack, so that we don't propagate events to GtkWindow->frame */
+      if ((w != window) &&
+          (GDK_WINDOW_OBJECT (w)->window_type != GDK_WINDOW_CHILD) &&
+          (g_object_get_data (G_OBJECT (w), "gdk-window-child-handler")))
+        break;
+
+      evmask = GDK_WINDOW_OBJECT (w)->event_mask;
+
+      if (evmask & type_masks[type])
+        return w;
+
+      w = gdk_window_get_parent (w);
+    }
+   return w;
+}
+
+
+GdkEvent *
+gdk_directfb_event_make (GdkWindow    *window,
+                         GdkEventType  type)
+{
+  GdkEvent *event    = gdk_event_new (GDK_NOTHING);
+  guint32   the_time = gdk_directfb_get_time ();
+  event->any.type       = type;
+  event->any.window     = g_object_ref (window);
+  event->any.send_event = FALSE;
+
+  switch (type)
+    {
+    case GDK_MOTION_NOTIFY:
+      event->motion.time = the_time;
+      event->motion.axes = NULL;
+      break;
+    case GDK_BUTTON_PRESS:
+    case GDK_2BUTTON_PRESS:
+    case GDK_3BUTTON_PRESS:
+    case GDK_BUTTON_RELEASE:
+      event->button.time = the_time;
+      event->button.axes = NULL;
+      break;
+    case GDK_KEY_PRESS:
+    case GDK_KEY_RELEASE:
+      event->key.time = the_time;
+      break;
+    case GDK_ENTER_NOTIFY:
+    case GDK_LEAVE_NOTIFY:
+      event->crossing.time = the_time;
+      break;
+    case GDK_PROPERTY_NOTIFY:
+      event->property.time = the_time;
+      break;
+    case GDK_SELECTION_CLEAR:
+    case GDK_SELECTION_REQUEST:
+    case GDK_SELECTION_NOTIFY:
+      event->selection.time = the_time;
+      break;
+    case GDK_PROXIMITY_IN:
+    case GDK_PROXIMITY_OUT:
+      event->proximity.time = the_time;
+      break;
+    case GDK_DRAG_ENTER:
+    case GDK_DRAG_LEAVE:
+    case GDK_DRAG_MOTION:
+    case GDK_DRAG_STATUS:
+    case GDK_DROP_START:
+    case GDK_DROP_FINISHED:
+      event->dnd.time = the_time;
+      break;
+    case GDK_SCROLL:
+      event->scroll.time = the_time;
+      break;
+    case GDK_FOCUS_CHANGE:
+    case GDK_CONFIGURE:
+    case GDK_MAP:
+    case GDK_UNMAP:
+    case GDK_CLIENT_EVENT:
+    case GDK_VISIBILITY_NOTIFY:
+    case GDK_NO_EXPOSE:
+    case GDK_DELETE:
+    case GDK_DESTROY:
+    case GDK_EXPOSE:
+    default:
+      break;
+    }
+
+  _gdk_event_queue_append (gdk_display_get_default (), event);
+
+  return event;
+}
+
+void
+gdk_error_trap_push (void)
+{
+}
+
+gint
+gdk_error_trap_pop (void)
+{
+  return 0;
+}
+
+
+/**
+ * gdk_pointer_grab_info_libgtk_only:
+ * @grab_window: location to store current grab window
+ * @owner_events: location to store boolean indicating whether
+ *   the @owner_events flag to gdk_pointer_grab() was %TRUE.
+ *
+ * Determines information about the current pointer grab.
+ * This is not public API and must not be used by applications.
+ *
+ * Return value: %TRUE if this application currently has the
+ *  pointer grabbed.
+ **/
+gboolean
+gdk_pointer_grab_info_libgtk_only (GdkDisplay *display,GdkWindow **grab_window,
+				   gboolean    *owner_events)
+{
+  if (_gdk_directfb_pointer_grab_window)
+    {
+      if (grab_window)
+        *grab_window = (GdkWindow *)_gdk_directfb_pointer_grab_window;
+      if (owner_events)
+        *owner_events = _gdk_directfb_pointer_grab_owner_events;
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+/**
+ * gdk_keyboard_grab_info_libgtk_only:
+ * @grab_window: location to store current grab window
+ * @owner_events: location to store boolean indicating whether
+ *   the @owner_events flag to gdk_keyboard_grab() was %TRUE.
+ *
+ * Determines information about the current keyboard grab.
+ * This is not public API and must not be used by applications.
+ *
+ * Return value: %TRUE if this application currently has the
+ *  keyboard grabbed.
+ **/
+gboolean
+gdk_keyboard_grab_info_libgtk_only (GdkDisplay *display,GdkWindow **grab_window,
+				    gboolean    *owner_events)
+{
+  if (_gdk_directfb_keyboard_grab_window)
+    {
+      if (grab_window)
+        *grab_window = (GdkWindow *) _gdk_directfb_keyboard_grab_window;
+      if (owner_events)
+        *owner_events = _gdk_directfb_keyboard_grab_owner_events;
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+GdkGrabStatus
+gdk_keyboard_grab (GdkWindow *window,
+                   gint       owner_events,
+                   guint32    time) 
+{
+	return gdk_display_keyboard_grab(gdk_display_get_default(),
+			window,
+			owner_events,
+			time);
+
+}
+
+/*
+ *--------------------------------------------------------------
+ * gdk_pointer_grab
+ *
+ *   Grabs the pointer to a specific window
+ *
+ * Arguments:
+ *   "window" is the window which will receive the grab
+ *   "owner_events" specifies whether events will be reported as is,
+ *     or relative to "window"
+ *   "event_mask" masks only interesting events
+ *   "confine_to" limits the cursor movement to the specified window
+ *   "cursor" changes the cursor for the duration of the grab
+ *   "time" specifies the time
+ *
+ * Results:
+ *
+ * Side effects:
+ *   requires a corresponding call to gdk_pointer_ungrab
+ *
+ *--------------------------------------------------------------
+ */
+
+
+GdkGrabStatus
+gdk_display_pointer_grab (GdkDisplay *display,GdkWindow    *window,
+                  gint          owner_events,
+                  GdkEventMask  event_mask,
+                  GdkWindow    *confine_to,
+                  GdkCursor    *cursor,
+                  guint32       time)
+{
+  g_return_val_if_fail (GDK_IS_WINDOW (window), 0);
+  g_return_val_if_fail (confine_to == NULL || GDK_IS_WINDOW (confine_to), 0);
+
+  return gdk_directfb_pointer_grab (window,
+                                    owner_events,
+                                    event_mask,
+                                    confine_to,
+                                    cursor,
+                                    time,
+                                    FALSE);
+}
+
+GdkGrabStatus
+gdk_pointer_grab (GdkWindow *     window,
+                  gint            owner_events,
+                  GdkEventMask    event_mask,
+                  GdkWindow *     confine_to,
+                  GdkCursor *     cursor,
+                  guint32         time)
+{
+	return gdk_directfb_pointer_grab(window, owner_events,event_mask,
+		confine_to,cursor,time,FALSE);	
+}
+
+#define __GDK_MAIN_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkpixmap-directfb.c gtk+/gdk/directfb/gdkpixmap-directfb.c
--- old/gdk/directfb/gdkpixmap-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkpixmap-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,341 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ * Copyright (C) 1998-1999 Tor Lillqvist
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+
+#include "gdkpixmap.h"
+#include "gdkalias.h"
+
+
+static void gdk_pixmap_impl_directfb_init       (GdkPixmapImplDirectFB      *pixmap);
+static void gdk_pixmap_impl_directfb_class_init (GdkPixmapImplDirectFBClass *klass);
+static void gdk_pixmap_impl_directfb_finalize   (GObject                    *object);
+
+
+static gpointer parent_class = NULL;
+
+
+GType
+gdk_pixmap_impl_directfb_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+        {
+          sizeof (GdkPixmapImplDirectFBClass),
+          (GBaseInitFunc) NULL,
+          (GBaseFinalizeFunc) NULL,
+          (GClassInitFunc) gdk_pixmap_impl_directfb_class_init,
+          NULL,           /* class_finalize */
+          NULL,           /* class_data */
+          sizeof (GdkPixmapImplDirectFB),
+          0,              /* n_preallocs */
+          (GInstanceInitFunc) gdk_pixmap_impl_directfb_init,
+        };
+
+      object_type = g_type_register_static (GDK_TYPE_DRAWABLE_IMPL_DIRECTFB,
+                                            "GdkPixmapImplDirectFB",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+GType
+_gdk_pixmap_impl_get_type (void)
+{
+  return gdk_pixmap_impl_directfb_get_type ();
+}
+
+static void
+gdk_pixmap_impl_directfb_init (GdkPixmapImplDirectFB *impl)
+{
+  GdkDrawableImplDirectFB *draw_impl = GDK_DRAWABLE_IMPL_DIRECTFB (impl);
+  draw_impl->width  = 1;
+  draw_impl->height = 1;
+}
+
+static void
+gdk_pixmap_impl_directfb_class_init (GdkPixmapImplDirectFBClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = gdk_pixmap_impl_directfb_finalize;
+}
+
+static void
+gdk_pixmap_impl_directfb_finalize (GObject *object)
+{
+  GdkDrawableImplDirectFB *impl = GDK_DRAWABLE_IMPL_DIRECTFB (object);
+
+  if (G_OBJECT_CLASS (parent_class)->finalize)
+    G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+GdkPixmap*
+gdk_pixmap_new (GdkDrawable *drawable,
+                gint       width,
+                gint       height,
+                gint       depth)
+{
+  DFBSurfacePixelFormat    format;
+  IDirectFBSurface        *surface;
+  GdkPixmap               *pixmap;
+  GdkDrawableImplDirectFB *draw_impl;
+
+  g_return_val_if_fail (drawable == NULL || GDK_IS_DRAWABLE (drawable), NULL);
+  g_return_val_if_fail (drawable != NULL || depth != -1, NULL);
+  g_return_val_if_fail (width > 0 && height > 0, NULL);
+
+  if (!drawable)
+    drawable = _gdk_parent_root;
+
+  if (GDK_IS_WINDOW (drawable) && GDK_WINDOW_DESTROYED (drawable))
+    return NULL;
+
+  GDK_NOTE (MISC, g_print ("gdk_pixmap_new: %dx%dx%d\n",
+                           width, height, depth));
+
+  if (depth == -1)
+    {
+      draw_impl =
+        GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (drawable)->impl);
+
+      g_return_val_if_fail (draw_impl != NULL, NULL);
+
+      draw_impl->surface->GetPixelFormat (draw_impl->surface, &format);
+      depth = DFB_BITS_PER_PIXEL (format);
+    }
+  else
+    {
+      switch (depth)
+        {
+        case  1:
+          format = DSPF_A8;
+          break;
+        case  8:
+          format = DSPF_LUT8;
+          break;
+        case 15:
+          format = DSPF_ARGB1555;
+          break;
+        case 16:
+          format = DSPF_RGB16;
+          break;
+        case 24:
+        case 32:
+          format = DSPF_RGB32;
+          break;
+        default:
+          g_message ("unimplemented %s for depth %d", G_GNUC_FUNCTION, depth);
+          return NULL;
+        }
+    }
+
+  if( !(surface = 
+	gdk_display_dfb_create_surface(_gdk_display,format,width,height) )) { 
+    g_assert( surface != NULL);
+    return NULL;
+  }
+
+  pixmap = g_object_new (gdk_pixmap_get_type (), NULL);
+  draw_impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (pixmap)->impl);
+  draw_impl->surface = surface;
+  surface->Clear (surface, 0x0, 0x0, 0x0, 0x0);
+  surface->GetSize (surface, &draw_impl->width, &draw_impl->height);
+  surface->GetPixelFormat (surface, &draw_impl->format);
+
+  draw_impl->abs_x = draw_impl->abs_y = 0;
+
+  GDK_PIXMAP_OBJECT (pixmap)->depth = depth;
+
+  return pixmap;
+}
+
+GdkPixmap *
+gdk_bitmap_create_from_data (GdkDrawable   *drawable,
+                             const gchar *data,
+                             gint         width,
+                             gint         height)
+{
+  GdkPixmap *pixmap;
+
+  g_return_val_if_fail (drawable == NULL || GDK_IS_DRAWABLE (drawable), NULL);
+  g_return_val_if_fail (data != NULL, NULL);
+  g_return_val_if_fail (width > 0 && height > 0, NULL);
+
+  GDK_NOTE (MISC, g_print ("gdk_bitmap_create_from_data: %dx%d\n",
+                           width, height));
+
+  pixmap = gdk_pixmap_new (drawable, width, height, 1);
+
+#define GET_PIXEL(data,pixel) \
+  ((data[(pixel / 8)] & (0x1 << ((pixel) % 8))) >> ((pixel) % 8))
+
+  if (pixmap)
+    {
+      guchar *dst;
+      gint    pitch;
+
+      IDirectFBSurface *surface;
+
+      surface = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (pixmap)->impl)->surface;
+
+      if (surface->Lock( surface, DSLF_WRITE, (void**)(&dst), &pitch ) == DFB_OK)
+        {
+          gint i, j;
+
+          for (i = 0; i < height; i++)
+            {
+	      for (j = 0; j < width; j++)
+		{
+		  dst[j] = GET_PIXEL (data, j) * 255;
+		}
+
+              data += (width + 7) / 8;
+	      dst += pitch;
+            }
+
+          surface->Unlock( surface );
+        }
+    }
+
+#undef GET_PIXEL
+
+  return pixmap;
+}
+
+GdkPixmap*
+gdk_pixmap_create_from_data (GdkDrawable   *drawable,
+                             const gchar *data,
+                             gint         width,
+                             gint         height,
+                             gint         depth,
+                             const GdkColor    *fg,
+                             const GdkColor    *bg)
+{
+  GdkPixmap *pixmap;
+
+  g_return_val_if_fail (drawable == NULL || GDK_IS_DRAWABLE (drawable), NULL);
+  g_return_val_if_fail (data != NULL, NULL);
+  g_return_val_if_fail (drawable != NULL || depth > 0, NULL);
+  g_return_val_if_fail (width > 0 && height > 0, NULL);
+
+  GDK_NOTE (MISC, g_print ("gdk_pixmap_create_from_data: %dx%dx%d\n",
+                           width, height, depth));
+
+  pixmap = gdk_pixmap_new (drawable, width, height, depth);
+
+  if (pixmap)
+    {
+      IDirectFBSurface *surface;
+      gchar            *dst;
+      gint              pitch;
+      gint              src_pitch;
+
+      depth = gdk_drawable_get_depth (pixmap);
+      src_pitch = width * ((depth + 7) / 8);
+
+      surface = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_PIXMAP_OBJECT (pixmap)->impl)->surface;
+
+      if (surface->Lock( surface,
+                         DSLF_WRITE, (void**)(&dst), &pitch ) == DFB_OK)
+        {
+          gint i;
+
+          for (i = 0; i < height; i++)
+            {
+              memcpy (dst, data, src_pitch);
+              dst += pitch;
+              data += src_pitch;
+            }
+
+          surface->Unlock( surface );
+        }
+    }
+
+  return pixmap;
+}
+
+GdkPixmap*
+gdk_pixmap_foreign_new (GdkNativeWindow anid)
+{
+  g_warning(" gdk_pixmap_foreign_new unsuporrted \n");
+  return NULL;
+}
+
+GdkPixmap*
+gdk_pixmap_foreign_new_for_display (GdkDisplay *display, GdkNativeWindow anid)
+{
+  return gdk_pixmap_foreign_new(anid);
+}
+
+GdkPixmap*
+gdk_pixmap_foreign_new_for_screen (GdkScreen       *screen,
+                                   GdkNativeWindow  anid,
+                                   gint             width,
+                                   gint             height,
+                                   gint             depth)
+{
+  /*Use the root drawable for now since only one screen */
+  return gdk_pixmap_new(NULL,width,height,depth);
+}
+
+
+GdkPixmap*
+gdk_pixmap_lookup (GdkNativeWindow anid)
+{
+  g_warning(" gdk_pixmap_lookup unsuporrted \n");
+  return NULL;
+}
+
+GdkPixmap* gdk_pixmap_lookup_for_display (GdkDisplay *display,GdkNativeWindow anid)
+{
+  return gdk_pixmap_lookup (anid);
+}
+
+#define __GDK_PIXMAP_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkprivate-directfb.h gtk+/gdk/directfb/gdkprivate-directfb.h
--- old/gdk/directfb/gdkprivate-directfb.h	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkprivate-directfb.h	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,318 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#ifndef __GDK_PRIVATE_DIRECTFB_H__
+#define __GDK_PRIVATE_DIRECTFB_H__
+
+//#include <gdk/gdk.h>
+#include <gdk/gdkprivate.h>
+#include "gdkinternals.h"
+#include "gdkcursor.h"
+#include "gdkdisplay-directfb.h"
+#include <cairo.h>
+
+
+
+#define GDK_TYPE_DRAWABLE_IMPL_DIRECTFB       (gdk_drawable_impl_directfb_get_type ())
+#define GDK_DRAWABLE_IMPL_DIRECTFB(object)    (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_DRAWABLE_IMPL_DIRECTFB, GdkDrawableImplDirectFB))
+#define GDK_IS_DRAWABLE_IMPL_DIRECTFB(object) (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_DRAWABLE_IMPL_DIRECTFB))
+
+#define GDK_TYPE_WINDOW_IMPL_DIRECTFB         (gdk_window_impl_directfb_get_type ())
+#define GDK_WINDOW_IMPL_DIRECTFB(object)      (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_WINDOW_IMPL_DIRECTFB, GdkWindowImplDirectFB))
+#define GDK_IS_WINDOW_IMPL_DIRECTFB(object)   (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_WINDOW_IMPL_DIRECTFB))
+
+#define GDK_TYPE_PIXMAP_IMPL_DIRECTFB         (gdk_pixmap_impl_directfb_get_type ())
+#define GDK_PIXMAP_IMPL_DIRECTFB(object)      (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_PIXMAP_IMPL_DIRECTFB, GdkPixmapImplDirectFB))
+#define GDK_IS_PIXMAP_IMPL_DIRECTFB(object)   (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_PIXMAP_IMPL_DIRECTFB))
+
+
+typedef struct _GdkDrawableImplDirectFB GdkDrawableImplDirectFB;
+typedef struct _GdkWindowImplDirectFB   GdkWindowImplDirectFB;
+typedef struct _GdkPixmapImplDirectFB   GdkPixmapImplDirectFB;
+
+
+struct _GdkDrawableImplDirectFB
+{
+  GdkDrawable             parent_object;
+
+  GdkDrawable            *wrapper;
+
+  gboolean                buffered;
+
+  GdkRegion              *paint_region;
+  gint                    paint_depth;
+
+  gint                    width;
+  gint                    height;
+  gint                    abs_x;
+  gint                    abs_y;
+
+  GdkColormap            *colormap;
+
+  IDirectFBSurface       *surface;
+  DFBSurfacePixelFormat   format;
+  cairo_surface_t *  cairo_surface;
+
+};
+
+typedef struct
+{
+  GdkDrawableClass  parent_class;
+} GdkDrawableImplDirectFBClass;
+
+GType      gdk_drawable_impl_directfb_get_type (void);
+
+void       _gdk_directfb_draw_rectangle (GdkDrawable *drawable,
+                                         GdkGC       *gc,
+                                         gint         filled,
+                                         gint         x,
+                                         gint         y,
+                                         gint         width,
+                                         gint         height);
+
+void       _gdk_directfb_update         (GdkDrawableImplDirectFB *impl,
+                                         DFBRegion               *region);
+
+GdkEvent *  gdk_directfb_event_make     (GdkWindow               *window,
+                                         GdkEventType             type);
+
+
+/*
+ * Pixmap
+ */
+
+struct _GdkPixmapImplDirectFB
+{
+  GdkDrawableImplDirectFB parent_instance;
+};
+
+typedef struct
+{
+  GdkDrawableImplDirectFBClass parent_class;
+} GdkPixmapImplDirectFBClass;
+
+GType gdk_pixmap_impl_directfb_get_type (void);
+
+
+
+/*
+ * Window
+ */
+
+typedef struct
+{
+  gulong   length;
+  GdkAtom  type;
+  gint     format;
+  guchar   data[1];
+} GdkWindowProperty;
+
+
+struct _GdkWindowImplDirectFB
+{
+  GdkDrawableImplDirectFB drawable;
+
+  IDirectFBWindow        *window;
+
+  DFBWindowID             dfb_id;
+
+  GdkCursor              *cursor;
+  GHashTable             *properties;
+
+  guint8                  opacity;
+
+  GdkWindowTypeHint       type_hint;
+};
+
+typedef struct
+{
+  GdkDrawableImplDirectFBClass parent_class;
+} GdkWindowImplDirectFBClass;
+
+GType gdk_window_impl_directfb_get_type        (void);
+
+void  gdk_directfb_window_send_crossing_events (GdkWindow       *src,
+                                                GdkWindow       *dest,
+                                                GdkCrossingMode  mode);
+
+void  _gdk_directfb_calc_abs                   (GdkWindow       *window);
+
+GdkWindow * gdk_directfb_window_find_toplevel  (GdkWindow       *window);
+
+
+void        gdk_directfb_window_id_table_insert (DFBWindowID  dfb_id,
+                                                 GdkWindow   *window);
+void        gdk_directfb_window_id_table_remove (DFBWindowID  dfb_id);
+GdkWindow * gdk_directfb_window_id_table_lookup (DFBWindowID  dfb_id);
+
+
+typedef struct
+{
+  GdkCursor         cursor;
+
+  gint              hot_x;
+  gint              hot_y;
+  IDirectFBSurface *shape;
+} GdkCursorDirectFB;
+
+typedef struct
+{
+  GdkVisual              visual;
+  DFBSurfacePixelFormat  format;
+} GdkVisualDirectFB;
+
+typedef struct
+{
+  IDirectFBSurface *surface;
+} GdkImageDirectFB;
+
+
+#define GDK_TYPE_GC_DIRECTFB       (gdk_gc_directfb_get_type ())
+#define GDK_GC_DIRECTFB(object)    (G_TYPE_CHECK_INSTANCE_CAST ((object), GDK_TYPE_GC_DIRECTFB, GdkGCDirectFB))
+#define GDK_IS_GC_DIRECTFB(object) (G_TYPE_CHECK_INSTANCE_TYPE ((object), GDK_TYPE_GC_DIRECTFB))
+
+typedef struct
+{
+  GdkGC             parent_instance;
+
+  GdkRegion        *clip_region;
+
+  GdkGCValuesMask   values_mask;
+  GdkGCValues       values;
+} GdkGCDirectFB;
+
+typedef struct
+{
+  GdkGCClass        parent_class;
+} GdkGCDirectFBClass;
+
+GType     gdk_gc_directfb_get_type (void);
+
+GdkGC *  _gdk_directfb_gc_new      (GdkDrawable     *drawable,
+                                    GdkGCValues     *values,
+                                    GdkGCValuesMask  values_mask);
+
+GdkImage* _gdk_directfb_copy_to_image (GdkDrawable  *drawable,
+                                       GdkImage     *image,
+                                       gint          src_x,
+                                       gint          src_y,
+                                       gint          dest_x,
+                                       gint          dest_y,
+                                       gint          width,
+                                       gint          height);
+
+void       gdk_directfb_event_windows_add (GdkWindow *window);
+
+GdkGrabStatus gdk_directfb_pointer_grab   (GdkWindow           *window,
+                                           gint                 owner_events,
+                                           GdkEventMask         event_mask,
+                                           GdkWindow           *confine_to,
+                                           GdkCursor           *cursor,
+                                           guint32              time,
+                                           gboolean             implicit_grab);
+void          gdk_directfb_pointer_ungrab (guint32              time,
+                                           gboolean             implicit_grab);
+
+guint32       gdk_directfb_get_time       (void);
+
+GdkWindow * gdk_directfb_pointer_event_window  (GdkWindow    *window,
+                                                GdkEventType  type);
+GdkWindow * gdk_directfb_keyboard_event_window (GdkWindow    *window,
+                                                GdkEventType  type);
+GdkWindow * gdk_directfb_other_event_window    (GdkWindow    *window,
+                                                GdkEventType  type);
+void       _gdk_selection_window_destroyed    (GdkWindow       *window);
+
+void       _gdk_directfb_move_resize_child (GdkWindow *window,
+                                            gint       x,
+                                            gint       y,
+                                            gint       width,
+                                            gint       height);
+
+GdkWindow * gdk_directfb_child_at          (GdkWindow *window,
+                                            gint      *x,
+                                            gint      *y);
+
+GdkWindow * gdk_directfb_window_find_focus (void);
+
+void        gdk_directfb_change_focus      (GdkWindow *new_focus_window);
+
+void        gdk_directfb_mouse_get_info    (gint            *x,
+                                            gint            *y,
+                                            GdkModifierType *mask);
+
+/**********************/
+/*  Global variables  */
+/**********************/
+
+extern GdkDisplayDFB *_gdk_display;
+
+/* Pointer grab info */
+extern GdkWindow           * _gdk_directfb_pointer_grab_window;
+extern gboolean              _gdk_directfb_pointer_grab_owner_events;
+extern GdkWindow           * _gdk_directfb_pointer_grab_confine;
+extern GdkEventMask          _gdk_directfb_pointer_grab_events;
+extern GdkCursor           * _gdk_directfb_pointer_grab_cursor;
+
+/* Keyboard grab info */
+extern GdkWindow           * _gdk_directfb_keyboard_grab_window;
+extern GdkEventMask          _gdk_directfb_keyboard_grab_events;
+extern gboolean              _gdk_directfb_keyboard_grab_owner_events;
+
+extern GdkScreen  *  _gdk_screen;
+
+extern GdkAtom               _gdk_selection_property;
+
+
+IDirectFBPalette * gdk_directfb_colormap_get_palette (GdkColormap *colormap);
+
+
+/* these are Linux-FB specific functions used for window decorations */
+
+typedef gboolean (* GdkWindowChildChanged) (GdkWindow *window,
+                                            gint       x,
+                                            gint       y,
+                                            gint       width,
+                                            gint       height,
+                                            gpointer   user_data);
+typedef void     (* GdkWindowChildGetPos)  (GdkWindow *window,
+                                            gint      *x,
+                                            gint      *y,
+                                            gpointer   user_data);
+
+void gdk_fb_window_set_child_handler (GdkWindow              *window,
+                                      GdkWindowChildChanged  changed,
+                                      GdkWindowChildGetPos   get_pos,
+                                      gpointer               user_data);
+
+
+#endif /* __GDK_PRIVATE_DIRECTFB_H__ */
diff -ruN old/gdk/directfb/gdkproperty-directfb.c gtk+/gdk/directfb/gdkproperty-directfb.c
--- old/gdk/directfb/gdkproperty-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkproperty-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,401 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+
+#include <string.h>
+
+#include "gdkproperty.h"
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+
+#include "gdkalias.h"
+
+static GHashTable *names_to_atoms;
+static GPtrArray *atoms_to_names;
+
+static const gchar xatoms_string[] = 
+  /* These are all the standard predefined X atoms */
+  "NONE\0"
+  "PRIMARY\0"
+  "SECONDARY\0"
+  "ARC\0"
+  "ATOM\0"
+  "BITMAP\0"
+  "CARDINAL\0"
+  "COLORMAP\0"
+  "CURSOR\0"
+  "CUT_BUFFER0\0"
+  "CUT_BUFFER1\0"
+  "CUT_BUFFER2\0"
+  "CUT_BUFFER3\0"
+  "CUT_BUFFER4\0"
+  "CUT_BUFFER5\0"
+  "CUT_BUFFER6\0"
+  "CUT_BUFFER7\0"
+  "DRAWABLE\0"
+  "FONT\0"
+  "INTEGER\0"
+  "PIXMAP\0"
+  "POINT\0"
+  "RECTANGLE\0"
+  "RESOURCE_MANAGER\0"
+  "RGB_COLOR_MAP\0"
+  "RGB_BEST_MAP\0"
+  "RGB_BLUE_MAP\0"
+  "RGB_DEFAULT_MAP\0"
+  "RGB_GRAY_MAP\0"
+  "RGB_GREEN_MAP\0"
+  "RGB_RED_MAP\0"
+  "STRING\0"
+  "VISUALID\0"
+  "WINDOW\0"
+  "WM_COMMAND\0"
+  "WM_HINTS\0"
+  "WM_CLIENT_MACHINE\0"
+  "WM_ICON_NAME\0"
+  "WM_ICON_SIZE\0"
+  "WM_NAME\0"
+  "WM_NORMAL_HINTS\0"
+  "WM_SIZE_HINTS\0"
+  "WM_ZOOM_HINTS\0"
+  "MIN_SPACE\0"
+  "NORM_SPACE\0"
+  "MAX_SPACE\0"
+  "END_SPACE\0"
+  "SUPERSCRIPT_X\0"
+  "SUPERSCRIPT_Y\0"
+  "SUBSCRIPT_X\0"
+  "SUBSCRIPT_Y\0"
+  "UNDERLINE_POSITION\0"
+  "UNDERLINE_THICKNESS\0"
+  "STRIKEOUT_ASCENT\0"
+  "STRIKEOUT_DESCENT\0"
+  "ITALIC_ANGLE\0"
+  "X_HEIGHT\0"
+  "QUAD_WIDTH\0"
+  "WEIGHT\0"
+  "POINT_SIZE\0"
+  "RESOLUTION\0"
+  "COPYRIGHT\0"
+  "NOTICE\0"
+  "FONT_NAME\0"
+  "FAMILY_NAME\0"
+  "FULL_NAME\0"
+  "CAP_HEIGHT\0"
+  "WM_CLASS\0"
+  "WM_TRANSIENT_FOR\0"
+;
+
+static const gint xatoms_offset[] = {
+    0,   5,  13,  23,  27,  32,  39,  48,  57,  64,  76,  88, 
+  100, 112, 124, 136, 148, 160, 169, 174, 182, 189, 195, 205, 
+  222, 236, 249, 262, 278, 291, 305, 317, 324, 333, 340, 351, 
+  360, 378, 391, 404, 412, 428, 442, 456, 466, 477, 487, 497, 
+  511, 525, 537, 549, 568, 588, 605, 623, 636, 645, 656, 663, 
+  674, 685, 695, 702, 712, 724, 734, 745, 754
+};
+
+#define N_CUSTOM_PREDEFINED 1
+
+static void
+ensure_atom_tables (void)
+{
+  int i;
+  
+  if (names_to_atoms)
+    return;
+
+  names_to_atoms = g_hash_table_new (g_str_hash, g_str_equal);
+  atoms_to_names = g_ptr_array_sized_new (G_N_ELEMENTS (xatoms_offset));
+
+  for (i = 0; i < G_N_ELEMENTS (xatoms_offset); i++)
+    {
+      g_hash_table_insert(names_to_atoms, (gchar *)xatoms_string + xatoms_offset[i], GINT_TO_POINTER (i));
+      g_ptr_array_add(atoms_to_names, (gchar *)xatoms_string + xatoms_offset[i]);
+    }
+}
+
+static GdkAtom
+intern_atom_internal (const gchar *atom_name, gboolean allocate)
+{
+  gpointer result;
+  gchar *name;
+  g_return_val_if_fail (atom_name != NULL, GDK_NONE);
+
+  ensure_atom_tables ();
+  
+  if (g_hash_table_lookup_extended (names_to_atoms, atom_name, NULL, &result))
+    return result;
+  
+  result = GINT_TO_POINTER (atoms_to_names->len);
+  name = allocate ? g_strdup (atom_name) : (gchar *)atom_name;
+  g_hash_table_insert(names_to_atoms, name, result);
+  g_ptr_array_add(atoms_to_names, name);
+  
+  return result;  
+}
+
+GdkAtom
+gdk_atom_intern (const gchar *atom_name,
+		 gboolean     only_if_exists)
+{
+  return intern_atom_internal (atom_name, TRUE);
+}
+
+GdkAtom
+gdk_atom_intern_static_string (const gchar *atom_name)
+{
+  return intern_atom_internal (atom_name, FALSE);
+}
+
+
+gchar *
+gdk_atom_name (GdkAtom atom)
+{
+  if (!atoms_to_names)
+    return NULL;
+    
+  if (GPOINTER_TO_INT (atom) >= atoms_to_names->len)
+    return NULL;
+    
+  return g_ptr_array_index (atoms_to_names, GPOINTER_TO_INT (atom));
+}
+
+
+static void
+gdk_property_delete_2 (GdkWindow         *window,
+                       GdkAtom            property,
+                       GdkWindowProperty *prop)
+{
+  GdkWindowImplDirectFB *impl;
+  GdkEvent              *event;
+  GdkWindow             *event_window;
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  g_hash_table_remove (impl->properties, GUINT_TO_POINTER (property));
+  g_free (prop);
+
+  event_window = gdk_directfb_other_event_window (window, GDK_PROPERTY_NOTIFY);
+
+  if (event_window)
+    {
+      event = gdk_directfb_event_make (event_window, GDK_PROPERTY_NOTIFY);
+      event->property.atom  = property;
+      event->property.state = GDK_PROPERTY_DELETE;
+    }
+}
+
+void
+gdk_property_delete (GdkWindow *window,
+                     GdkAtom    property)
+{
+  GdkWindowImplDirectFB *impl;
+  GdkWindowProperty     *prop;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  if (!impl->properties)
+    return;
+
+  prop = g_hash_table_lookup (impl->properties, GUINT_TO_POINTER (property));
+  if (!prop)
+    return;
+
+  gdk_property_delete_2 (window, property, prop);
+}
+
+gboolean
+gdk_property_get (GdkWindow   *window,
+                  GdkAtom      property,
+                  GdkAtom      type,
+                  gulong       offset,
+                  gulong       length,
+                  gint         pdelete,
+                  GdkAtom     *actual_property_type,
+                  gint        *actual_format_type,
+                  gint        *actual_length,
+                  guchar     **data)
+{
+  GdkWindowImplDirectFB *impl;
+  GdkWindowProperty     *prop;
+  gint                   nbytes = 0;
+
+  g_return_val_if_fail (window == NULL || GDK_IS_WINDOW (window), FALSE);
+  g_return_val_if_fail (data != NULL, FALSE);
+
+  if (!window)
+    window = _gdk_parent_root;
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return FALSE;
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  if (!impl->properties)
+    return FALSE;
+
+  prop = g_hash_table_lookup (impl->properties, GUINT_TO_POINTER (property));
+  if (!prop)
+    {
+      if (actual_property_type)
+        *actual_property_type = GDK_NONE;
+      return FALSE;
+    }
+
+  nbytes = CLAMP (length, 0, prop->length - offset * 4);
+
+  if (nbytes > 0 &&
+      (prop->type == 0 /* AnyPropertyType */ || prop->type == type))
+    {
+      *data = g_malloc (nbytes + 1);
+      memcpy (*data, prop->data + offset, nbytes);
+      (*data)[nbytes] = 0;
+    }
+  else
+    {
+      *data = NULL;
+    }
+
+  if (actual_length)
+    *actual_length = nbytes;
+  if (actual_property_type)
+    *actual_property_type = prop->type;
+  if (actual_format_type)
+    *actual_format_type = prop->format;
+
+  /* only delete the property if it was completely retrieved */
+  if (pdelete && length >= *actual_length && *data != NULL)
+    {
+      gdk_property_delete_2 (window, property, prop);
+    }
+
+  return TRUE;
+}
+
+void
+gdk_property_change (GdkWindow    *window,
+                     GdkAtom       property,
+                     GdkAtom       type,
+                     gint          format,
+                     GdkPropMode   mode,
+                     const guchar *data,
+                     gint          nelements)
+{
+  GdkWindowImplDirectFB *impl;
+  GdkWindowProperty     *prop;
+  GdkWindowProperty     *new_prop;
+  gint                   new_size = 0;
+  GdkEvent              *event;
+  GdkWindow             *event_window;
+
+  g_return_if_fail (window == NULL || GDK_IS_WINDOW (window));
+
+  if (!window)
+    window = _gdk_parent_root;
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  if (!impl->properties)
+    impl->properties = g_hash_table_new (NULL, NULL);
+
+  prop = g_hash_table_lookup (impl->properties, GUINT_TO_POINTER (property));
+
+  switch (mode)
+    {
+    case GDK_PROP_MODE_REPLACE:
+      new_size = nelements * (format >> 3);
+      break;
+
+    case GDK_PROP_MODE_PREPEND:
+    case GDK_PROP_MODE_APPEND:
+      new_size = nelements * (format >> 3);
+      if (prop)
+        {
+          if (type != prop->type || format != prop->format)
+            return;
+          new_size += prop->length;
+        }
+      break;
+    }
+
+  new_prop = g_malloc (G_STRUCT_OFFSET (GdkWindowProperty, data) + new_size);
+  new_prop->length = new_size;
+  new_prop->type   = type;
+  new_prop->format = format;
+
+  switch (mode)
+    {
+    case GDK_PROP_MODE_REPLACE:
+      memcpy (new_prop->data, data, new_size);
+      break;
+
+    case GDK_PROP_MODE_APPEND:
+      if (prop)
+        memcpy (new_prop->data, prop->data, prop->length);
+      memcpy (new_prop->data + new_prop->length,
+              data, (nelements * (format >> 3)));
+      break;
+
+    case GDK_PROP_MODE_PREPEND:
+      memcpy (new_prop->data, data, (nelements * (format >> 3)));
+      if (prop)
+        memcpy (new_prop->data + (nelements * (format >> 3)),
+                prop->data, prop->length);
+      break;
+    }
+
+  g_hash_table_insert (impl->properties,
+                       GUINT_TO_POINTER (property), new_prop);
+  g_free (prop);
+
+  event_window = gdk_directfb_other_event_window (window, GDK_PROPERTY_NOTIFY);
+
+  if (event_window)
+    {
+      event = gdk_directfb_event_make (event_window, GDK_PROPERTY_NOTIFY);
+      event->property.atom  = property;
+      event->property.state = GDK_PROPERTY_NEW_VALUE;
+    }
+}
+#define __GDK_PROPERTY_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkscreen-directfb.c gtk+/gdk/directfb/gdkscreen-directfb.c
--- old/gdk/directfb/gdkscreen-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkscreen-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,223 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ * Copyright (C) 1998-1999 Tor Lillqvist
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include "config.h"
+#include "gdk.h"
+#include "gdkscreen.h"
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkinternals.h"
+#include "gdkalias.h"
+
+
+static GdkColormap *default_colormap = NULL;
+
+GdkDisplay *
+gdk_screen_get_display (GdkScreen *screen)
+{
+  return GDK_DISPLAY_OBJECT(_gdk_display);
+}
+
+GdkWindow *
+gdk_screen_get_root_window (GdkScreen *screen)
+{
+  return _gdk_parent_root;
+}
+
+GdkColormap*
+gdk_screen_get_default_colormap (GdkScreen *screen)
+{
+  return default_colormap;
+}
+
+void
+gdk_screen_set_default_colormap (GdkScreen   *screen,
+				 GdkColormap *colormap)
+{
+  GdkColormap *old_colormap;
+
+  g_return_if_fail (GDK_IS_SCREEN (screen));
+  g_return_if_fail (GDK_IS_COLORMAP (colormap));
+
+  old_colormap = default_colormap;
+
+  default_colormap = g_object_ref (colormap);
+
+  if (old_colormap)
+    g_object_unref (old_colormap);
+}
+
+gint
+gdk_screen_get_n_monitors (GdkScreen *screen)
+{
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), 0);
+
+  return 1;
+}
+
+void
+gdk_screen_get_monitor_geometry (GdkScreen    *screen,
+				 gint          num_monitor,
+				 GdkRectangle *dest)
+{
+  g_return_if_fail (GDK_IS_SCREEN (screen));
+  g_return_if_fail (dest != NULL);
+
+  dest->x = 0;
+  dest->y = 0;
+  dest->width  = gdk_screen_width ();
+  dest->height = gdk_screen_height ();
+}
+
+gint
+gdk_screen_get_number (GdkScreen *screen)
+{
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), 0);
+
+  return 0;
+}
+
+
+gchar *
+_gdk_windowing_substitute_screen_number (const gchar *display_name,
+					 int          screen_number)
+{
+  return g_strdup (display_name);
+}
+
+gchar *
+gdk_screen_make_display_name (GdkScreen *screen)
+{
+  return g_strdup ("DirectFB");
+}
+
+gint
+gdk_screen_get_width (GdkScreen *screen)
+{
+  DFBDisplayLayerConfig dlc;
+
+  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+
+  return dlc.width;
+}
+
+gint
+gdk_screen_get_height (GdkScreen *screen)
+{
+  DFBDisplayLayerConfig dlc;
+
+  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+
+  return dlc.height;
+}
+
+gint
+gdk_screen_get_width_mm (GdkScreen *screen)
+{
+  static gboolean first_call = TRUE;
+  DFBDisplayLayerConfig dlc;
+
+  if (first_call)
+    {
+      g_message
+        ("gdk_screen_width_mm() assumes a screen resolution of 72 dpi");
+      first_call = FALSE;
+    }
+
+  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+
+  return (dlc.width * 254) / 720;
+}
+
+gint
+gdk_screen_get_height_mm (GdkScreen *screen)
+{
+  static gboolean first_call = TRUE;
+  DFBDisplayLayerConfig dlc;
+
+  if (first_call)
+    {
+      g_message
+        ("gdk_screen_height_mm() assumes a screen resolution of 72 dpi");
+      first_call = FALSE;
+    }
+
+  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+
+  return (dlc.height * 254) / 720;
+}
+
+GdkVisual *
+gdk_screen_get_rgba_visual (GdkScreen *screen)
+{
+  static GdkVisual *rgba_visual;
+  if( !rgba_visual )
+    rgba_visual = gdk_directfb_visual_by_format(DSPF_ARGB);
+  return rgba_visual;
+}
+
+GdkColormap *
+gdk_screen_get_rgba_colormap (GdkScreen *screen)
+{
+  static GdkColormap *rgba_colormap;
+  if( !rgba_colormap && gdk_screen_get_rgba_visual(screen) )
+    rgba_colormap = gdk_colormap_new (gdk_screen_get_rgba_visual(screen),FALSE);
+  return rgba_colormap;
+}
+
+GdkWindow *
+gdk_screen_get_active_window (GdkScreen *screen)
+{
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);
+
+  return NULL;
+}
+
+GList *
+gdk_screen_get_window_stack (GdkScreen *screen)
+{
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);
+
+  return NULL;
+}
+
+gboolean
+gdk_screen_is_composited (GdkScreen *screen)
+{
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);
+  return FALSE;
+} 
+
+#define __GDK_SCREEN_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkselection-directfb.c gtk+/gdk/directfb/gdkselection-directfb.c
--- old/gdk/directfb/gdkselection-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkselection-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,498 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include "config.h"
+
+#include <string.h>
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkproperty.h"
+#include "gdkselection.h"
+#include "gdkprivate.h"
+#include "gdkalias.h"
+
+
+typedef struct _OwnerInfo OwnerInfo;
+
+struct _OwnerInfo
+{
+  GdkAtom    selection;
+  GdkWindow *owner;
+};
+
+GSList *owner_list = NULL;
+
+/* When a window is destroyed we check if it is the owner
+ * of any selections. This is somewhat inefficient, but
+ * owner_list is typically short, and it is a low memory,
+ * low code solution
+ */
+void
+_gdk_selection_window_destroyed (GdkWindow *window)
+{
+  GSList *tmp_list = owner_list;
+
+  while (tmp_list)
+    {
+      OwnerInfo *info = tmp_list->data;
+
+      tmp_list = tmp_list->next;
+
+      if (info->owner == window)
+	{
+	  owner_list = g_slist_remove (owner_list, info);
+	  g_free (info);
+	}
+    }
+}
+
+gint
+gdk_selection_owner_set_for_display (GdkDisplay *display,
+                                     GdkWindow  *owner,
+                                     GdkAtom     selection,
+                                     guint32     time,
+                                     gint        send_event)
+{
+  GSList    *tmp_list;
+  OwnerInfo *info;
+
+  tmp_list = owner_list;
+  while (tmp_list)
+    {
+      info = tmp_list->data;
+      if (info->selection == selection)
+	{
+	  owner_list = g_slist_remove (owner_list, info);
+	  g_free (info);
+	  break;
+	}
+      tmp_list = tmp_list->next;
+    }
+
+  if (owner)
+    {
+      info = g_new (OwnerInfo, 1);
+      info->owner = owner;
+      info->selection = selection;
+
+      owner_list = g_slist_prepend (owner_list, info);
+    }
+
+  return TRUE;
+}
+
+GdkWindow *
+gdk_selection_owner_get_for_display (GdkDisplay *display,
+                                     GdkAtom     selection)
+{
+  OwnerInfo *info;
+  GSList    *tmp_list;
+
+  tmp_list = owner_list;
+  while (tmp_list)
+    {
+      info = tmp_list->data;
+      if (info->selection == selection)
+	{
+	  return info->owner;
+	}
+      tmp_list = tmp_list->next;
+    }
+  return NULL;
+}
+
+void
+gdk_selection_convert (GdkWindow *requestor,
+		       GdkAtom    selection,
+		       GdkAtom    target,
+		       guint32    time)
+{
+  GdkEvent  *event;
+  GdkWindow *owner;
+  GdkWindow *event_window;
+
+  owner = gdk_selection_owner_get (selection);
+
+  if (owner)
+    {
+      event_window = gdk_directfb_other_event_window (owner,
+                                                      GDK_SELECTION_REQUEST);
+      if (event_window)
+	{
+	  event = gdk_directfb_event_make (event_window,
+                                           GDK_SELECTION_REQUEST);
+	  event->selection.requestor = GDK_WINDOW_DFB_ID (requestor);
+	  event->selection.selection = selection;
+	  event->selection.target    = target;
+	  event->selection.property  = _gdk_selection_property;
+	}
+    }
+  else
+    {
+      /* If no owner for the specified selection exists, the X server
+       * generates a SelectionNotify event to the requestor with property None.
+       */
+      gdk_selection_send_notify (GDK_WINDOW_DFB_ID (requestor),
+				 selection,
+				 target,
+				 GDK_NONE,
+				 0);
+    }
+}
+
+gint
+gdk_selection_property_get (GdkWindow  *requestor,
+			    guchar    **data,
+			    GdkAtom    *ret_type,
+			    gint       *ret_format)
+{
+  guchar *t = NULL;
+  GdkAtom prop_type;
+  gint prop_format;
+  gint prop_len;
+
+  g_return_val_if_fail (requestor != NULL, 0);
+  g_return_val_if_fail (GDK_IS_WINDOW (requestor), 0);
+
+  if (!gdk_property_get (requestor,
+			 _gdk_selection_property,
+			 0/*AnyPropertyType?*/,
+			 0, 0,
+			 FALSE,
+			 &prop_type, &prop_format, &prop_len,
+			 &t))
+    {
+      *data = NULL;
+      return 0;
+    }
+
+  if (ret_type)
+    *ret_type = prop_type;
+  if (ret_format)
+    *ret_format = prop_format;
+
+  if (!gdk_property_get (requestor,
+			 _gdk_selection_property,
+			 0/*AnyPropertyType?*/,
+			 0, prop_len + 1,
+			 FALSE,
+			 &prop_type, &prop_format, &prop_len,
+			 &t))
+    {
+      *data = NULL;
+      return 0;
+    }
+
+  *data = t;
+
+  return prop_len;
+}
+
+
+void
+gdk_selection_send_notify_for_display (GdkDisplay *display,
+                                       guint32     requestor,
+                                       GdkAtom     selection,
+                                       GdkAtom     target,
+                                       GdkAtom     property,
+                                       guint32     time)
+{
+  GdkEvent  *event;
+  GdkWindow *event_window;
+
+  event_window = gdk_window_lookup ((GdkNativeWindow) requestor);
+
+  if (!event_window)
+    return;
+
+  event_window = gdk_directfb_other_event_window (event_window,
+                                                  GDK_SELECTION_NOTIFY);
+
+  if (event_window)
+    {
+      event = gdk_directfb_event_make (event_window, GDK_SELECTION_NOTIFY);
+      event->selection.selection = selection;
+      event->selection.target = target;
+      event->selection.property = property;
+      event->selection.requestor = (GdkNativeWindow) requestor;
+    }
+}
+
+gint
+gdk_text_property_to_text_list_for_display (GdkDisplay      *display,
+                                            GdkAtom          encoding,
+                                            gint             format,
+                                            const guchar    *text,
+                                            gint             length,
+                                            gchar         ***list)
+{
+  g_warning ("gdk_text_property_to_text_list() not implemented\n");
+  return 0;
+}
+
+void
+gdk_free_text_list (gchar **list)
+{
+  g_return_if_fail (list != NULL);
+  g_warning ("gdk_free_text_list() not implemented\n");
+}
+
+gint
+gdk_string_to_compound_text_for_display (GdkDisplay   *display,
+                                         const gchar  *str,
+                                         GdkAtom      *encoding,
+                                         gint         *format,
+                                         guchar      **ctext,
+                                         gint         *length)
+{
+  g_warning ("gdk_string_to_compound_text() not implemented\n");
+  return 0;
+}
+
+void
+gdk_free_compound_text (guchar *ctext)
+{
+  g_warning ("gdk_free_compound_text() not implemented\n");
+}
+
+/**
+ * gdk_utf8_to_string_target:
+ * @str: a UTF-8 string
+ *
+ * Convert an UTF-8 string into the best possible representation
+ * as a STRING. The representation of characters not in STRING
+ * is not specified; it may be as pseudo-escape sequences
+ * \x{ABCD}, or it may be in some other form of approximation.
+ *
+ * Return value: the newly allocated string, or %NULL if the
+ *               conversion failed. (It should not fail for
+ *               any properly formed UTF-8 string.)
+ **/
+gchar *
+gdk_utf8_to_string_target (const gchar *str)
+{
+  g_warning ("gdk_utf8_to_string_target() not implemented\n");
+  return 0;
+}
+
+/**
+ * gdk_utf8_to_compound_text:
+ * @str:      a UTF-8 string
+ * @encoding: location to store resulting encoding
+ * @format:   location to store format of the result
+ * @ctext:    location to store the data of the result
+ * @length:   location to store the length of the data
+ *            stored in @ctext
+ *
+ * Convert from UTF-8 to compound text.
+ *
+ * Return value: %TRUE if the conversion succeeded, otherwise
+ *               false.
+ **/
+gboolean
+gdk_utf8_to_compound_text_for_display (GdkDisplay   *display,
+                                       const gchar  *str,
+                                       GdkAtom      *encoding,
+                                       gint         *format,
+                                       guchar      **ctext,
+                                       gint         *length)
+{
+  g_warning ("gdk_utf8_to_compound_text() not implemented\n");
+  return 0;
+}
+
+static gint
+make_list (const gchar  *text,
+	   gint          length,
+	   gboolean      latin1,
+	   gchar      ***list)
+{
+  GSList *strings = NULL;
+  gint n_strings = 0;
+  gint i;
+  const gchar *p = text;
+  const gchar *q;
+  GSList *tmp_list;
+  GError *error = NULL;
+
+  while (p < text + length)
+    {
+      gchar *str;
+
+      q = p;
+      while (*q && q < text + length)
+	q++;
+
+      if (latin1)
+	{
+	  str = g_convert (p, q - p,
+			   "UTF-8", "ISO-8859-1",
+			   NULL, NULL, &error);
+
+	  if (!str)
+	    {
+	      g_warning ("Error converting selection from STRING: %s",
+			 error->message);
+	      g_error_free (error);
+	    }
+	}
+      else
+	str = g_strndup (p, q - p);
+
+      if (str)
+	{
+	  strings = g_slist_prepend (strings, str);
+	  n_strings++;
+	}
+
+      p = q + 1;
+    }
+
+  if (list)
+    *list = g_new (gchar *, n_strings + 1);
+
+  (*list)[n_strings] = NULL;
+
+  i = n_strings;
+  tmp_list = strings;
+  while (tmp_list)
+    {
+      if (list)
+	(*list)[--i] = tmp_list->data;
+      else
+	g_free (tmp_list->data);
+
+      tmp_list = tmp_list->next;
+    }
+
+  g_slist_free (strings);
+
+  return n_strings;
+}
+
+
+/**
+ * gdk_text_property_to_utf8_list:
+ * @encoding: an atom representing the encoding of the text
+ * @format:   the format of the property
+ * @text:     the text to convert
+ * @length:   the length of @text, in bytes
+ * @list:     location to store the list of strings or %NULL. The
+ *            list should be freed with g_strfreev().
+ *
+ * Convert a text property in the giving encoding to
+ * a list of UTF-8 strings.
+ *
+ * Return value: the number of strings in the resulting
+ *               list.
+ **/
+gint
+gdk_text_property_to_utf8_list_for_display (GdkDisplay     *display,
+                                            GdkAtom         encoding,
+                                            gint            format,
+                                            const guchar   *text,
+                                            gint            length,
+                                            gchar        ***list)
+{
+  g_return_val_if_fail (text != NULL, 0);
+  g_return_val_if_fail (length >= 0, 0);
+
+  if (encoding == GDK_TARGET_STRING)
+    {
+      return make_list ((gchar *)text, length, TRUE, list);
+    }
+  else if (encoding == gdk_atom_intern ("UTF8_STRING", FALSE))
+    {
+      return make_list ((gchar *)text, length, FALSE, list);
+    }
+  else
+    {
+      gchar **local_list;
+      gint local_count;
+      gint i;
+      const gchar *charset = NULL;
+      gboolean need_conversion = !g_get_charset (&charset);
+      gint count = 0;
+      GError *error = NULL;
+
+      /* Probably COMPOUND text, we fall back to Xlib routines
+       */
+      local_count = gdk_text_property_to_text_list (encoding,
+						    format,
+						    text,
+						    length,
+						    &local_list);
+      if (list)
+	*list = g_new (gchar *, local_count + 1);
+
+      for (i = 0; i < local_count; i++)
+	{
+	  /* list contains stuff in our default encoding
+	   */
+	  if (need_conversion)
+	    {
+	      gchar *utf = g_convert (local_list[i], -1,
+				      "UTF-8", charset,
+				      NULL, NULL, &error);
+	      if (utf)
+		{
+		  if (list)
+		    (*list)[count++] = utf;
+		  else
+		    g_free (utf);
+		}
+	      else
+		{
+		  g_warning ("Error converting to UTF-8 from '%s': %s",
+			     charset, error->message);
+		  g_error_free (error);
+		  error = NULL;
+		}
+	    }
+	  else
+	    {
+	      if (list)
+		(*list)[count++] = g_strdup (local_list[i]);
+	    }
+	}
+
+      gdk_free_text_list (local_list);
+      (*list)[count] = NULL;
+
+      return count;
+    }
+}
+
+#define __GDK_SELECTION_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkspawn-directfb.c gtk+/gdk/directfb/gdkspawn-directfb.c
--- old/gdk/directfb/gdkspawn-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkspawn-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2003 Sun Microsystems Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Mark McLoughlin <mark@skynet.ie>
+ */
+
+#include <config.h>
+#include <glib.h>
+#include "gdk.h"
+#include "gdkspawn.h"
+#include "gdkprivate.h"
+#include "gdkalias.h"
+
+
+gboolean
+gdk_spawn_on_screen (GdkScreen             *screen,
+		     const gchar           *working_directory,
+		     gchar                **argv,
+		     gchar                **envp,
+		     GSpawnFlags            flags,
+		     GSpawnChildSetupFunc   child_setup,
+		     gpointer               user_data,
+		     gint                  *child_pid,
+		     GError               **error)
+{
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
+
+  return g_spawn_async (working_directory,
+			argv,
+			envp,
+			flags,
+			child_setup,
+			user_data,
+			child_pid,
+			error);
+}
+
+gboolean
+gdk_spawn_on_screen_with_pipes (GdkScreen            *screen,
+				const gchar          *working_directory,
+				gchar               **argv,
+				gchar               **envp,
+				GSpawnFlags           flags,
+				GSpawnChildSetupFunc  child_setup,
+				gpointer              user_data,
+				gint                 *child_pid,
+				gint                 *standard_input,
+				gint                 *standard_output,
+				gint                 *standard_error,
+				GError              **error)
+{
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), FALSE);
+
+  return g_spawn_async_with_pipes (working_directory,
+				   argv,
+				   envp,
+				   flags,
+				   child_setup,
+				   user_data,
+				   child_pid,
+				   standard_input,
+				   standard_output,
+				   standard_error,
+				   error);
+}
+
+gboolean
+gdk_spawn_command_line_on_screen (GdkScreen    *screen,
+				  const gchar  *command_line,
+				  GError      **error)
+{
+  gchar    **argv = NULL;
+  gboolean   retval;
+
+  g_return_val_if_fail (command_line != NULL, FALSE);
+
+  if (!g_shell_parse_argv (command_line,
+			   NULL, &argv,
+			   error))
+    return FALSE;
+
+  retval = gdk_spawn_on_screen (screen,
+				NULL, argv, NULL,
+				G_SPAWN_SEARCH_PATH,
+				NULL, NULL, NULL,
+				error);
+  g_strfreev (argv);
+
+  return retval;
+}
+
+#define __GDK_SPAWN_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkvisual-directfb.c gtk+/gdk/directfb/gdkvisual-directfb.c
--- old/gdk/directfb/gdkvisual-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkvisual-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,494 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include "config.h"
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkscreen.h"
+#include "gdkvisual.h"
+#include "gdkalias.h"
+
+
+struct _GdkVisualClass
+{
+  GObjectClass parent_class;
+};
+
+
+static void                gdk_visual_decompose_mask  (gulong   mask,
+                                                       gint    *shift,
+                                                       gint    *prec);
+static GdkVisualDirectFB * gdk_directfb_visual_create (DFBSurfacePixelFormat  pixelformat);
+
+
+static DFBSurfacePixelFormat formats[] =
+{
+  DSPF_RGB32,
+  DSPF_ARGB,
+  DSPF_RGB24,
+  DSPF_RGB16,
+  DSPF_ARGB1555,
+  DSPF_LUT8,
+  DSPF_RGB332
+};
+
+static GdkVisual         * system_visual = NULL;
+static GdkVisualDirectFB * visuals[G_N_ELEMENTS (formats) + 1] = { NULL };
+static gint                available_depths[G_N_ELEMENTS (formats) + 1] = {0};
+static GdkVisualType       available_types[G_N_ELEMENTS (formats) + 1]  = {0};
+
+
+static void
+gdk_visual_finalize (GObject *object)
+{
+  g_error ("A GdkVisual object was finalized. This should not happen");
+}
+
+static void
+gdk_visual_class_init (GObjectClass *class)
+{
+  class->finalize = gdk_visual_finalize;
+}
+
+GType
+gdk_visual_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+      {
+        sizeof (GdkVisualClass),
+        (GBaseInitFunc) NULL,
+        (GBaseFinalizeFunc) NULL,
+        (GClassInitFunc) gdk_visual_class_init,
+        NULL,           /* class_finalize */
+        NULL,           /* class_data */
+        sizeof (GdkVisualDirectFB),
+        0,              /* n_preallocs */
+        (GInstanceInitFunc) NULL,
+      };
+
+      object_type = g_type_register_static (G_TYPE_OBJECT,
+                                            "GdkVisual",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+void
+_gdk_visual_init (void)
+{
+  DFBResult              ret;
+  DFBDisplayLayerConfig  dlc;
+  DFBSurfaceDescription  desc;
+  IDirectFBSurface      *dest;
+  gint                   i, c;
+
+  GdkWindowImplDirectFB  *root_impl = GDK_WINDOW_IMPL_DIRECTFB (
+						GDK_WINDOW_OBJECT(_gdk_parent_root)->impl);
+
+  _gdk_display->layer->GetConfiguration (_gdk_display->layer, &dlc);
+  
+  dest = gdk_display_dfb_create_surface(_gdk_display,dlc.pixelformat,8,8);
+  g_assert (dest != NULL);
+
+  /* We could provide all visuals since DirectFB allows us to mix
+     surface formats. Blitting with format conversion can however
+     be incredibly slow, so we've choosen to register only those
+     visuals that can be blitted to the display layer in hardware.
+
+     If you want to use a special pixelformat that is not registered
+     here, you can create it using the DirectFB-specific function
+     gdk_directfb_visual_by_format().
+   */
+  for (i = 0, c = 0; i < G_N_ELEMENTS (formats); i++)
+    {
+      IDirectFBSurface    *src;
+      DFBAccelerationMask  acc;
+
+      desc.flags = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
+      desc.width       = 8;
+      desc.height      = 8;
+      desc.pixelformat = formats[i];
+
+      //call direct so fail silently  is ok
+      if (_gdk_display->directfb->CreateSurface (_gdk_display->directfb,
+	 &desc, &src) != DFB_OK)
+        continue;
+
+      dest->GetAccelerationMask (dest, src, &acc);
+
+      if (acc & DFXL_BLIT)
+        {
+          visuals[c] = gdk_directfb_visual_create (formats[i]);
+
+          if (formats[i] == root_impl->drawable.format)
+            system_visual = GDK_VISUAL (visuals[c]);
+          
+          c++;
+        }
+
+      src->Release (src);
+    }
+
+  dest->Release (dest);
+
+  if (!system_visual)
+    {
+      visuals[c] = gdk_directfb_visual_create (root_impl->drawable.format);
+      system_visual = GDK_VISUAL (visuals[c]);      
+    }
+
+  g_assert (system_visual);
+  /*
+	Now we can set up the system colormap
+  */
+  gdk_drawable_set_colormap (GDK_DRAWABLE (_gdk_parent_root),gdk_colormap_get_system());
+}
+
+gint
+gdk_visual_get_best_depth (void)
+{
+  return system_visual->depth;
+}
+
+GdkVisualType
+gdk_visual_get_best_type (void)
+{
+  return system_visual->type;
+}
+
+GdkVisual*
+gdk_screen_get_system_visual (GdkScreen *screen)
+{
+  return system_visual;
+}
+
+GdkVisual*
+gdk_visual_get_best (void)
+{
+  return system_visual;
+}
+
+GdkVisual*
+gdk_visual_get_best_with_depth (gint depth)
+{
+  gint i;
+
+  for (i = 0; visuals[i]; i++)
+    {
+      GdkVisual *visual = GDK_VISUAL (visuals[i]);
+
+      if (depth == visual->depth)
+        return visual;
+    }
+
+  return NULL;
+}
+
+GdkVisual*
+gdk_visual_get_best_with_type (GdkVisualType visual_type)
+{
+  gint i;
+
+  for (i = 0; visuals[i]; i++)
+    {
+      GdkVisual *visual = GDK_VISUAL (visuals[i]);
+
+      if (visual_type == visual->type)
+        return visual;
+    }
+
+  return NULL;
+}
+
+GdkVisual*
+gdk_visual_get_best_with_both (gint          depth,
+                               GdkVisualType visual_type)
+{
+  gint i;
+
+  for (i = 0; visuals[i]; i++)
+    {
+      GdkVisual *visual = GDK_VISUAL (visuals[i]);
+
+      if (depth == visual->depth && visual_type == visual->type)
+        return visual;
+    }
+
+  return system_visual;
+}
+
+void
+gdk_query_depths (gint **depths,
+                  gint  *count)
+{
+  gint i;
+
+  for (i = 0; available_depths[i]; i++)
+    ;
+
+  *count = i;
+  *depths = available_depths;
+}
+
+void
+gdk_query_visual_types (GdkVisualType **visual_types,
+                        gint           *count)
+{
+  gint i;
+
+  for (i = 0; available_types[i]; i++)
+    ;
+
+  *count = i;
+  *visual_types = available_types;
+}
+
+GList *
+gdk_screen_list_visuals (GdkScreen *screen)
+{
+  GList *list = NULL;
+  gint   i;
+
+  for (i = 0; visuals[i]; i++)
+    list = g_list_append (list, visuals[i]);
+
+  return list;
+}
+
+/**
+ * gdk_directfb_visual_by_format:
+ * @pixel_format: the pixel_format of the requested visual
+ *
+ * This function is specific to the DirectFB backend. It allows
+ * to specify a GdkVisual by @pixel_format.
+ *
+ * At startup, only those visuals that can be blitted
+ * hardware-accelerated are registered.  By using
+ * gdk_directfb_visual_by_format() you can retrieve visuals that
+ * don't match this criteria since this function will try to create
+ * a new visual for the desired @pixel_format for you.
+ *
+ * Return value: a pointer to the GdkVisual or %NULL if the
+ * pixel_format is unsupported.
+ **/
+GdkVisual *
+gdk_directfb_visual_by_format (DFBSurfacePixelFormat pixel_format)
+{
+  gint i;
+
+  /* first check if one the registered visuals matches */
+  for (i = 0; visuals[i]; i++)
+    if (visuals[i]->format == pixel_format)
+      return GDK_VISUAL (visuals[i]);
+
+  /* none matched, try to create a new one for this pixel_format */
+  {
+    DFBSurfaceDescription  desc;
+    IDirectFBSurface      *test;
+
+    desc.flags = DSDESC_WIDTH | DSDESC_HEIGHT | DSDESC_PIXELFORMAT;
+    desc.width       = 8;
+    desc.height      = 8;
+    desc.pixelformat = pixel_format;
+
+    if ( _gdk_display->directfb->CreateSurface ( _gdk_display->directfb, &desc, &test) != DFB_OK)
+      return NULL;
+
+    test->Release (test);
+  }
+
+  visuals[i] = gdk_directfb_visual_create (pixel_format);
+
+  return GDK_VISUAL (visuals[i]);
+}
+
+GdkScreen *
+gdk_visual_get_screen (GdkVisual *visual)
+{
+  g_return_val_if_fail (GDK_IS_VISUAL (visual), NULL);
+
+  return gdk_screen_get_default ();
+}
+
+static void
+gdk_visual_decompose_mask (gulong  mask,
+                           gint   *shift,
+                           gint   *prec)
+{
+  *shift = 0;
+  *prec  = 0;
+
+  while (!(mask & 0x1))
+    {
+      (*shift)++;
+      mask >>= 1;
+    }
+
+  while (mask & 0x1)
+    {
+      (*prec)++;
+      mask >>= 1;
+    }
+}
+
+static GdkVisualDirectFB *
+gdk_directfb_visual_create (DFBSurfacePixelFormat  pixelformat)
+{
+  GdkVisual *visual;
+  gint       i;
+
+  for (i = 0; i < G_N_ELEMENTS (formats); i++)
+    if (formats[i] == pixelformat)
+      break;
+
+  if (i ==  G_N_ELEMENTS (formats))
+    {
+      g_warning ("unsupported pixelformat");
+      return NULL;
+    }
+
+  visual = g_object_new (GDK_TYPE_VISUAL, NULL);
+
+  switch (pixelformat)
+    {
+    case DSPF_LUT8:
+      visual->type         = GDK_VISUAL_PSEUDO_COLOR;
+      visual->bits_per_rgb = 8;
+      break;
+
+    case DSPF_RGB332:
+      visual->type         = GDK_VISUAL_STATIC_COLOR;
+      visual->bits_per_rgb = 3;
+      break;
+
+    case DSPF_ARGB1555:
+      visual->type         = GDK_VISUAL_TRUE_COLOR;
+      visual->red_mask     = 0x00007C00;
+      visual->green_mask   = 0x000003E0;
+      visual->blue_mask    = 0x0000001F;
+      visual->bits_per_rgb = 5;
+      break;
+
+    case DSPF_RGB16:
+      visual->type         = GDK_VISUAL_TRUE_COLOR;
+      visual->red_mask     = 0x0000F800;
+      visual->green_mask   = 0x000007E0;
+      visual->blue_mask    = 0x0000001F;
+      visual->bits_per_rgb = 6;
+      break;
+
+    case DSPF_RGB24:
+    case DSPF_RGB32:
+    case DSPF_ARGB:
+      visual->type         = GDK_VISUAL_TRUE_COLOR;
+      visual->red_mask     = 0x00FF0000;
+      visual->green_mask   = 0x0000FF00;
+      visual->blue_mask    = 0x000000FF;
+      visual->bits_per_rgb = 8;
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  visual->byte_order = GDK_MSB_FIRST;
+#else
+  visual->byte_order = GDK_LSB_FIRST;
+#endif
+
+  visual->depth      = DFB_BITS_PER_PIXEL (pixelformat);
+
+  switch (visual->type)
+    {
+    case GDK_VISUAL_TRUE_COLOR:
+      gdk_visual_decompose_mask (visual->red_mask,
+                                 &visual->red_shift, &visual->red_prec);
+      gdk_visual_decompose_mask (visual->green_mask,
+                                 &visual->green_shift, &visual->green_prec);
+      gdk_visual_decompose_mask (visual->blue_mask,
+                                 &visual->blue_shift, &visual->blue_prec);
+
+      /* the number of possible levels per color component */
+      visual->colormap_size = 1 << MAX (visual->red_prec,
+                                        MAX (visual->green_prec,
+                                             visual->blue_prec));
+      break;
+
+    case GDK_VISUAL_STATIC_COLOR:
+    case GDK_VISUAL_PSEUDO_COLOR:
+      visual->colormap_size = 1 << visual->depth;
+
+      visual->red_mask    = 0;
+      visual->red_shift   = 0;
+      visual->red_prec    = 0;
+
+      visual->green_mask  = 0;
+      visual->green_shift = 0;
+      visual->green_prec  = 0;
+
+      visual->blue_mask   = 0;
+      visual->blue_shift  = 0;
+      visual->blue_prec   = 0;
+
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  ((GdkVisualDirectFB *)visual)->format = pixelformat;
+
+  for (i = 0; available_depths[i]; i++)
+    if (available_depths[i] == visual->depth)
+      break;
+  if (!available_depths[i])
+    available_depths[i] = visual->depth;
+
+  for (i = 0; available_types[i]; i++)
+    if (available_types[i] == visual->type)
+      break;
+  if (!available_types[i])
+    available_types[i] = visual->type;
+
+  return (GdkVisualDirectFB *) visual;
+}
+
+#define __GDK_VISUAL_X11_C__
+#include "gdkaliasdef.c"
diff -ruN old/gdk/directfb/gdkwindow-directfb.c gtk+/gdk/directfb/gdkwindow-directfb.c
--- old/gdk/directfb/gdkwindow-directfb.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkwindow-directfb.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,2519 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ * Copyright (C) 1998-1999 Tor Lillqvist
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include <config.h>
+#include "gdk.h"
+#include "gdkwindow.h"
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+#include "gdkregion-generic.h"
+
+#include "gdkinternals.h"
+#include "gdkalias.h"
+#include "cairo.h"
+
+static GdkRegion * gdk_window_impl_directfb_get_visible_region (GdkDrawable *drawable);
+static void        gdk_window_impl_directfb_set_colormap       (GdkDrawable *drawable,
+                                                                GdkColormap *colormap);
+static void gdk_window_impl_directfb_init       (GdkWindowImplDirectFB      *window);
+static void gdk_window_impl_directfb_class_init (GdkWindowImplDirectFBClass *klass);
+static void gdk_window_impl_directfb_finalize   (GObject                    *object);
+
+typedef struct
+{
+  GdkWindowChildChanged  changed;
+  GdkWindowChildGetPos   get_pos;
+  gpointer               user_data;
+} GdkWindowChildHandlerData;
+
+
+
+static GdkWindow *gdk_directfb_window_containing_pointer = NULL;
+static GdkWindow *gdk_directfb_focused_window            = NULL;
+static gpointer   parent_class                           = NULL;
+GdkWindow * _gdk_parent_root = NULL;
+
+
+GType
+gdk_window_impl_directfb_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (!object_type)
+    {
+      static const GTypeInfo object_info =
+        {
+          sizeof (GdkWindowImplDirectFBClass),
+          (GBaseInitFunc) NULL,
+          (GBaseFinalizeFunc) NULL,
+          (GClassInitFunc) gdk_window_impl_directfb_class_init,
+          NULL,           /* class_finalize */
+          NULL,           /* class_data */
+          sizeof (GdkWindowImplDirectFB),
+          0,              /* n_preallocs */
+          (GInstanceInitFunc) gdk_window_impl_directfb_init,
+        };
+
+      object_type = g_type_register_static (GDK_TYPE_DRAWABLE_IMPL_DIRECTFB,
+                                            "GdkWindowImplDirectFB",
+                                            &object_info, 0);
+    }
+
+  return object_type;
+}
+
+GType
+_gdk_window_impl_get_type (void)
+{
+  return gdk_window_impl_directfb_get_type ();
+}
+
+static void
+gdk_window_impl_directfb_init (GdkWindowImplDirectFB *impl)
+{
+  impl->drawable.width  = 1;
+  impl->drawable.height = 1;
+  //cannot use gdk_cursor_new here since gdk_display_get_default
+  //does not work yet.
+  impl->cursor          = gdk_cursor_new_for_display (GDK_DISPLAY_OBJECT(_gdk_display),GDK_LEFT_PTR);
+  impl->opacity         = 255;
+}
+
+static void
+gdk_window_impl_directfb_class_init (GdkWindowImplDirectFBClass *klass)
+{
+  GObjectClass     *object_class   = G_OBJECT_CLASS (klass);
+  GdkDrawableClass *drawable_class = GDK_DRAWABLE_CLASS (klass);
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = gdk_window_impl_directfb_finalize;
+
+  drawable_class->set_colormap = gdk_window_impl_directfb_set_colormap;
+
+  /* Visible and clip regions are the same */
+
+  drawable_class->get_clip_region =
+    gdk_window_impl_directfb_get_visible_region;
+
+  drawable_class->get_visible_region =
+    gdk_window_impl_directfb_get_visible_region;
+}
+
+static void
+g_free_2nd (gpointer a,
+            gpointer b,
+            gpointer data)
+{
+  g_free (b);
+}
+
+static void
+gdk_window_impl_directfb_finalize (GObject *object)
+{
+  GdkWindowImplDirectFB *impl = GDK_WINDOW_IMPL_DIRECTFB (object);
+
+  if (GDK_WINDOW_IS_MAPPED (impl->drawable.wrapper))
+    gdk_window_hide (impl->drawable.wrapper);
+
+  if (impl->cursor)
+    gdk_cursor_unref (impl->cursor);
+
+  if (impl->properties)
+    {
+      g_hash_table_foreach (impl->properties, g_free_2nd, NULL);
+      g_hash_table_destroy (impl->properties);
+    }
+  if (impl->window)
+    {
+      gdk_directfb_window_id_table_remove (impl->dfb_id);
+	  /* native window resource must be release before we can finalize !*/
+      /*impl->window->Release (impl->window);*/
+      impl->window = NULL;
+    }
+
+  if (G_OBJECT_CLASS (parent_class)->finalize)
+    G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static GdkRegion*
+gdk_window_impl_directfb_get_visible_region (GdkDrawable *drawable)
+{
+  GdkDrawableImplDirectFB *priv = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+  GdkRectangle             rect = { 0, 0, 0, 0 };
+  DFBRectangle             drect = { 0, 0, 0, 0 };
+
+  if (priv->surface)
+    priv->surface->GetVisibleRectangle (priv->surface, &drect);
+  rect.x= drect.x;
+  rect.y= drect.y;
+  rect.width=drect.w;
+  rect.height=drect.h;
+  return gdk_region_rectangle (&rect);
+}
+
+static void
+gdk_window_impl_directfb_set_colormap (GdkDrawable *drawable,
+                                       GdkColormap *colormap)
+{
+  GDK_DRAWABLE_CLASS (parent_class)->set_colormap (drawable, colormap);
+
+  if (colormap)
+    {
+       GdkDrawableImplDirectFB *priv = GDK_DRAWABLE_IMPL_DIRECTFB (drawable);
+
+       if (priv->surface)
+	 {
+	   IDirectFBPalette *palette = gdk_directfb_colormap_get_palette (colormap);
+
+           if (palette)
+             priv->surface->SetPalette (priv->surface, palette);
+         }
+    }
+}
+
+
+static gboolean
+create_directfb_window (GdkWindowImplDirectFB *impl,
+                        DFBWindowDescription  *desc,
+                        DFBWindowOptions       window_options)
+{
+  DFBResult        ret;
+  IDirectFBWindow *window;
+
+  ret = _gdk_display->layer->CreateWindow (_gdk_display->layer, desc, &window);
+
+  if (ret != DFB_OK)
+    {
+      DirectFBError ("gdk_window_new: Layer->CreateWindow failed", ret);
+      return FALSE;
+    }
+
+  if ((desc->flags & DWDESC_CAPS) && (desc->caps & DWCAPS_INPUTONLY))
+    impl->drawable.surface = NULL;
+  else
+    window->GetSurface (window, &impl->drawable.surface);
+
+  if (window_options)
+    {
+      DFBWindowOptions options;
+      window->GetOptions (window, &options);
+      window->SetOptions (window,  options | window_options);
+    }
+
+  impl->window = window;
+
+  return TRUE;
+}
+
+void
+_gdk_windowing_window_init (void)
+{
+  GdkWindowObject       *private;
+  GdkWindowImplDirectFB *impl;
+  DFBDisplayLayerConfig  dlc;
+
+  g_assert (_gdk_parent_root == NULL);
+
+  _gdk_display->layer->GetConfiguration( 
+	_gdk_display->layer, &dlc );
+
+  _gdk_parent_root = g_object_new (GDK_TYPE_WINDOW, NULL);
+  private = GDK_WINDOW_OBJECT (_gdk_parent_root);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  private->window_type = GDK_WINDOW_ROOT;
+  private->state       = 0;
+  private->children    = NULL;
+
+  impl->window           = NULL;
+  impl->drawable.abs_x   = 0;
+  impl->drawable.abs_y   = 0;
+  impl->drawable.width   = dlc.width;
+  impl->drawable.height  = dlc.height;
+  impl->drawable.wrapper = GDK_DRAWABLE (private);
+  /* custom root window init */
+  {
+    DFBWindowDescription   desc;
+    desc.flags = 0;
+	/*XXX I must do this now its a bug  ALPHA ROOT*/
+#if 1 
+    desc.flags |= DWDESC_CAPS;
+    desc.caps = DWCAPS_ALPHACHANNEL;
+#endif
+    desc.flags |= ( DWDESC_WIDTH | DWDESC_HEIGHT |
+                      DWDESC_POSX  | DWDESC_POSY );
+    desc.posx   = 0;
+    desc.posy   = 0;
+    desc.width  = dlc.width;
+    desc.height = dlc.height;
+    create_directfb_window (impl,&desc,0);
+	g_assert(impl->window != NULL);
+    g_assert(impl->drawable.surface != NULL );
+  }
+  impl->drawable.surface->GetPixelFormat(impl->drawable.surface,&impl->drawable.format); 
+  private->depth = DFB_BITS_PER_PIXEL(impl->drawable.format);
+}
+
+
+
+GdkWindow *
+gdk_directfb_window_new (GdkWindow              *parent,
+                         GdkWindowAttr          *attributes,
+                         gint                    attributes_mask,
+                         DFBWindowCapabilities   window_caps,
+                         DFBWindowOptions        window_options,
+                         DFBSurfaceCapabilities  surface_caps)
+{
+  GdkWindow             *window;
+  GdkWindowObject       *private;
+  GdkWindowObject       *parent_private;
+  GdkWindowImplDirectFB *impl;
+  GdkWindowImplDirectFB *parent_impl;
+  GdkVisual             *visual;
+  DFBWindowDescription   desc;
+  gint x, y;
+
+  g_return_val_if_fail (attributes != NULL, NULL);
+
+  if (!parent || attributes->window_type != GDK_WINDOW_CHILD)
+    parent = _gdk_parent_root;
+
+  window = g_object_new (GDK_TYPE_WINDOW, NULL);
+  private = GDK_WINDOW_OBJECT (window);
+
+  parent_private = GDK_WINDOW_OBJECT (parent);
+  parent_impl = GDK_WINDOW_IMPL_DIRECTFB (parent_private->impl);
+  private->parent = parent_private;
+
+  x = (attributes_mask & GDK_WA_X) ? attributes->x : 0;
+  y = (attributes_mask & GDK_WA_Y) ? attributes->y : 0;
+
+  gdk_window_set_events (window, attributes->event_mask | GDK_STRUCTURE_MASK);
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+  impl->drawable.wrapper = GDK_DRAWABLE (window);
+
+  private->x = x;
+  private->y = y;
+
+  _gdk_directfb_calc_abs (window);
+
+  impl->drawable.width  = MAX (1, attributes->width);
+  impl->drawable.height = MAX (1, attributes->height);
+
+  private->window_type = attributes->window_type;
+
+  desc.flags = 0;
+
+  if (attributes_mask & GDK_WA_VISUAL)
+    visual = attributes->visual;
+  else
+    visual = gdk_drawable_get_visual (parent);
+
+  switch (attributes->wclass)
+    {
+    case GDK_INPUT_OUTPUT:
+      private->input_only = FALSE;
+
+      desc.flags |= DWDESC_PIXELFORMAT;
+      desc.pixelformat = ((GdkVisualDirectFB *) visual)->format;
+
+      if (DFB_PIXELFORMAT_HAS_ALPHA (desc.pixelformat))
+        {
+          desc.flags |= DWDESC_CAPS;
+          desc.caps = DWCAPS_ALPHACHANNEL;
+        }
+      break;
+
+    case GDK_INPUT_ONLY:
+      private->input_only = TRUE;
+      desc.flags |= DWDESC_CAPS;
+      desc.caps = DWCAPS_INPUTONLY;
+      break;
+
+    default:
+      g_warning ("gdk_window_new: unsupported window class\n");
+      _gdk_window_destroy (window, FALSE);
+      return NULL;
+    }
+
+  switch (private->window_type)
+    {
+    case GDK_WINDOW_TOPLEVEL:
+    case GDK_WINDOW_DIALOG:
+    case GDK_WINDOW_TEMP:
+      desc.flags |= ( DWDESC_WIDTH | DWDESC_HEIGHT |
+                      DWDESC_POSX  | DWDESC_POSY );
+      desc.posx   = x;
+      desc.posy   = y;
+      desc.width  = impl->drawable.width;
+      desc.height = impl->drawable.height;
+#if 0
+      if (window_caps)
+        {
+          if (! (desc.flags & DWDESC_CAPS))
+            {
+              desc.flags |= DWDESC_CAPS;
+              desc.caps   = DWCAPS_NONE;
+            }
+
+          desc.caps |= window_caps;
+        }
+
+      if (surface_caps)
+        {
+          desc.flags |= DWDESC_SURFACE_CAPS;
+          desc.surface_caps = surface_caps;
+        }
+#endif
+
+      if (!create_directfb_window (impl, &desc, window_options))
+        {
+		  g_assert(0);
+          _gdk_window_destroy (window, FALSE);
+          return NULL;
+        }
+      	if( desc.caps != DWCAPS_INPUTONLY )
+			impl->window->SetOpacity(impl->window, 0x00 );
+      break;
+
+    case GDK_WINDOW_CHILD:
+	   impl->window=NULL;
+      if (!private->input_only && parent_impl->drawable.surface)
+        {
+          DFBRectangle rect =
+          { x, y, impl->drawable.width, impl->drawable.height };
+
+          parent_impl->drawable.surface->GetSubSurface (parent_impl->drawable.surface,
+                                                        &rect,
+                                                        &impl->drawable.surface);
+        }
+      break;
+
+    default:
+      g_warning ("gdk_window_new: unsupported window type: %d",
+                 private->window_type);
+      _gdk_window_destroy (window, FALSE);
+      return NULL;
+    }
+
+  if (impl->drawable.surface)
+    {
+      GdkColormap *colormap;
+
+      impl->drawable.surface->GetPixelFormat (impl->drawable.surface,
+					      &impl->drawable.format);
+
+  	  private->depth = DFB_BITS_PER_PIXEL(impl->drawable.format);
+
+      if ((attributes_mask & GDK_WA_COLORMAP) && attributes->colormap)
+	{
+	  colormap = attributes->colormap;
+	}
+      else
+	{
+	  if (gdk_visual_get_system () == visual)
+	    colormap = gdk_colormap_get_system ();
+	  else
+	    colormap =gdk_drawable_get_colormap (parent);
+	}
+
+      gdk_drawable_set_colormap (GDK_DRAWABLE (window), colormap);
+    }
+  else
+    {
+      impl->drawable.format = ((GdkVisualDirectFB *)visual)->format;
+  	  private->depth = visual->depth;
+    }
+
+  gdk_window_set_cursor (window, ((attributes_mask & GDK_WA_CURSOR) ?
+                                  (attributes->cursor) : NULL));
+
+  if (parent_private)
+    parent_private->children = g_list_prepend (parent_private->children,
+                                               window);
+
+  /* we hold a reference count on ourselves */
+  g_object_ref (window);
+
+  if (impl->window)
+    {
+      impl->window->GetID (impl->window, &impl->dfb_id);
+      gdk_directfb_window_id_table_insert (impl->dfb_id, window);
+      gdk_directfb_event_windows_add (window);
+    }
+
+  return window;
+}
+
+GdkWindow *
+gdk_window_new (GdkWindow     *parent,
+                GdkWindowAttr *attributes,
+                gint           attributes_mask)
+{
+  g_return_val_if_fail (attributes != NULL, NULL);
+
+  return gdk_directfb_window_new (parent, attributes, attributes_mask,
+                                  DWCAPS_NONE, DWOP_NONE, DSCAPS_NONE);
+}
+void
+_gdk_windowing_window_destroy_foreign (GdkWindow *window)
+{
+  /* It's somebody else's window, but in our heirarchy,
+   * so reparent it to the root window, and then send
+   * it a delete event, as if we were a WM
+   */
+	_gdk_windowing_window_destroy (window,TRUE,TRUE);
+}
+
+
+void
+_gdk_windowing_window_destroy (GdkWindow *window,
+                               gboolean   recursing,
+                               gboolean   foreign_destroy)
+{
+  GdkWindowObject       *private;
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  _gdk_selection_window_destroyed (window);
+
+  if (window == _gdk_directfb_pointer_grab_window)
+    gdk_pointer_ungrab (GDK_CURRENT_TIME);
+  if (window == _gdk_directfb_keyboard_grab_window)
+    gdk_keyboard_ungrab (GDK_CURRENT_TIME);
+
+  if (window == gdk_directfb_focused_window)
+    gdk_directfb_change_focus (NULL);
+
+/*
+printf( " DESTROYING WINDOW %p %p %d parent=%p\n",window,impl->window,recursing,(GDK_WINDOW_OBJECT (window))->parent);
+*/
+  if (!recursing && !foreign_destroy && impl->window ) {
+    	impl->window->SetOpacity (impl->window,0);
+   		impl->window->Close(impl->window);
+      	impl->window->Release(impl->window);
+  }
+
+#if 0 /* let the finalizer kill it */
+  if (!recursing && !foreign_destroy)
+    {
+  		if (impl->window)
+    		impl->window->Destroy (impl->window);
+  		impl->window = NULL;
+	}
+#endif
+}
+
+/* This function is called when the window is really gone.
+ */
+void
+gdk_window_destroy_notify (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (!GDK_WINDOW_DESTROYED (window))
+    {
+      if (GDK_WINDOW_TYPE(window) != GDK_WINDOW_FOREIGN)
+	g_warning ("GdkWindow %p unexpectedly destroyed", window);
+
+      _gdk_window_destroy (window, TRUE);
+    }
+   g_object_unref (window);
+}
+
+/* Focus follows pointer */
+GdkWindow *
+gdk_directfb_window_find_toplevel (GdkWindow *window)
+{
+  while (window && window != _gdk_parent_root)
+    {
+      GdkWindow *parent = (GdkWindow *) (GDK_WINDOW_OBJECT (window))->parent;
+
+      if ((parent == _gdk_parent_root) && GDK_WINDOW_IS_MAPPED (window))
+        return window;
+
+      window = parent;
+    }
+
+  return _gdk_parent_root;
+}
+
+GdkWindow *
+gdk_directfb_window_find_focus (void)
+{
+  if (_gdk_directfb_keyboard_grab_window)
+    return _gdk_directfb_keyboard_grab_window;
+
+  if (!gdk_directfb_focused_window)
+    gdk_directfb_focused_window = g_object_ref (_gdk_parent_root);
+
+  return gdk_directfb_focused_window;
+}
+
+void
+gdk_directfb_change_focus (GdkWindow *new_focus_window)
+{
+  GdkEventFocus *event;
+  GdkWindow     *old_win;
+  GdkWindow     *new_win;
+  GdkWindow     *event_win;
+
+
+  /* No focus changes while the pointer is grabbed */
+  if (_gdk_directfb_pointer_grab_window)
+    return;
+
+  old_win = gdk_directfb_focused_window;
+  new_win = gdk_directfb_window_find_toplevel (new_focus_window);
+
+  if (old_win == new_win)
+    return;
+
+  if (old_win)
+    {
+      event_win = gdk_directfb_keyboard_event_window (old_win,
+                                                      GDK_FOCUS_CHANGE);
+      if (event_win)
+        {
+          event = (GdkEventFocus *) gdk_directfb_event_make (event_win,
+                                                             GDK_FOCUS_CHANGE);
+          event->in = FALSE;
+        }
+    }
+
+  event_win = gdk_directfb_keyboard_event_window (new_win,
+                                                  GDK_FOCUS_CHANGE);
+  if (event_win)
+    {
+      event = (GdkEventFocus *) gdk_directfb_event_make (event_win,
+                                                         GDK_FOCUS_CHANGE);
+      event->in = TRUE;
+    }
+
+  if (gdk_directfb_focused_window)
+    g_object_unref (gdk_directfb_focused_window);
+  gdk_directfb_focused_window = g_object_ref (new_win);
+}
+
+void
+gdk_window_set_accept_focus (GdkWindow *window,
+                             gboolean accept_focus)
+{
+  GdkWindowObject *private;
+  g_return_if_fail (window != NULL);
+  g_return_if_fail (GDK_IS_WINDOW (window));
+                                                                                                                      
+  private = (GdkWindowObject *)window;
+                                                                                                                      
+  accept_focus = accept_focus != FALSE;
+                                                                                                                      
+  if (private->accept_focus != accept_focus)
+    private->accept_focus = accept_focus;
+
+}
+
+void
+gdk_window_set_focus_on_map (GdkWindow *window,
+                             gboolean focus_on_map)
+{
+  GdkWindowObject *private;
+  g_return_if_fail (window != NULL);
+  g_return_if_fail (GDK_IS_WINDOW (window));
+                                                                                                                      
+  private = (GdkWindowObject *)window;
+                                                                                                                      
+  focus_on_map = focus_on_map != FALSE;
+                                                                                                                      
+  if (private->focus_on_map != focus_on_map)
+    private->focus_on_map = focus_on_map;
+}
+
+static gboolean
+gdk_directfb_window_raise (GdkWindow *window)
+{
+  GdkWindowObject *parent;
+
+  parent = GDK_WINDOW_OBJECT (window)->parent;
+
+  if (parent->children->data == window)
+    return FALSE;
+
+  parent->children = g_list_remove (parent->children, window);
+  parent->children = g_list_prepend (parent->children, window);
+
+  return TRUE;
+}
+
+static void
+gdk_directfb_window_lower (GdkWindow *window)
+{
+  GdkWindowObject *parent;
+
+  parent = GDK_WINDOW_OBJECT (window)->parent;
+
+  parent->children = g_list_remove (parent->children, window);
+  parent->children = g_list_append (parent->children, window);
+}
+
+static gboolean
+all_parents_shown (GdkWindowObject *private)
+{
+  while (GDK_WINDOW_IS_MAPPED (private))
+    {
+      if (private->parent)
+        private = GDK_WINDOW_OBJECT (private)->parent;
+      else
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static void
+send_map_events (GdkWindowObject *private)
+{
+  GList     *list;
+  GdkWindow *event_win;
+
+  if (!GDK_WINDOW_IS_MAPPED (private))
+    return;
+
+  event_win = gdk_directfb_other_event_window ((GdkWindow *) private, GDK_MAP);
+  if (event_win)
+    gdk_directfb_event_make (event_win, GDK_MAP);
+
+  for (list = private->children; list; list = list->next)
+    send_map_events (list->data);
+}
+
+static GdkWindow *
+gdk_directfb_find_common_ancestor (GdkWindow *win1,
+                                   GdkWindow *win2)
+{
+  GdkWindowObject *a;
+  GdkWindowObject *b;
+
+  for (a = GDK_WINDOW_OBJECT (win1); a; a = a->parent)
+    for (b = GDK_WINDOW_OBJECT (win2); b; b = b->parent)
+      {
+        if (a == b)
+          return GDK_WINDOW (a);
+      }
+
+  return NULL;
+}
+
+void
+gdk_directfb_window_send_crossing_events (GdkWindow       *src,
+                                          GdkWindow       *dest,
+                                          GdkCrossingMode  mode)
+{
+  GdkWindow       *c;
+  GdkWindow       *win, *last, *next;
+  GdkEvent        *event;
+  gint             x, y, x_int, y_int;
+  GdkModifierType  modifiers;
+  GSList          *path, *list;
+  gboolean         non_linear;
+  GdkWindow       *a;
+  GdkWindow       *b;
+  GdkWindow       *event_win;
+
+  /* Do a possible cursor change before checking if we need to
+     generate crossing events so cursor changes due to pointer
+     grabs work correctly. */
+  {
+    static GdkCursorDirectFB *last_cursor = NULL;
+
+    GdkWindowObject       *private = GDK_WINDOW_OBJECT (dest);
+    GdkWindowImplDirectFB *impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+    GdkCursorDirectFB     *cursor;
+
+    if (_gdk_directfb_pointer_grab_cursor)
+      cursor = (GdkCursorDirectFB*) _gdk_directfb_pointer_grab_cursor;
+    else
+      cursor = (GdkCursorDirectFB*) impl->cursor;
+
+    if (cursor != last_cursor)
+      {
+        win     = gdk_directfb_window_find_toplevel (dest);
+        private = GDK_WINDOW_OBJECT (win);
+        impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+        if (impl->window)
+          impl->window->SetCursorShape (impl->window,
+                                        cursor->shape,
+                                        cursor->hot_x, cursor->hot_y);
+        last_cursor = cursor;
+      }
+  }
+
+  if (dest == gdk_directfb_window_containing_pointer)
+    return;
+
+  if (gdk_directfb_window_containing_pointer == NULL)
+    gdk_directfb_window_containing_pointer = g_object_ref (_gdk_parent_root);
+
+  if (src)
+    a = src;
+  else
+    a = gdk_directfb_window_containing_pointer;
+
+  b = dest;
+
+  if (a == b)
+    return;
+
+  /* gdk_directfb_window_containing_pointer might have been destroyed.
+   * The refcount we hold on it should keep it, but it's parents
+   * might have died.
+   */
+  if (GDK_WINDOW_DESTROYED (a))
+    a = _gdk_parent_root;
+
+  gdk_directfb_mouse_get_info (&x, &y, &modifiers);
+
+  c = gdk_directfb_find_common_ancestor (a, b);
+
+  non_linear = (c != a) && (c != b);
+
+  event_win = gdk_directfb_pointer_event_window (a, GDK_LEAVE_NOTIFY);
+  if (event_win)
+    {
+      event = gdk_directfb_event_make (event_win, GDK_LEAVE_NOTIFY);
+      event->crossing.subwindow = NULL;
+
+      gdk_window_get_origin (a, &x_int, &y_int);
+
+      event->crossing.x      = x - x_int;
+      event->crossing.y      = y - y_int;
+      event->crossing.x_root = x;
+      event->crossing.y_root = y;
+      event->crossing.mode   = mode;
+
+      if (non_linear)
+        event->crossing.detail = GDK_NOTIFY_NONLINEAR;
+      else if (c == a)
+        event->crossing.detail = GDK_NOTIFY_INFERIOR;
+      else
+        event->crossing.detail = GDK_NOTIFY_ANCESTOR;
+
+      event->crossing.focus = FALSE;
+      event->crossing.state = modifiers;
+    }
+
+   /* Traverse up from a to (excluding) c */
+  if (c != a)
+    {
+      last = a;
+      win = GDK_WINDOW (GDK_WINDOW_OBJECT (a)->parent);
+      while (win != c)
+        {
+          event_win =
+            gdk_directfb_pointer_event_window (win, GDK_LEAVE_NOTIFY);
+
+          if (event_win)
+            {
+              event = gdk_directfb_event_make (event_win, GDK_LEAVE_NOTIFY);
+
+              event->crossing.subwindow = g_object_ref (last);
+
+              gdk_window_get_origin (win, &x_int, &y_int);
+
+              event->crossing.x      = x - x_int;
+              event->crossing.y      = y - y_int;
+              event->crossing.x_root = x;
+              event->crossing.y_root = y;
+              event->crossing.mode   = mode;
+
+              if (non_linear)
+                event->crossing.detail = GDK_NOTIFY_NONLINEAR_VIRTUAL;
+              else
+                event->crossing.detail = GDK_NOTIFY_VIRTUAL;
+
+              event->crossing.focus = FALSE;
+              event->crossing.state = modifiers;
+            }
+
+          last = win;
+          win = GDK_WINDOW (GDK_WINDOW_OBJECT (win)->parent);
+        }
+    }
+
+  /* Traverse down from c to b */
+  if (c != b)
+    {
+      path = NULL;
+      win = GDK_WINDOW (GDK_WINDOW_OBJECT (b)->parent);
+      while (win != c)
+        {
+          path = g_slist_prepend (path, win);
+          win = GDK_WINDOW (GDK_WINDOW_OBJECT (win)->parent);
+        }
+
+      list = path;
+      while (list)
+        {
+          win = GDK_WINDOW (list->data);
+          list = g_slist_next (list);
+
+          if (list)
+            next = GDK_WINDOW (list->data);
+          else
+            next = b;
+
+          event_win =
+            gdk_directfb_pointer_event_window (win, GDK_ENTER_NOTIFY);
+
+          if (event_win)
+            {
+              event = gdk_directfb_event_make (event_win, GDK_ENTER_NOTIFY);
+
+              event->crossing.subwindow = g_object_ref (next);
+
+              gdk_window_get_origin (win, &x_int, &y_int);
+
+              event->crossing.x      = x - x_int;
+              event->crossing.y      = y - y_int;
+              event->crossing.x_root = x;
+              event->crossing.y_root = y;
+              event->crossing.mode   = mode;
+
+              if (non_linear)
+                event->crossing.detail = GDK_NOTIFY_NONLINEAR_VIRTUAL;
+              else
+                event->crossing.detail = GDK_NOTIFY_VIRTUAL;
+
+              event->crossing.focus = FALSE;
+              event->crossing.state = modifiers;
+            }
+        }
+
+      g_slist_free (path);
+    }
+
+  event_win = gdk_directfb_pointer_event_window (b, GDK_ENTER_NOTIFY);
+  if (event_win)
+    {
+      event = gdk_directfb_event_make (event_win, GDK_ENTER_NOTIFY);
+
+      event->crossing.subwindow = NULL;
+
+      gdk_window_get_origin (b, &x_int, &y_int);
+
+      event->crossing.x      = x - x_int;
+      event->crossing.y      = y - y_int;
+      event->crossing.x_root = x;
+      event->crossing.y_root = y;
+      event->crossing.mode   = mode;
+
+      if (non_linear)
+        event->crossing.detail = GDK_NOTIFY_NONLINEAR;
+      else if (c==a)
+        event->crossing.detail = GDK_NOTIFY_ANCESTOR;
+      else
+        event->crossing.detail = GDK_NOTIFY_INFERIOR;
+
+      event->crossing.focus = FALSE;
+      event->crossing.state = modifiers;
+    }
+
+  if (mode != GDK_CROSSING_GRAB)
+    {
+      //this seems to cause focus to change as the pointer moves yuck
+      //gdk_directfb_change_focus (b);
+      if (b != gdk_directfb_window_containing_pointer)
+        {
+          g_object_unref (gdk_directfb_window_containing_pointer);
+          gdk_directfb_window_containing_pointer = g_object_ref (b);
+        }
+    }
+}
+
+static void
+show_window_internal (GdkWindow *window,
+                      gboolean   raise)
+{
+  GdkWindowObject       *private;
+  GdkWindowImplDirectFB *impl;
+  GdkWindow             *mousewin;
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  if (!private->destroyed && !GDK_WINDOW_IS_MAPPED (private))
+    {
+      private->state &= ~GDK_WINDOW_STATE_WITHDRAWN;
+
+      if (raise)
+        gdk_window_raise (window);
+
+      if (all_parents_shown (GDK_WINDOW_OBJECT (private)->parent))
+        {
+          send_map_events (private);
+
+          mousewin = gdk_window_at_pointer (NULL, NULL);
+          gdk_directfb_window_send_crossing_events (NULL, mousewin,
+                                                    GDK_CROSSING_NORMAL);
+
+          if (private->input_only)
+            return;
+
+          gdk_window_invalidate_rect (window, NULL, TRUE);
+        }
+    }
+
+  if (impl->window)
+    {
+      if (gdk_directfb_apply_focus_opacity)
+	impl->window->SetOpacity (impl->window,
+				  (impl->opacity >> 1) + (impl->opacity >> 2));
+      else
+	impl->window->SetOpacity (impl->window, impl->opacity);
+	  /* if its the first window focus it */
+    }
+}
+
+void
+gdk_window_show_unraised (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  show_window_internal (window, FALSE);
+}
+
+void
+gdk_window_show (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  show_window_internal (window, TRUE);
+}
+
+void
+gdk_window_hide (GdkWindow *window)
+{
+  GdkWindowObject       *private;
+  GdkWindowImplDirectFB *impl;
+  GdkWindow             *mousewin;
+  GdkWindow             *event_win;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  if (impl->window)
+    impl->window->SetOpacity (impl->window, 0);
+
+  if (!private->destroyed && GDK_WINDOW_IS_MAPPED (private))
+    {
+      GdkEvent *event;
+
+      private->state |= GDK_WINDOW_STATE_WITHDRAWN;
+
+      if (!private->input_only && private->parent)
+        {
+          _gdk_windowing_window_clear_area (GDK_WINDOW (private->parent),
+                                            private->x,
+                                            private->y,
+                                            impl->drawable.width,
+                                            impl->drawable.height);
+        }
+
+      event_win = gdk_directfb_other_event_window (window, GDK_UNMAP);
+      if (event_win)
+        event = gdk_directfb_event_make (event_win, GDK_UNMAP);
+
+      mousewin = gdk_window_at_pointer (NULL, NULL);
+      gdk_directfb_window_send_crossing_events (NULL,
+                                                mousewin,
+                                                GDK_CROSSING_NORMAL);
+
+      if (window == _gdk_directfb_pointer_grab_window)
+        gdk_pointer_ungrab (GDK_CURRENT_TIME);
+      if (window == _gdk_directfb_keyboard_grab_window)
+        gdk_keyboard_ungrab (GDK_CURRENT_TIME);
+    }
+}
+
+void
+gdk_window_withdraw (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  /* for now this should be enough */
+  gdk_window_hide (window);
+}
+
+void
+gdk_window_move (GdkWindow *window,
+                 gint       x,
+                 gint       y)
+{
+  GdkWindowObject       *private;
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  if (impl->window)
+    {
+  	  private->x = x;
+  	  private->y = y;
+      impl->window->MoveTo (impl->window, x, y);
+    }
+  else
+    {
+	  gint width=impl->drawable.width;
+	  gint height=impl->drawable.height;
+      GdkRectangle  old =
+      { private->x, private->y,width,height };
+
+      _gdk_directfb_move_resize_child (window, x, y, width, height);
+      _gdk_directfb_calc_abs (window);
+
+      if (GDK_WINDOW_IS_MAPPED (private))
+        {
+          GdkWindow    *mousewin;
+          GdkRectangle  new = { x, y, width, height };
+
+          gdk_rectangle_union (&new, &old, &new);
+          gdk_window_invalidate_rect (GDK_WINDOW (private->parent), &new,TRUE);
+
+          /* The window the pointer is in might have changed */
+          mousewin = gdk_window_at_pointer (NULL, NULL);
+          gdk_directfb_window_send_crossing_events (NULL, mousewin,
+                                                    GDK_CROSSING_NORMAL);
+        }
+    }
+}
+
+void
+gdk_window_resize (GdkWindow *window,
+                   gint       width,
+                   gint       height)
+{
+  GdkWindowObject *private;
+  gint             x, y;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+
+  x = private->x;
+  y = private->y;
+
+  if (private->parent && (private->parent->window_type != GDK_WINDOW_CHILD))
+    {
+      GdkWindowChildHandlerData *data;
+
+      data = g_object_get_data (G_OBJECT (private->parent),
+				"gdk-window-child-handler");
+
+      if (data)
+	(*data->get_pos) (window, &x, &y, data->user_data);
+    }
+
+  gdk_window_move_resize (window, x, y, width, height);
+}
+
+void
+_gdk_directfb_move_resize_child (GdkWindow *window,
+                                 gint       x,
+                                 gint       y,
+                                 gint       width,
+                                 gint       height)
+{
+  GdkWindowObject       *private;
+  GdkWindowImplDirectFB *impl;
+  GdkWindowImplDirectFB *parent_impl;
+  GList                 *list;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  private->x = x;
+  private->y = y;
+
+  impl->drawable.width  = width;
+  impl->drawable.height = height;
+
+  if (!private->input_only)
+    {
+      if (impl->drawable.surface)
+        {
+          impl->drawable.surface->Release (impl->drawable.surface);
+          impl->drawable.surface = NULL;
+        }
+
+      parent_impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (private->parent)->impl);
+
+      if (parent_impl->drawable.surface)
+        {
+          DFBRectangle rect = { x, y, width, height };
+
+          parent_impl->drawable.surface->GetSubSurface (parent_impl->drawable.surface,
+                                                        &rect,
+                                                        &impl->drawable.surface);
+        }
+    }
+
+  for (list = private->children; list; list = list->next)
+    {
+      private = GDK_WINDOW_OBJECT (list->data);
+  	  impl  = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+      _gdk_directfb_move_resize_child (list->data,
+                                       private->x, private->y,
+                                       impl->drawable.width, impl->drawable.height);
+    }
+}
+
+void
+gdk_window_move_resize (GdkWindow *window,
+                        gint       x,
+                        gint       y,
+                        gint       width,
+                        gint       height)
+{
+  GdkWindowObject       *private;
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  if (width < 1)
+     width = 1;
+  if (height < 1)
+    height = 1;
+
+  if (private->destroyed ||
+      (private->x == x  &&  private->y == y  &&
+       impl->drawable.width == width  &&  impl->drawable.height == height))
+    return;
+
+  if (private->parent && (private->parent->window_type != GDK_WINDOW_CHILD))
+    {
+      GdkWindowChildHandlerData *data;
+
+      data = g_object_get_data (G_OBJECT (private->parent),
+                                "gdk-window-child-handler");
+
+      if (data &&
+          (*data->changed) (window, x, y, width, height, data->user_data))
+        return;
+    }
+
+  if (impl->drawable.width == width  &&  impl->drawable.height == height)
+    {
+      gdk_window_move (window, x, y);
+    }
+  else if (impl->window)
+    {
+  	  private->x = x;
+  	  private->y = y;
+      impl->window->MoveTo (impl->window, x, y);
+      impl->window->Resize (impl->window, width, height);
+    }
+  else
+    {
+      GdkRectangle  old =
+      { private->x, private->y, impl->drawable.width, impl->drawable.height };
+      _gdk_directfb_move_resize_child (window, x, y, width, height);
+      _gdk_directfb_calc_abs (window);
+
+      if (GDK_WINDOW_IS_MAPPED (private))
+        {
+          GdkWindow    *mousewin;
+          GdkRectangle  new = { x, y, width, height };
+
+          gdk_rectangle_union (&new, &old, &new);
+          gdk_window_invalidate_rect (GDK_WINDOW (private->parent), &new,TRUE);
+
+          /* The window the pointer is in might have changed */
+          mousewin = gdk_window_at_pointer (NULL, NULL);
+          gdk_directfb_window_send_crossing_events (NULL, mousewin,
+                                                    GDK_CROSSING_NORMAL);
+        }
+    }
+}
+
+void
+gdk_window_reparent (GdkWindow *window,
+                     GdkWindow *new_parent,
+                     gint       x,
+                     gint       y)
+{
+  GdkWindowObject *window_private;
+  GdkWindowObject *parent_private;
+  GdkWindowObject *old_parent_private;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  if (!new_parent)
+    new_parent = _gdk_parent_root;
+
+  window_private = (GdkWindowObject *) window;
+  old_parent_private = (GdkWindowObject *) window_private->parent;
+  parent_private = (GdkWindowObject *) new_parent;
+
+  window_private->parent = (GdkWindowObject *) new_parent;
+
+  if (old_parent_private)
+    {
+      old_parent_private->children =
+        g_list_remove (old_parent_private->children, window);
+    }
+
+  parent_private->children = g_list_prepend (parent_private->children, window);
+
+  gdk_window_move_resize (window, x, y, -1, -1);
+}
+
+void
+_gdk_windowing_window_clear_area (GdkWindow *window,
+                                  gint       x,
+                                  gint       y,
+                                  gint       width,
+                                  gint       height)
+{
+  GdkWindowObject         *private;
+  GdkDrawableImplDirectFB *impl;
+  GdkPixmap               *bg_pixmap;
+  GdkWindowObject         *relative_to;
+  GdkGC                   *gc = NULL;
+  gint                     dx = 0;
+  gint                     dy = 0;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  private = GDK_WINDOW_OBJECT (window);
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+
+  /**
+	Follow XClearArea definition for zero height width
+  **/
+  if( width == 0 )  
+		width = impl->width-x;
+  if( height == 0 )  
+		height = impl->height-y;
+
+  bg_pixmap = private->bg_pixmap;
+
+  for (relative_to = private;
+       relative_to && bg_pixmap == GDK_PARENT_RELATIVE_BG;
+       relative_to = relative_to->parent)
+    {
+      bg_pixmap = relative_to->bg_pixmap;
+      dx += relative_to->x;
+      dy += relative_to->y;
+    }
+
+  if (bg_pixmap == GDK_NO_BG)
+    return;
+
+  if (bg_pixmap && bg_pixmap != GDK_PARENT_RELATIVE_BG)
+    {
+      GdkGCValues  values;
+
+      values.fill = GDK_TILED;
+      values.tile = bg_pixmap;
+      values.ts_x_origin = - dx;
+      values.ts_y_origin = - dy;
+
+      gc = gdk_gc_new_with_values (GDK_DRAWABLE (impl), &values,
+                                   GDK_GC_FILL | GDK_GC_TILE |
+                                   GDK_GC_TS_X_ORIGIN | GDK_GC_TS_Y_ORIGIN);
+    }
+  else 
+    {
+      /* GDK_PARENT_RELATIVE_BG, but no pixmap,
+         get the color from the parent window. */
+
+      GdkGCValues  values;
+
+      values.foreground = relative_to->bg_color;
+
+      gc = gdk_gc_new_with_values (GDK_DRAWABLE (impl), &values,
+                                   GDK_GC_FOREGROUND);
+    }
+
+  gdk_draw_rectangle (GDK_DRAWABLE (impl),
+                                gc, TRUE, x, y, width, height);
+
+  if (gc)
+    g_object_unref (gc);
+}
+
+void
+_gdk_windowing_window_clear_area_e (GdkWindow *window,
+                                    gint       x,
+                                    gint       y,
+                                    gint       width,
+                                    gint       height)
+{
+  GdkRectangle  rect;
+  GdkWindowObject       *private;
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl    = GDK_WINDOW_IMPL_DIRECTFB (private->impl);
+
+  /**
+	Follow XClearArea definition for zero height width
+  **/
+  if( width == 0 )  
+		width = impl->drawable.width-x;
+  if( height == 0 )  
+		height = impl->drawable.height-y;
+
+  rect.x = x;
+  rect.y = y;
+  rect.width = width;
+  rect.height = height;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  _gdk_windowing_window_clear_area (window, x, y, width, height);
+
+  gdk_window_invalidate_rect (window, &rect, TRUE);
+}
+
+void
+gdk_window_raise (GdkWindow *window)
+{
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  if (impl->window)
+    {
+      DFBResult ret;
+
+      ret = impl->window->RaiseToTop (impl->window);
+      if (ret)
+        DirectFBError ("gdkwindow-directfb.c: RaiseToTop", ret);
+      else
+        gdk_directfb_window_raise (window);
+    }
+  else
+    {
+      if (gdk_directfb_window_raise (window))
+        gdk_window_invalidate_rect (window, NULL, TRUE);
+    }
+}
+
+void
+gdk_window_lower (GdkWindow *window)
+{
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  if (impl->window)
+    {
+      DFBResult ret;
+
+      ret = impl->window->LowerToBottom (impl->window);
+      if (ret)
+        DirectFBError ("gdkwindow-directfb.c: LowerToBottom", ret);
+      else
+        gdk_directfb_window_lower (window);
+    }
+  else
+    {
+      gdk_directfb_window_lower (window);
+      gdk_window_invalidate_rect (window, NULL, TRUE);
+    }
+}
+
+void
+gdk_window_set_hints (GdkWindow *window,
+                      gint       x,
+                      gint       y,
+                      gint       min_width,
+                      gint       min_height,
+                      gint       max_width,
+                      gint       max_height,
+                      gint       flags)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_set_geometry_hints (GdkWindow      *window,
+                               GdkGeometry    *geometry,
+                               GdkWindowHints  geom_mask)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_set_title (GdkWindow   *window,
+                      const gchar *title)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_set_role (GdkWindow   *window,
+                     const gchar *role)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_set_transient_for (GdkWindow *window,
+                              GdkWindow *parent)
+{
+  GdkWindowObject *private;
+  GdkWindowObject *root;
+  gint i;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+  g_return_if_fail (GDK_IS_WINDOW (parent));
+
+  private = GDK_WINDOW_OBJECT (window);
+  root    = GDK_WINDOW_OBJECT (_gdk_parent_root);
+
+  g_return_if_fail (GDK_WINDOW (private->parent) == _gdk_parent_root);
+  g_return_if_fail (GDK_WINDOW (GDK_WINDOW_OBJECT (parent)->parent) == _gdk_parent_root);
+
+  root->children = g_list_remove (root->children, window);
+
+  i = g_list_index (root->children, parent);
+  if (i < 0)
+    root->children = g_list_prepend (root->children, window);
+  else
+    root->children = g_list_insert (root->children, window, i);
+}
+
+void
+gdk_window_set_background (GdkWindow *window,
+                           const GdkColor  *color)
+{
+  GdkWindowObject *private;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  g_return_if_fail (color != NULL);
+
+  private = GDK_WINDOW_OBJECT (window);
+  private->bg_color = *color;
+
+  if (private->bg_pixmap &&
+      private->bg_pixmap != GDK_PARENT_RELATIVE_BG &&
+      private->bg_pixmap != GDK_NO_BG)
+    g_object_unref (private->bg_pixmap);
+
+  private->bg_pixmap = NULL;
+}
+
+void
+gdk_window_set_back_pixmap (GdkWindow *window,
+                            GdkPixmap *pixmap,
+                            gint       parent_relative)
+{
+  GdkWindowObject *private;
+  GdkPixmap       *old_pixmap;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+  g_return_if_fail (pixmap == NULL || !parent_relative);
+
+  private = GDK_WINDOW_OBJECT (window);
+  old_pixmap = private->bg_pixmap;
+
+  if (private->bg_pixmap &&
+      private->bg_pixmap != GDK_PARENT_RELATIVE_BG &&
+      private->bg_pixmap != GDK_NO_BG)
+    {
+      g_object_unref (private->bg_pixmap);
+    }
+
+  if (parent_relative)
+    {
+      private->bg_pixmap = GDK_PARENT_RELATIVE_BG;
+    }
+  else
+    {
+      if (pixmap && pixmap != GDK_NO_BG && pixmap != GDK_PARENT_RELATIVE_BG)
+        g_object_ref (pixmap);
+
+      private->bg_pixmap = pixmap;
+    }
+}
+
+void
+gdk_window_set_cursor (GdkWindow *window,
+                       GdkCursor *cursor)
+{
+  GdkWindowImplDirectFB *impl;
+  GdkCursor             *old_cursor;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+  old_cursor = impl->cursor;
+
+  impl->cursor = (cursor ?
+                  gdk_cursor_ref (cursor) : gdk_cursor_new (GDK_LEFT_PTR));
+
+  if (gdk_window_at_pointer (NULL, NULL) == window)
+    {
+      /* This is a bit evil but we want to keep all cursor changes in
+         one place, so let gdk_directfb_window_send_crossing_events
+         do the work for us. */
+
+      gdk_directfb_window_send_crossing_events (window, window,
+                                                GDK_CROSSING_NORMAL);
+    }
+  else if (impl->window)
+    {
+      GdkCursorDirectFB *dfb_cursor = (GdkCursorDirectFB *) impl->cursor;
+
+      /* this branch takes care of setting the cursor for unmapped windows */
+
+      impl->window->SetCursorShape (impl->window,
+                                    dfb_cursor->shape,
+                                    dfb_cursor->hot_x, dfb_cursor->hot_y);
+    }
+
+  if (old_cursor)
+    gdk_cursor_unref (old_cursor);
+}
+
+void
+gdk_window_get_geometry (GdkWindow *window,
+                         gint      *x,
+                         gint      *y,
+                         gint      *width,
+                         gint      *height,
+                         gint      *depth)
+{
+  GdkWindowObject         *private;
+  GdkDrawableImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl    = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+
+  if (!GDK_WINDOW_DESTROYED (window))
+    {
+      if (x)
+	*x = private->x;
+
+      if (y)
+	*y = private->y;
+
+      if (width)
+	*width = impl->width;
+
+      if (height)
+	*height = impl->height;
+
+      if (depth)
+	*depth = DFB_BITS_PER_PIXEL(impl->format);
+    }
+}
+
+void
+_gdk_directfb_calc_abs (GdkWindow *window)
+{
+  GdkWindowObject         *private;
+  GdkDrawableImplDirectFB *impl;
+  GList                   *list;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  private = GDK_WINDOW_OBJECT (window);
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+
+  impl->abs_x = private->x;
+  impl->abs_y = private->y;
+
+  if (private->parent)
+    {
+      GdkDrawableImplDirectFB *parent_impl =
+        GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (private->parent)->impl);
+
+      impl->abs_x += parent_impl->abs_x;
+      impl->abs_y += parent_impl->abs_y;
+    }
+
+  for (list = private->children; list; list = list->next)
+    {
+      _gdk_directfb_calc_abs (list->data);
+    }
+}
+
+gboolean
+gdk_window_get_origin (GdkWindow *window,
+                       gint      *x,
+                       gint      *y)
+{
+  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
+
+  if (!GDK_WINDOW_DESTROYED (window))
+    {
+      GdkDrawableImplDirectFB *impl;
+
+      impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+      if (x)
+	*x = impl->abs_x;
+      if (y)
+	*y = impl->abs_y;
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+gboolean
+gdk_window_get_deskrelative_origin (GdkWindow *window,
+                                    gint      *x,
+                                    gint      *y)
+{
+  return gdk_window_get_origin (window, x, y);
+}
+
+void
+gdk_window_get_root_origin (GdkWindow *window,
+                            gint      *x,
+                            gint      *y)
+{
+  GdkWindowObject *rover;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  rover = (GdkWindowObject*) window;
+  if (x)
+    *x = 0;
+  if (y)
+    *y = 0;
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  while (rover->parent && ((GdkWindowObject*) rover->parent)->parent)
+    rover = (GdkWindowObject *) rover->parent;
+  if (rover->destroyed)
+    return;
+
+  if (x)
+    *x = rover->x;
+  if (y)
+    *y = rover->y;
+}
+
+GdkWindow *
+_gdk_windowing_window_get_pointer (GdkDisplay      *display,
+                                   GdkWindow       *window,
+				   gint            *x,
+				   gint            *y,
+				   GdkModifierType *mask)
+{
+  GdkWindow               *retval = NULL;
+  gint                     rx, ry, wx, wy;
+  GdkDrawableImplDirectFB *impl;
+
+  g_return_val_if_fail (window == NULL || GDK_IS_WINDOW (window), NULL);
+
+  if (!window)
+    window = _gdk_parent_root;
+
+  gdk_directfb_mouse_get_info (&rx, &ry, mask);
+
+  wx = rx;
+  wy = ry;
+  retval = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  if (x)
+    *x = rx - impl->abs_x;
+  if (y)
+    *y = ry - impl->abs_y;
+
+  return retval;
+}
+
+GdkWindow *
+_gdk_windowing_window_at_pointer (GdkDisplay *display,
+                                  gint       *win_x,
+				  gint       *win_y)
+{
+  GdkWindow *retval;
+  gint       wx, wy;
+
+  if (!win_x || !win_y)
+  gdk_directfb_mouse_get_info (&wx, &wy, NULL);
+
+  if (win_x)
+    wx = *win_x;
+
+  if (win_y)
+    wy = *win_y;
+
+  retval = gdk_directfb_child_at (_gdk_parent_root, &wx, &wy);
+
+  if (win_x)
+    *win_x = wx;
+
+  if (win_y)
+    *win_y = wy;
+
+  return retval;
+}
+
+void
+_gdk_windowing_get_pointer (GdkDisplay       *display,
+                            GdkScreen       **screen,
+                            gint             *x,
+                            gint             *y,
+                            GdkModifierType  *mask)
+{
+(void)screen;
+if(screen) {
+	*screen = gdk_display_get_default_screen  (display);
+}
+_gdk_windowing_window_get_pointer (display,
+				   _gdk_windowing_window_at_pointer(display,NULL,NULL),x,y,mask);
+
+}
+
+GdkEventMask
+gdk_window_get_events (GdkWindow *window)
+{
+  g_return_val_if_fail (GDK_IS_WINDOW (window), 0);
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return 0;
+  else
+    return GDK_WINDOW_OBJECT (window)->event_mask;
+}
+
+void
+gdk_window_set_events (GdkWindow    *window,
+                       GdkEventMask  event_mask)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (event_mask & GDK_BUTTON_MOTION_MASK)
+    event_mask |= (GDK_BUTTON1_MOTION_MASK |
+                   GDK_BUTTON2_MOTION_MASK |
+                   GDK_BUTTON3_MOTION_MASK);
+
+  GDK_WINDOW_OBJECT (window)->event_mask = event_mask;
+}
+
+void
+gdk_window_shape_combine_mask (GdkWindow *window,
+                               GdkBitmap *mask,
+                               gint       x,
+                               gint       y)
+{
+}
+
+void
+gdk_window_input_shape_combine_mask (GdkWindow *window,
+                                    GdkBitmap *mask,
+                                    gint       x,
+                                    gint       y)
+{
+}
+
+void
+gdk_window_shape_combine_region (GdkWindow *window,
+                                 GdkRegion *shape_region,
+                                 gint       offset_x,
+                                 gint       offset_y)
+{
+}
+
+void
+gdk_window_input_shape_combine_region (GdkWindow *window,
+                                      GdkRegion *shape_region,
+                                      gint       offset_x,
+                                      gint       offset_y)
+{
+}
+
+void
+gdk_window_set_override_redirect (GdkWindow *window,
+                                  gboolean   override_redirect)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_set_icon_list (GdkWindow *window,
+                          GList     *pixbufs)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_set_icon (GdkWindow *window,
+                     GdkWindow *icon_window,
+                     GdkPixmap *pixmap,
+                     GdkBitmap *mask)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_set_icon_name (GdkWindow   *window,
+                          const gchar *name)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_iconify (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  gdk_window_hide (window);
+}
+
+void
+gdk_window_deiconify (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  gdk_window_show (window);
+}
+
+void
+gdk_window_stick (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_unstick (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_directfb_window_set_opacity (GdkWindow *window,
+                                 guchar     opacity)
+{
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  impl->opacity = opacity;
+
+  if (impl->window && GDK_WINDOW_IS_MAPPED (window))
+    {
+      if (gdk_directfb_apply_focus_opacity &&
+	  window == gdk_directfb_focused_window)
+	impl->window->SetOpacity (impl->window,
+				  (impl->opacity >> 1) + (impl->opacity >> 2));
+      else
+	impl->window->SetOpacity (impl->window, impl->opacity);
+    }
+}
+
+void
+gdk_window_focus (GdkWindow *window,
+                  guint32    timestamp)
+{
+  GdkWindow *toplevel;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  toplevel = gdk_directfb_window_find_toplevel (window);
+  if (toplevel != _gdk_parent_root)
+    {
+      GdkWindowImplDirectFB *impl;
+
+      impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (toplevel)->impl);
+
+      impl->window->RequestFocus (impl->window);
+    }
+}
+
+void
+gdk_window_maximize (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_unmaximize (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+void
+gdk_window_set_type_hint (GdkWindow        *window,
+                          GdkWindowTypeHint hint)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  GDK_NOTE (MISC, g_print ("gdk_window_set_type_hint: 0x%x: %d\n",
+               GDK_WINDOW_DFB_ID (window), hint));
+
+  ((GdkWindowImplDirectFB *)((GdkWindowObject *)window)->impl)->type_hint = hint;
+
+
+  /* N/A */
+}
+
+GdkWindowTypeHint
+gdk_window_get_type_hint (GdkWindow *window)
+{
+  g_return_val_if_fail (GDK_IS_WINDOW (window), GDK_WINDOW_TYPE_HINT_NORMAL);
+  
+  if (GDK_WINDOW_DESTROYED (window))
+    return GDK_WINDOW_TYPE_HINT_NORMAL;
+
+  return GDK_WINDOW_IMPL_DIRECTFB (((GdkWindowObject *) window)->impl)->type_hint;
+}
+
+void
+gdk_window_set_modal_hint (GdkWindow *window,
+                           gboolean   modal)
+{
+  GdkWindowImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  impl = GDK_WINDOW_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  if (impl->window)
+    {
+      impl->window->SetStackingClass (impl->window,
+                                      modal ? DWSC_UPPER : DWSC_MIDDLE);
+    }
+}
+
+void
+gdk_window_set_skip_taskbar_hint (GdkWindow *window,
+				  gboolean   skips_taskbar)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+}
+
+void
+gdk_window_set_skip_pager_hint (GdkWindow *window,
+				gboolean   skips_pager)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+}
+
+
+void
+gdk_window_set_group (GdkWindow *window,
+                      GdkWindow *leader)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+  g_return_if_fail (GDK_IS_WINDOW (leader));
+ g_warning(" DirectFb set_group groups not supported \n");
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+}
+
+GdkWindow * gdk_window_get_group (GdkWindow *window)
+{
+ g_warning(" DirectFb get_group groups not supported \n");
+ return window;	
+}
+
+void
+gdk_fb_window_set_child_handler (GdkWindow             *window,
+                                 GdkWindowChildChanged  changed,
+                                 GdkWindowChildGetPos   get_pos,
+                                 gpointer               user_data)
+{
+  GdkWindowChildHandlerData *data;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  data = g_new (GdkWindowChildHandlerData, 1);
+  data->changed   = changed;
+  data->get_pos   = get_pos;
+  data->user_data = user_data;
+
+  g_object_set_data_full (G_OBJECT (window), "gdk-window-child-handler",
+                          data, (GDestroyNotify) g_free);
+}
+
+void
+gdk_window_set_decorations (GdkWindow       *window,
+                            GdkWMDecoration  decorations)
+{
+  GdkWMDecoration *dec;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  dec = g_new (GdkWMDecoration, 1);
+  *dec = decorations;
+
+  g_object_set_data_full (G_OBJECT (window), "gdk-window-decorations",
+                          dec, (GDestroyNotify) g_free);
+}
+
+gboolean
+gdk_window_get_decorations (GdkWindow       *window,
+			    GdkWMDecoration *decorations)
+{
+  GdkWMDecoration *dec;
+
+  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
+
+  dec = g_object_get_data (G_OBJECT (window), "gdk-window-decorations");
+  if (dec)
+    {
+      *decorations = *dec;
+      return TRUE;
+    }
+  return FALSE;
+}
+
+void
+gdk_window_set_functions (GdkWindow     *window,
+                          GdkWMFunction  functions)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  /* N/A */
+  g_message("unimplemented %s", G_GNUC_FUNCTION);
+}
+
+void
+gdk_window_set_child_shapes (GdkWindow *window)
+{
+}
+
+void
+gdk_window_merge_child_shapes (GdkWindow *window)
+{
+}
+
+void
+gdk_window_set_child_input_shapes (GdkWindow *window)
+{
+}
+
+void
+gdk_window_merge_child_input_shapes (GdkWindow *window)
+{
+}
+
+gboolean
+gdk_window_set_static_gravities (GdkWindow *window,
+                                 gboolean   use_static)
+{
+  g_return_val_if_fail (GDK_IS_WINDOW (window), FALSE);
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return FALSE;
+
+  /* N/A */
+  g_message("unimplemented %s", G_GNUC_FUNCTION);
+
+  return FALSE;
+}
+#if 0 
+void
+gdk_window_begin_paint_region (GdkWindow *window,
+                               GdkRegion *region)
+{
+  GdkDrawableImplDirectFB *impl;
+  gint                     i;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  impl->buffered = TRUE;
+  impl->paint_depth++;
+
+  if (!region)
+    return;
+
+  if (impl->paint_region)
+    gdk_region_union (impl->paint_region, region);
+  else
+    impl->paint_region = gdk_region_copy (region);
+
+  for (i = 0; i < region->numRects; i++)
+    {
+      GdkRegionBox *box = &region->rects[i];
+
+      _gdk_windowing_window_clear_area (window,
+                                        box->x1,
+                                        box->y1,
+                                        box->x2 - box->x1,
+                                        box->y2 - box->y1);
+    }
+}
+
+void
+gdk_window_end_paint (GdkWindow *window)
+{
+  GdkDrawableImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (GDK_WINDOW_OBJECT (window)->impl);
+
+  g_return_if_fail (impl->paint_depth > 0);
+
+  impl->paint_depth--;
+
+  if (impl->paint_depth == 0)
+    {
+      impl->buffered = FALSE;
+
+      if (impl->paint_region)
+        {
+          DFBRegion reg = { impl->paint_region->extents.x1,
+                            impl->paint_region->extents.y1,
+                            impl->paint_region->extents.x2 - 1,
+                            impl->paint_region->extents.y2 - 1 };
+
+          _gdk_directfb_update (impl, &reg);
+
+          gdk_region_destroy (impl->paint_region);
+          impl->paint_region = NULL;
+        }
+    }
+}
+#endif
+
+void
+gdk_window_begin_resize_drag (GdkWindow     *window,
+                              GdkWindowEdge  edge,
+                              gint           button,
+                              gint           root_x,
+                              gint           root_y,
+                              guint32        timestamp)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  g_message("unimplemented %s", G_GNUC_FUNCTION);
+}
+
+void
+gdk_window_begin_move_drag (GdkWindow *window,
+                            gint       button,
+                            gint       root_x,
+                            gint       root_y,
+                            guint32    timestamp)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  g_message("unimplemented %s", G_GNUC_FUNCTION);
+}
+
+/**
+ * gdk_window_get_frame_extents:
+ * @window: a #GdkWindow
+ * @rect: rectangle to fill with bounding box of the window frame
+ *
+ * Obtains the bounding box of the window, including window manager
+ * titlebar/borders if any. The frame position is given in root window
+ * coordinates. To get the position of the window itself (rather than
+ * the frame) in root window coordinates, use gdk_window_get_origin().
+ *
+ **/
+void
+gdk_window_get_frame_extents (GdkWindow    *window,
+                              GdkRectangle *rect)
+{
+  GdkWindowObject         *private;
+  GdkDrawableImplDirectFB *impl;
+
+  g_return_if_fail (GDK_IS_WINDOW (window));
+  g_return_if_fail (rect != NULL);
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  private = GDK_WINDOW_OBJECT (window);
+
+  while (private->parent && ((GdkWindowObject*) private->parent)->parent)
+    private = (GdkWindowObject*) private->parent;
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  impl = GDK_DRAWABLE_IMPL_DIRECTFB (private->impl);
+
+  rect->x      = impl->abs_x;
+  rect->y      = impl->abs_x;
+  rect->width  = impl->width;
+  rect->height = impl->height;
+}
+
+
+
+GdkWindow *
+gdk_window_foreign_new_for_display (GdkDisplay* display,GdkNativeWindow anid)
+{
+  GdkWindow *window;
+
+  window = gdk_window_lookup (anid);
+
+  if (window)
+    g_object_ref (window);
+
+  return window;
+}
+
+GdkWindow *
+gdk_window_lookup_for_display (GdkDisplay *display,GdkNativeWindow anid)
+{
+  return gdk_directfb_window_id_table_lookup ((DFBWindowID) anid);
+}
+
+GdkWindow *
+gdk_window_lookup (GdkNativeWindow anid)
+{
+  return gdk_directfb_window_id_table_lookup ((DFBWindowID) anid);
+}
+
+
+
+void
+gdk_window_fullscreen (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  g_warning ("gdk_window_fullscreen() not implemented.\n");
+}
+
+void
+gdk_window_unfullscreen (GdkWindow *window)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+
+  /*  g_warning ("gdk_window_unfullscreen() not implemented.\n");*/
+}
+
+void
+gdk_window_set_keep_above (GdkWindow *window, gboolean setting)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+  static gboolean first_call = TRUE;
+  if (first_call) {
+  g_warning ("gdk_window_set_keep_above() not implemented.\n");
+	first_call=FALSE;
+  }
+	
+}
+
+void
+gdk_window_set_keep_below (GdkWindow *window, gboolean setting)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+  static gboolean first_call = TRUE;
+  if (first_call) {
+  g_warning ("gdk_window_set_keep_below() not implemented.\n");
+  first_call=FALSE;
+  }
+  
+}
+
+void
+gdk_window_enable_synchronized_configure (GdkWindow *window)
+{
+}
+
+void
+gdk_window_configure_finished (GdkWindow *window)
+{
+}
+
+void
+gdk_display_warp_pointer (GdkDisplay *display,
+                          GdkScreen  *screen,
+                          gint        x,
+                          gint        y)
+{
+  g_warning ("gdk_display_warp_pointer() not implemented.\n");
+}
+
+void
+gdk_window_set_urgency_hint (GdkWindow *window,
+                             gboolean   urgent)
+{
+  g_return_if_fail (GDK_IS_WINDOW (window));
+  g_return_if_fail (GDK_WINDOW_TYPE (window) != GDK_WINDOW_CHILD);
+
+  if (GDK_WINDOW_DESTROYED (window))
+    return;
+
+  g_warning ("gdk_window_set_urgency_hint() not implemented.\n");
+
+}
+
+
+#define __GDK_WINDOW_X11_C__
+#include "gdkaliasdef.c"
+
diff -ruN old/gdk/directfb/gdkwindowid.c gtk+/gdk/directfb/gdkwindowid.c
--- old/gdk/directfb/gdkwindowid.c	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/gdkwindowid.c	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,69 @@
+/* GDK - The GIMP Drawing Kit
+ * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GTK+ Team.
+ */
+
+/*
+ * GTK+ DirectFB backend
+ * Copyright (C) 2001-2002  convergence integrated media GmbH
+ * Copyright (C) 2002-2004  convergence GmbH
+ * Written by Denis Oliver Kropp <dok@convergence.de> and
+ *            Sven Neumann <sven@convergence.de>
+ */
+
+#include "config.h"
+
+#include "gdkdirectfb.h"
+#include "gdkprivate-directfb.h"
+
+
+static GHashTable *window_id_ht = NULL;
+
+
+void
+gdk_directfb_window_id_table_insert (DFBWindowID  dfb_id,
+                                     GdkWindow   *window)
+{
+  if (!window_id_ht)
+    window_id_ht = g_hash_table_new (g_direct_hash, g_direct_equal);
+
+  g_hash_table_insert (window_id_ht, GUINT_TO_POINTER (dfb_id), window);
+}
+
+void
+gdk_directfb_window_id_table_remove (DFBWindowID dfb_id)
+{
+  if (window_id_ht)
+    g_hash_table_remove (window_id_ht, GUINT_TO_POINTER (dfb_id));
+}
+
+GdkWindow *
+gdk_directfb_window_id_table_lookup (DFBWindowID dfb_id)
+{
+  GdkWindow *window = NULL;
+
+  if (window_id_ht)
+    window = (GdkWindow *) g_hash_table_lookup (window_id_ht,
+                                                GUINT_TO_POINTER (dfb_id));
+
+  return window;
+}
diff -ruN old/gdk/directfb/x-cursors.xbm gtk+/gdk/directfb/x-cursors.xbm
--- old/gdk/directfb/x-cursors.xbm	1970-01-01 01:00:00.000000000 +0100
+++ gtk+/gdk/directfb/x-cursors.xbm	2006-06-13 23:46:23.000000000 +0200
@@ -0,0 +1,924 @@
+#define X_cursor_width 14
+#define X_cursor_height 14
+#define X_cursor_x_hot 6
+#define X_cursor_y_hot 6
+static unsigned char X_cursor_bits[] = {
+0x07, 0xb8, 0x0f, 0x3c, 0x1f, 0x3e, 0x3e, 0x1f, 0xfc, 0x0f, 0xf8, 0x07, 0xf0, 0x03, 0xf0, 0x03, 0xf8, 0x07, 0xfc, 0x0f, 0x3e, 0x1f, 0x1f, 0x3e, 0x0f, 0x3c, 0x07, 0x38};
+#define X_cursor_mask_width 16
+#define X_cursor_mask_height 16
+#define X_cursor_mask_x_hot 7
+#define X_cursor_mask_y_hot 7
+static unsigned char X_cursor_mask_bits[] = {
+0x0f, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 0xfe, 0x7f, 0xfc, 0x3f, 0xf8, 0x1f, 0xf0, 0x0f, 0xf0, 0x0f, 0xf8, 0x1f, 0xfc, 0x3f, 0xfe, 0x7f, 0x7f, 0xfe, 0x3f, 0xfc, 0x1f, 0xf8, 0x0f, 0xf0};
+#define arrow_width 14
+#define arrow_height 14
+#define arrow_x_hot 13
+#define arrow_y_hot 0
+static unsigned char arrow_bits[] = {
+00, 0xb0, 00, 0x3c, 00, 0x1f, 0xc0, 0x1f, 0xf0, 0x0f, 0xfc, 0x0f, 0xc0, 0x07, 0xe0, 0x07, 0x70, 0x03, 0x38, 0x03, 0x1c, 0x01, 0x0e, 0x01, 0x07, 00, 0x02, 00};
+#define arrow_mask_width 16
+#define arrow_mask_height 16
+#define arrow_mask_x_hot 14
+#define arrow_mask_y_hot 1
+static unsigned char arrow_mask_bits[] = {
+00, 0xe0, 00, 0xf8, 00, 0xfe, 0x80, 0x7f, 0xe0, 0x7f, 0xf8, 0x3f, 0xfc, 0x3f, 0xfc, 0x1f, 0xe0, 0x1f, 0xf0, 0x0f, 0xf8, 0x0f, 0x7c, 0x07, 0x3e, 0x07, 0x1f, 0x02, 0x0e, 00, 0x04, 00};
+#define based_arrow_down_width 8
+#define based_arrow_down_height 10
+#define based_arrow_down_x_hot 3
+#define based_arrow_down_y_hot 9
+static unsigned char based_arrow_down_bits[] = {
+0xff, 00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x5a, 0x3c, 0x18};
+#define based_arrow_down_mask_width 10
+#define based_arrow_down_mask_height 12
+#define based_arrow_down_mask_x_hot 4
+#define based_arrow_down_mask_y_hot 10
+static unsigned char based_arrow_down_mask_bits[] = {
+0xff, 0x23, 0xff, 0x03, 0xff, 0x03, 0xff, 0x03, 0xff, 0x03, 0x78, 00, 0x78, 00, 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfc, 00, 0x78, 00};
+#define based_arrow_up_width 8
+#define based_arrow_up_height 10
+#define based_arrow_up_x_hot 3
+#define based_arrow_up_y_hot 9
+static unsigned char based_arrow_up_bits[] = {
+0x18, 0x3c, 0x5a, 0x18, 0x18, 0x18, 0x18, 0xff, 00, 0xff};
+#define based_arrow_up_mask_width 10
+#define based_arrow_up_mask_height 12
+#define based_arrow_up_mask_x_hot 4
+#define based_arrow_up_mask_y_hot 10
+static unsigned char based_arrow_up_mask_bits[] = {
+0x30, 0x20, 0x78, 00, 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0x78, 00, 0x78, 00, 0xff, 0x03, 0xff, 0x03, 0xff, 0x03, 0xff, 0x03, 0xff, 0x03};
+#define boat_width 16
+#define boat_height 8
+#define boat_x_hot 14
+#define boat_y_hot 3
+static unsigned char boat_bits[] = {
+0x80, 00, 0xe0, 0x03, 0x11, 0x06, 0xff, 0xff, 00, 0x18, 00, 0x04, 00, 0x02, 0xff, 0x03};
+#define boat_mask_width 16
+#define boat_mask_height 9
+#define boat_mask_x_hot 14
+#define boat_mask_y_hot 4
+static unsigned char boat_mask_bits[] = {
+0xe0, 00, 0xf0, 0x03, 0xf9, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0x07, 0xff, 0x03};
+#define bogosity_width 13
+#define bogosity_height 14
+#define bogosity_x_hot 6
+#define bogosity_y_hot 6
+static unsigned char bogosity_bits[] = {
+0x47, 0x9c, 0x44, 0x04, 0x44, 0x04, 0x44, 0x04, 0xff, 0x1f, 0x45, 0x14, 0x45, 0x14, 0x45, 0x14, 0x45, 0x14, 0xff, 0x1f, 0x44, 0x04, 0x44, 0x04, 0x44, 0x04, 0x47, 0x1c};
+#define bogosity_mask_width 15
+#define bogosity_mask_height 16
+#define bogosity_mask_x_hot 7
+#define bogosity_mask_y_hot 7
+static unsigned char bogosity_mask_bits[] = {
+0xdf, 0x7d, 0xdf, 0x7d, 0xdf, 0x7d, 0xdc, 0x1d, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xdf, 0x7d, 0xdf, 0x7d, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xdc, 0x1d, 0xdf, 0x7d, 0xdf, 0x7d, 0xdf, 0x7d};
+#define bottom_left_corner_width 14
+#define bottom_left_corner_height 14
+#define bottom_left_corner_x_hot 0
+#define bottom_left_corner_y_hot 13
+static unsigned char bottom_left_corner_bits[] = {
+0x03, 0x80, 0x03, 00, 0x23, 0x08, 0x23, 0x04, 0x23, 0x02, 0x23, 0x01, 0xa3, 00, 0x63, 00, 0xe3, 0x0f, 0x03, 00, 0x03, 00, 0x03, 00, 0xff, 0x3f, 0xff, 0x3f};
+#define bottom_left_corner_mask_width 16
+#define bottom_left_corner_mask_height 16
+#define bottom_left_corner_mask_x_hot 1
+#define bottom_left_corner_mask_y_hot 14
+static unsigned char bottom_left_corner_mask_bits[] = {
+0x0f, 00, 0x0f, 00, 0xef, 0x30, 0xef, 0x38, 0xef, 0x1c, 0xef, 0x0e, 0xef, 0x07, 0xef, 0x03, 0xef, 0x3f, 0xef, 0x3f, 0xef, 0x3f, 0x0f, 00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+#define bottom_right_corner_width 14
+#define bottom_right_corner_height 14
+#define bottom_right_corner_x_hot 13
+#define bottom_right_corner_y_hot 13
+static unsigned char bottom_right_corner_bits[] = {
+00, 0xb0, 00, 0x30, 0x04, 0x31, 0x08, 0x31, 0x10, 0x31, 0x20, 0x31, 0x40, 0x31, 0x80, 0x31, 0xfc, 0x31, 00, 0x30, 00, 0x30, 00, 0x30, 0xff, 0x3f, 0xff, 0x3f};
+#define bottom_right_corner_mask_width 16
+#define bottom_right_corner_mask_height 16
+#define bottom_right_corner_mask_x_hot 14
+#define bottom_right_corner_mask_y_hot 14
+static unsigned char bottom_right_corner_mask_bits[] = {
+00, 0xf0, 00, 0xf0, 0x0c, 0xf7, 0x1c, 0xf7, 0x38, 0xf7, 0x70, 0xf7, 0xe0, 0xf7, 0xc0, 0xf7, 0xfc, 0xf7, 0xfc, 0xf7, 0xfc, 0xf7, 00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+#define bottom_side_width 13
+#define bottom_side_height 14
+#define bottom_side_x_hot 6
+#define bottom_side_y_hot 13
+static unsigned char bottom_side_bits[] = {
+0x40, 0x80, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x44, 0x04, 0x48, 0x02, 0x50, 0x01, 0xe0, 00, 0x40, 00, 00, 00, 0xff, 0x1f, 0xff, 0x1f};
+#define bottom_side_mask_width 15
+#define bottom_side_mask_height 16
+#define bottom_side_mask_x_hot 7
+#define bottom_side_mask_y_hot 14
+static unsigned char bottom_side_mask_bits[] = {
+0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xcc, 0x19, 0xdc, 0x1d, 0xf8, 0x0f, 0xf0, 0x07, 0xe0, 0x03, 0xc0, 0x01, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f};
+#define bottom_tee_width 14
+#define bottom_tee_height 10
+#define bottom_tee_x_hot 7
+#define bottom_tee_y_hot 9
+static unsigned char bottom_tee_bits[] = {
+0xc0, 0x80, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xff, 0x3f, 0xff, 0x3f};
+#define bottom_tee_mask_width 16
+#define bottom_tee_mask_height 12
+#define bottom_tee_mask_x_hot 8
+#define bottom_tee_mask_y_hot 10
+static unsigned char bottom_tee_mask_bits[] = {
+0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+#define box_spiral_width 15
+#define box_spiral_height 16
+#define box_spiral_x_hot 8
+#define box_spiral_y_hot 8
+static unsigned char box_spiral_bits[] = {
+0xff, 0xff, 0x01, 00, 0xfd, 0x7f, 0x05, 0x40, 0xf5, 0x5f, 0x15, 0x50, 0xd5, 0x57, 0x55, 0x54, 0x55, 0x55, 0xd5, 0x55, 0x15, 0x54, 0xf5, 0x57, 0x05, 0x50, 0xfd, 0x5f, 0x01, 0x40, 0xff, 0x7f};
+#define box_spiral_mask_width 16
+#define box_spiral_mask_height 16
+#define box_spiral_mask_x_hot 8
+#define box_spiral_mask_y_hot 8
+static unsigned char box_spiral_mask_bits[] = {
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+#define center_ptr_width 10
+#define center_ptr_height 14
+#define center_ptr_x_hot 4
+#define center_ptr_y_hot 0
+static unsigned char center_ptr_bits[] = {
+0x30, 0x90, 0x30, 00, 0x78, 00, 0x78, 00, 0xfc, 00, 0xfc, 00, 0xfe, 0x01, 0xfe, 0x01, 0x33, 0x03, 0x31, 0x02, 0x30, 00, 0x30, 00, 0x30, 00, 0x30, 00};
+#define center_ptr_mask_width 12
+#define center_ptr_mask_height 16
+#define center_ptr_mask_x_hot 5
+#define center_ptr_mask_y_hot 1
+static unsigned char center_ptr_mask_bits[] = {
+0xf0, 0x20, 0xf0, 00, 0xf8, 0x01, 0xf8, 0x01, 0xfc, 0x03, 0xfc, 0x03, 0xfe, 0x07, 0xfe, 0x07, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xf7, 0x0e, 0xf0, 00, 0xf0, 00, 0xf0, 00, 0xf0, 00};
+#define circle_width 14
+#define circle_height 14
+#define circle_x_hot 7
+#define circle_y_hot 7
+static unsigned char circle_bits[] = {
+0xe0, 0x81, 0xf8, 0x07, 0xfc, 0x0f, 0x1e, 0x1e, 0x0e, 0x1c, 0x07, 0x38, 0x07, 0x38, 0x07, 0x38, 0x07, 0x38, 0x0e, 0x1c, 0x1e, 0x1e, 0xfc, 0x0f, 0xf8, 0x07, 0xe0, 0x01};
+#define circle_mask_width 16
+#define circle_mask_height 16
+#define circle_mask_x_hot 8
+#define circle_mask_y_hot 8
+static unsigned char circle_mask_bits[] = {
+0xe0, 0x07, 0xf8, 0x1f, 0xfc, 0x3f, 0xfe, 0x7f, 0xfe, 0x7f, 0x3f, 0xfc, 0x1f, 0xf8, 0x1f, 0xf8, 0x1f, 0xf8, 0x1f, 0xf8, 0x3f, 0xfc, 0xfe, 0x7f, 0xfe, 0x7f, 0xfc, 0x3f, 0xf8, 0x1f, 0xe0, 0x07};
+#define clock_width 14
+#define clock_height 16
+#define clock_x_hot 6
+#define clock_y_hot 3
+static unsigned char clock_bits[] = {
+0xfc, 0x8f, 0xe6, 0x19, 0x13, 0x33, 0xc9, 0x24, 0x79, 0x24, 0x11, 0x22, 0xe3, 0x31, 0xfe, 0x1f, 0xca, 0x14, 0xca, 0x14, 0xca, 0x14, 0xea, 0x15, 0xcb, 0x34, 0x0f, 0x3c, 0xff, 0x3f, 0xff, 0x3f};
+#define clock_mask_width 15
+#define clock_mask_height 16
+#define clock_mask_x_hot 6
+#define clock_mask_y_hot 3
+static unsigned char clock_mask_bits[] = {
+0xfe, 0x1f, 0xf7, 0x39, 0xdb, 0x77, 0xed, 0x6d, 0xfd, 0x6f, 0xf9, 0x66, 0xf3, 0x73, 0xff, 0x3f, 0xeb, 0x35, 0xeb, 0x35, 0xeb, 0x35, 0xfb, 0x37, 0xeb, 0x75, 0xcf, 0x7c, 0xff, 0x7f, 0xff, 0x7f};
+#define coffee_mug_width 15
+#define coffee_mug_height 16
+#define coffee_mug_x_hot 7
+#define coffee_mug_y_hot 9
+static unsigned char coffee_mug_bits[] = {
+0xf8, 0x8f, 0x04, 0x10, 0x06, 0x60, 0x0a, 0x58, 0xf2, 0x47, 0x03, 0x40, 0x03, 0x40, 0x02, 0x40, 0x02, 0x40, 0x9a, 0x58, 0x56, 0x55, 0xd7, 0x55, 0x5b, 0x59, 0x02, 0x40, 0x02, 0x40, 0xfc, 0x3f};
+#define coffee_mug_mask_width 16
+#define coffee_mug_mask_height 16
+#define coffee_mug_mask_x_hot 7
+#define coffee_mug_mask_y_hot 9
+static unsigned char coffee_mug_mask_bits[] = {
+0xf8, 0x0f, 0xfc, 0x1f, 0xfe, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xfc, 0x3f};
+#define cross_width 16
+#define cross_height 15
+#define cross_x_hot 7
+#define cross_y_hot 7
+static unsigned char cross_bits[] = {
+0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x7f, 0xff, 00, 00, 0x7f, 0xff, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01};
+#define cross_mask_width 16
+#define cross_mask_height 16
+#define cross_mask_x_hot 7
+#define cross_mask_y_hot 7
+static unsigned char cross_mask_bits[] = {
+0xe0, 0x03, 0xe0, 0x03, 0xe0, 0x03, 0xe0, 0x03, 0xe0, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x03, 0xe0, 0x03, 0xe0, 0x03, 0xe0, 0x03, 0xe0, 0x03, 0xe0, 0x03};
+#define cross_reverse_width 16
+#define cross_reverse_height 15
+#define cross_reverse_x_hot 7
+#define cross_reverse_y_hot 7
+static unsigned char cross_reverse_bits[] = {
+0x42, 0x21, 0x45, 0x51, 0x4a, 0x29, 0x54, 0x15, 0x68, 0x0b, 0x50, 0x05, 0xbf, 0xfe, 0x40, 0x01, 0xbf, 0xfe, 0x50, 0x05, 0x68, 0x0b, 0x54, 0x15, 0x4a, 0x29, 0x45, 0x51, 0x42, 0x21};
+#define cross_reverse_mask_width 16
+#define cross_reverse_mask_height 15
+#define cross_reverse_mask_x_hot 7
+#define cross_reverse_mask_y_hot 7
+static unsigned char cross_reverse_mask_bits[] = {
+0x66, 0x33, 0x6d, 0xdb, 0x7b, 0x6f, 0x76, 0x37, 0x6c, 0x1b, 0x5f, 0xfd, 0x3f, 0xfe, 0x80, 00, 0x3f, 0xfe, 0x5f, 0xfd, 0x6c, 0x1b, 0x76, 0x37, 0x7b, 0x6f, 0x6d, 0xdb, 0x66, 0x33};
+#define crosshair_width 16
+#define crosshair_height 15
+#define crosshair_x_hot 7
+#define crosshair_y_hot 7
+static unsigned char crosshair_bits[] = {
+0x80, 00, 0x80, 00, 0x80, 00, 0x80, 00, 0x80, 00, 0x80, 00, 0x80, 00, 0x7f, 0xff, 0x80, 00, 0x80, 00, 0x80, 00, 0x80, 00, 0x80, 00, 0x80, 00, 0x80, 00};
+#define crosshair_mask_width 16
+#define crosshair_mask_height 16
+#define crosshair_mask_x_hot 7
+#define crosshair_mask_y_hot 7
+static unsigned char crosshair_mask_bits[] = {
+0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01};
+#define diamond_cross_width 15
+#define diamond_cross_height 15
+#define diamond_cross_x_hot 7
+#define diamond_cross_y_hot 7
+static unsigned char diamond_cross_bits[] = {
+0x40, 0x81, 0x60, 0x03, 0x50, 0x05, 0x48, 0x09, 0x44, 0x11, 0x42, 0x21, 0x7f, 0x7f, 00, 00, 0x7f, 0x7f, 0x42, 0x21, 0x44, 0x11, 0x48, 0x09, 0x50, 0x05, 0x60, 0x03, 0x40, 0x01};
+#define diamond_cross_mask_width 16
+#define diamond_cross_mask_height 16
+#define diamond_cross_mask_x_hot 7
+#define diamond_cross_mask_y_hot 7
+static unsigned char diamond_cross_mask_bits[] = {
+0xe0, 0x03, 0xf0, 0x07, 0xf8, 0x0f, 0xdc, 0x1d, 0xce, 0x39, 0xc7, 0x71, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xc7, 0x71, 0xce, 0x39, 0xdc, 0x1d, 0xf8, 0x0f, 0xf0, 0x07, 0xe0, 0x03, 0xc0, 0x01};
+#define dot_width 10
+#define dot_height 10
+#define dot_x_hot 5
+#define dot_y_hot 5
+static unsigned char dot_bits[] = {
+0x78, 0x90, 0xfe, 0x01, 0xfe, 0x01, 0xff, 0x03, 0xff, 0x03, 0xff, 0x03, 0xff, 0x03, 0xfe, 0x01, 0xfe, 0x01, 0x78, 00};
+#define dot_mask_width 12
+#define dot_mask_height 12
+#define dot_mask_x_hot 6
+#define dot_mask_y_hot 6
+static unsigned char dot_mask_bits[] = {
+0xf8, 0x21, 0xfe, 0x07, 0xfe, 0x07, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xfe, 0x07, 0xfe, 0x07, 0xf8, 0x01};
+#define dotbox_width 12
+#define dotbox_height 12
+#define dotbox_x_hot 6
+#define dotbox_y_hot 5
+static unsigned char dotbox_bits[] = {
+0xff, 0x9f, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0x61, 0x08, 0x61, 0x08, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0x01, 0x08, 0xff, 0x0f};
+#define dotbox_mask_width 14
+#define dotbox_mask_height 14
+#define dotbox_mask_x_hot 7
+#define dotbox_mask_y_hot 6
+static unsigned char dotbox_mask_bits[] = {
+0xff, 0x3f, 0xff, 0x3f, 0xff, 0x3f, 0x07, 0x38, 0x07, 0x38, 0xe7, 0x39, 0xe7, 0x39, 0xe7, 0x39, 0xe7, 0x39, 0x07, 0x38, 0x07, 0x38, 0xff, 0x3f, 0xff, 0x3f, 0xff, 0x3f};
+#define double_arrow_width 10
+#define double_arrow_height 14
+#define double_arrow_x_hot 5
+#define double_arrow_y_hot 7
+static unsigned char double_arrow_bits[] = {
+0x30, 0x90, 0x78, 00, 0xfc, 00, 0xb6, 0x01, 0x33, 0x03, 0x30, 00, 0x30, 00, 0x30, 00, 0x30, 00, 0x33, 0x03, 0xb6, 0x01, 0xfc, 00, 0x78, 00, 0x30, 00};
+#define double_arrow_mask_width 12
+#define double_arrow_mask_height 16
+#define double_arrow_mask_x_hot 6
+#define double_arrow_mask_y_hot 8
+static unsigned char double_arrow_mask_bits[] = {
+0xf0, 0x20, 0xf8, 0x01, 0xfc, 0x03, 0xfe, 0x07, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xf0, 00, 0xf0, 00, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xfe, 0x07, 0xfc, 0x03, 0xf8, 0x01, 0xf0, 00};
+#define draft_large_width 15
+#define draft_large_height 15
+#define draft_large_x_hot 14
+#define draft_large_y_hot 0
+static unsigned char draft_large_bits[] = {
+00, 0xc0, 00, 0x30, 00, 0x3c, 00, 0x1f, 0xc0, 0x1f, 0xf0, 0x0f, 0xfc, 0x0f, 0x80, 0x07, 0x40, 0x07, 0x20, 0x03, 0x10, 0x03, 0x08, 0x01, 0x04, 0x01, 0x02, 00, 0x01, 00};
+#define draft_large_mask_width 15
+#define draft_large_mask_height 16
+#define draft_large_mask_x_hot 14
+#define draft_large_mask_y_hot 0
+static unsigned char draft_large_mask_bits[] = {
+00, 0x60, 00, 0x78, 00, 0x7e, 0x80, 0x3f, 0xe0, 0x1f, 0xf8, 0x1f, 0xfe, 0x0f, 0xfe, 0x0f, 0xe0, 0x07, 0xf0, 0x07, 0xb8, 0x03, 0x9c, 0x03, 0x8e, 0x01, 0x87, 0x01, 0x03, 00, 0x01, 00};
+#define draft_small_width 15
+#define draft_small_height 15
+#define draft_small_x_hot 14
+#define draft_small_y_hot 0
+static unsigned char draft_small_bits[] = {
+00, 0x40, 00, 0x30, 00, 0x3c, 00, 0x1f, 0xc0, 0x1f, 00, 0x0e, 00, 0x0d, 0x80, 0x04, 0x40, 0x04, 0x20, 00, 0x10, 00, 0x08, 00, 0x04, 00, 0x02, 00, 0x01, 00};
+#define draft_small_mask_width 15
+#define draft_small_mask_height 15
+#define draft_small_mask_x_hot 14
+#define draft_small_mask_y_hot 0
+static unsigned char draft_small_mask_bits[] = {
+00, 0x60, 00, 0x78, 00, 0x3e, 0x80, 0x3f, 0xe0, 0x1f, 0xe0, 0x1f, 0x80, 0x0f, 0xc0, 0x0f, 0xe0, 0x06, 0x70, 0x02, 0x38, 00, 0x1c, 00, 0x0e, 00, 0x07, 00, 0x03, 00};
+#define draped_box_width 12
+#define draped_box_height 12
+#define draped_box_x_hot 6
+#define draped_box_y_hot 5
+static unsigned char draped_box_bits[] = {
+0xff, 0x1f, 0x91, 0x08, 0x99, 0x09, 0x0d, 0x0b, 0x07, 0x0e, 0x61, 0x08, 0x61, 0x08, 0x07, 0x0e, 0x0d, 0x0b, 0x99, 0x09, 0x91, 0x08, 0xff, 0x0f};
+#define draped_box_mask_width 14
+#define draped_box_mask_height 14
+#define draped_box_mask_x_hot 7
+#define draped_box_mask_y_hot 6
+static unsigned char draped_box_mask_bits[] = {
+0xff, 0x3f, 0xff, 0x3f, 0xf3, 0x33, 0xfb, 0x37, 0x3f, 0x3f, 0xdf, 0x3e, 0xef, 0x3d, 0xef, 0x3d, 0xdf, 0x3e, 0x3f, 0x3f, 0xfb, 0x37, 0xf3, 0x33, 0xff, 0x3f, 0xff, 0x3f};
+#define exchange_width 14
+#define exchange_height 14
+#define exchange_x_hot 6
+#define exchange_y_hot 6
+static unsigned char exchange_bits[] = {
+0xf1, 0x03, 0xfb, 0x07, 0x1f, 0x0c, 0x09, 0x08, 0x19, 00, 0x3f, 00, 00, 00, 00, 00, 00, 0x3f, 00, 0x26, 0x04, 0x24, 0x0c, 0x3e, 0xf8, 0x37, 0xf0, 0x23};
+#define exchange_mask_width 16
+#define exchange_mask_height 16
+#define exchange_mask_x_hot 7
+#define exchange_mask_y_hot 7
+static unsigned char exchange_mask_bits[] = {
+0xe3, 0x07, 0xf7, 0x0f, 0xff, 0x1f, 0xff, 0x3f, 0x3f, 0x38, 0xff, 0x30, 0xff, 00, 0xff, 00, 00, 0xff, 00, 0xff, 0x0c, 0xfe, 0x1c, 0xfc, 0xfc, 0xff, 0xf8, 0xff, 0xf0, 0xef, 0xe0, 0xc7};
+#define fleur_width 14
+#define fleur_height 14
+#define fleur_x_hot 7
+#define fleur_y_hot 7
+static unsigned char fleur_bits[] = {
+0xc0, 00, 0xe0, 0x01, 0xf0, 0x03, 0xc0, 00, 0xc4, 0x08, 0xc6, 0x18, 0xff, 0x3f, 0xff, 0x3f, 0xc6, 0x18, 0xc4, 0x08, 0xc0, 00, 0xf0, 0x03, 0xe0, 0x01, 0xc0, 00};
+#define fleur_mask_width 16
+#define fleur_mask_height 16
+#define fleur_mask_x_hot 8
+#define fleur_mask_y_hot 8
+static unsigned char fleur_mask_bits[] = {
+0xc0, 0x03, 0xc0, 0x07, 0xe0, 0x07, 0xf0, 0x0f, 0xe8, 0x17, 0xdc, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdc, 0x3b, 0xe8, 0x17, 0xf0, 0x0f, 0xe0, 0x07, 0xc0, 0x03, 0xc0, 0x03};
+#define gobbler_width 16
+#define gobbler_height 15
+#define gobbler_x_hot 14
+#define gobbler_y_hot 2
+static unsigned char gobbler_bits[] = {
+00, 0x1e, 00, 0x0e, 0x01, 0xcc, 0xf9, 0x0d, 0xff, 0x0f, 0x7f, 0x0c, 0x3f, 0x0c, 0x06, 0x1c, 00, 0x0f, 0xf8, 0x07, 0x10, 00, 0x10, 00, 0x10, 00, 0x10, 00, 0x78, 00};
+#define gobbler_mask_width 16
+#define gobbler_mask_height 16
+#define gobbler_mask_x_hot 14
+#define gobbler_mask_y_hot 3
+static unsigned char gobbler_mask_bits[] = {
+00, 0x3f, 00, 0x3f, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0x3f, 0xff, 0x3f, 0xff, 0x3f, 0xff, 0x3f, 0xfe, 0x1f, 0xf8, 0x0f, 0x38, 00, 0x38, 00, 0xfc, 00, 0xfc, 00};
+#define gumby_width 16
+#define gumby_height 16
+#define gumby_x_hot 2
+#define gumby_y_hot 0
+static unsigned char gumby_bits[] = {
+0xfc, 00, 0x08, 0x01, 0x13, 0x02, 0x57, 0x05, 0x13, 0x04, 0xd3, 0x05, 0x1f, 0x3c, 0x1c, 0xfc, 0x10, 0xe4, 0x10, 0xe4, 0x90, 0xf4, 0x90, 0xe4, 0x90, 0x04, 0x88, 0x08, 0x84, 0x10, 0x7c, 0x1f};
+#define gumby_mask_width 16
+#define gumby_mask_height 16
+#define gumby_mask_x_hot 2
+#define gumby_mask_y_hot 0
+static unsigned char gumby_mask_bits[] = {
+0xfc, 00, 0xfb, 0x01, 0xf7, 0x03, 0xff, 0x07, 0xf7, 0x07, 0xf7, 0x3f, 0xff, 0x7f, 0xff, 0xff, 0xfc, 0xf7, 0xf0, 0xf7, 0xf0, 0xff, 0xf0, 0xf7, 0xf0, 0xe7, 0xf8, 0x0f, 0xfc, 0x1f, 0x7c, 0x1f};
+#define hand1_width 13
+#define hand1_height 16
+#define hand1_x_hot 12
+#define hand1_y_hot 0
+static unsigned char hand1_bits[] = {
+00, 0x18, 00, 0x1e, 0x80, 0x07, 0xc0, 0x03, 0xe0, 0x01, 0xf0, 0x03, 0xf8, 0x07, 0xfa, 0x03, 0xff, 0x07, 0xfd, 0x07, 0xf0, 0x03, 0xf0, 0x01, 0x29, 00, 0x23, 00, 0x16, 00, 0x0c, 00};
+#define hand1_mask_width 13
+#define hand1_mask_height 16
+#define hand1_mask_x_hot 12
+#define hand1_mask_y_hot 0
+static unsigned char hand1_mask_bits[] = {
+00, 0xdc, 00, 0x1f, 0xc0, 0x0f, 0xe0, 0x07, 0xf0, 0x03, 0xf8, 0x07, 0xfe, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x07, 0xff, 0x03, 0xff, 0x01, 0x7f, 00, 0x3f, 00, 0x1e, 00};
+#define hand2_width 15
+#define hand2_height 14
+#define hand2_x_hot 0
+#define hand2_y_hot 0
+static unsigned char hand2_bits[] = {
+0xfe, 0x01, 0x01, 0x02, 0x7e, 0x04, 0x08, 0x08, 0x70, 0x08, 0x08, 0x08, 0x70, 0x14, 0x08, 0x22, 0x30, 0x41, 0xc0, 0x20, 0x40, 0x12, 0x80, 0x08, 00, 0x05, 00, 0x02};
+#define hand2_mask_width 16
+#define hand2_mask_height 16
+#define hand2_mask_x_hot 0
+#define hand2_mask_y_hot 1
+static unsigned char hand2_mask_bits[] = {
+0xfe, 0x01, 0xff, 0x03, 0xff, 0x07, 0xff, 0x0f, 0xfe, 0x1f, 0xf8, 0x1f, 0xfc, 0x1f, 0xf8, 0x3f, 0xfc, 0x7f, 0xf8, 0xff, 0xf0, 0x7f, 0xe0, 0x3f, 0xc0, 0x1f, 0x80, 0x0f, 00, 0x07, 00, 0x02};
+#define heart_width 15
+#define heart_height 14
+#define heart_x_hot 6
+#define heart_y_hot 8
+static unsigned char heart_bits[] = {
+0x7c, 0x1f, 0xc6, 0x31, 0x83, 0x60, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x03, 0x60, 0x06, 0x30, 0x0c, 0x18, 0x18, 0x0c, 0x30, 0x06, 0x60, 0x03, 0xc0, 0x01};
+#define heart_mask_width 15
+#define heart_mask_height 14
+#define heart_mask_x_hot 6
+#define heart_mask_y_hot 8
+static unsigned char heart_mask_bits[] = {
+0x7c, 0x9f, 0xfe, 0x3f, 0xc7, 0x71, 0x83, 0x60, 0x03, 0x60, 0x03, 0x60, 0x43, 0x61, 0x87, 0x70, 0x0e, 0x38, 0x1c, 0x1c, 0x38, 0x0e, 0xf0, 0x07, 0xe0, 0x03, 0xc0, 0x01};
+#define icon_width 16
+#define icon_height 16
+#define icon_x_hot 8
+#define icon_y_hot 8
+static unsigned char icon_bits[] = {
+0xff, 0xff, 0xab, 0xaa, 0x55, 0xd5, 0xab, 0xaa, 0x05, 0xd0, 0x0b, 0xa0, 0x05, 0xd0, 0x0b, 0xa0, 0x05, 0xd0, 0x0b, 0xa0, 0x05, 0xd0, 0x0b, 0xa0, 0x55, 0xd5, 0xab, 0xaa, 0x55, 0xd5, 0xff, 0xff};
+#define icon_mask_width 16
+#define icon_mask_height 16
+#define icon_mask_x_hot 8
+#define icon_mask_y_hot 8
+static unsigned char icon_mask_bits[] = {
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+#define iron_cross_width 14
+#define iron_cross_height 14
+#define iron_cross_x_hot 7
+#define iron_cross_y_hot 6
+static unsigned char iron_cross_bits[] = {
+0xfe, 0x1f, 0xfc, 0x0f, 0xf9, 0x27, 0xf3, 0x33, 0xe7, 0x39, 0xcf, 0x3c, 0xff, 0x3f, 0xff, 0x3f, 0xcf, 0x3c, 0xe7, 0x39, 0xf3, 0x33, 0xf9, 0x27, 0xfc, 0x0f, 0xfe, 0x1f};
+#define iron_cross_mask_width 16
+#define iron_cross_mask_height 16
+#define iron_cross_mask_x_hot 8
+#define iron_cross_mask_y_hot 7
+static unsigned char iron_cross_mask_bits[] = {
+0xfc, 0x3f, 0xfe, 0x7f, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfe, 0x7f, 0xfc, 0x3f};
+#define left_ptr_width 8
+#define left_ptr_height 14
+#define left_ptr_x_hot 0
+#define left_ptr_y_hot 0
+static unsigned char left_ptr_bits[] = {
+0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff, 0x1f, 0x1b, 0x31, 0x30, 0x60, 0x60};
+#define left_ptr_mask_width 10
+#define left_ptr_mask_height 16
+#define left_ptr_mask_x_hot 1
+#define left_ptr_mask_y_hot 1
+static unsigned char left_ptr_mask_bits[] = {
+0x03, 0xc0, 0x07, 00, 0x0f, 00, 0x1f, 00, 0x3f, 00, 0x7f, 00, 0xff, 00, 0xff, 0x01, 0xff, 0x03, 0xff, 0x03, 0x7f, 00, 0xf7, 00, 0xf3, 00, 0xe0, 0x01, 0xe0, 0x01, 0xc0, 00};
+#define left_side_width 14
+#define left_side_height 13
+#define left_side_x_hot 0
+#define left_side_y_hot 6
+static unsigned char left_side_bits[] = {
+0x03, 00, 0x03, 00, 0x83, 00, 0x43, 00, 0x23, 00, 0x13, 00, 0xfb, 0x3f, 0x13, 00, 0x23, 00, 0x43, 00, 0x83, 00, 0x03, 00, 0x03, 00};
+#define left_side_mask_width 16
+#define left_side_mask_height 15
+#define left_side_mask_x_hot 1
+#define left_side_mask_y_hot 7
+static unsigned char left_side_mask_bits[] = {
+0x0f, 00, 0x0f, 00, 0x0f, 0x03, 0x8f, 0x03, 0xcf, 0x01, 0xef, 00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 00, 0xcf, 0x01, 0x8f, 0x03, 0x0f, 0x03, 0x0f, 00, 0x0f, 00};
+#define left_tee_width 10
+#define left_tee_height 14
+#define left_tee_x_hot 0
+#define left_tee_y_hot 7
+static unsigned char left_tee_bits[] = {
+0x03, 0x10, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0xff, 0x03, 0xff, 0x03, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00};
+#define left_tee_mask_width 12
+#define left_tee_mask_height 16
+#define left_tee_mask_x_hot 1
+#define left_tee_mask_y_hot 8
+static unsigned char left_tee_mask_bits[] = {
+0x0f, 0xc0, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00};
+#define leftbutton_width 16
+#define leftbutton_height 16
+#define leftbutton_x_hot 8
+#define leftbutton_y_hot 8
+static unsigned char leftbutton_bits[] = {
+0x01, 0xc0, 0xfe, 0xbf, 0xfe, 0xbf, 0x22, 0xa2, 0xa2, 0xaa, 0xa2, 0xaa, 0xa2, 0xaa, 0xa2, 0xaa, 0x22, 0xa2, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0x01, 0xc0};
+#define leftbutton_mask_width 15
+#define leftbutton_mask_height 16
+#define leftbutton_mask_x_hot 8
+#define leftbutton_mask_y_hot 8
+static unsigned char leftbutton_mask_bits[] = {
+0xfe, 0xbf, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xfe, 0x3f};
+#define ll_angle_width 10
+#define ll_angle_height 10
+#define ll_angle_x_hot 0
+#define ll_angle_y_hot 9
+static unsigned char ll_angle_bits[] = {
+0x03, 0x10, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0xff, 0x03, 0xff, 0x03};
+#define ll_angle_mask_width 12
+#define ll_angle_mask_height 12
+#define ll_angle_mask_x_hot 1
+#define ll_angle_mask_y_hot 10
+static unsigned char ll_angle_mask_bits[] = {
+0x0f, 0xc0, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f};
+#define lr_angle_width 10
+#define lr_angle_height 10
+#define lr_angle_x_hot 9
+#define lr_angle_y_hot 9
+static unsigned char lr_angle_bits[] = {
+00, 0x13, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 0xff, 0x03, 0xff, 0x03};
+#define lr_angle_mask_width 12
+#define lr_angle_mask_height 12
+#define lr_angle_mask_x_hot 10
+#define lr_angle_mask_y_hot 10
+static unsigned char lr_angle_mask_bits[] = {
+00, 0xcf, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f};
+#define man_width 16
+#define man_height 16
+#define man_x_hot 14
+#define man_y_hot 5
+static unsigned char man_bits[] = {
+0xc0, 0x01, 0x78, 0x0f, 0x40, 0x01, 0x81, 00, 0xc2, 0xe1, 0x24, 0xd2, 0xb8, 0x0e, 0xa0, 0x02, 0x20, 0x02, 0x40, 0x01, 0x20, 0x02, 0x90, 0x04, 0x48, 0x09, 0x28, 0x0a, 0x1e, 0x3c, 0x1f, 0xfc};
+#define man_mask_width 16
+#define man_mask_height 16
+#define man_mask_x_hot 14
+#define man_mask_y_hot 5
+static unsigned char man_mask_bits[] = {
+0xf8, 0x07, 0xfc, 0x0f, 0xfc, 0x1f, 0xc3, 0x41, 0xe7, 0xe3, 0xfe, 0xff, 0xfc, 0xdf, 0xf8, 0x0f, 0xe0, 0x07, 0xe0, 0x03, 0xf0, 0x07, 0xf8, 0x0f, 0xfc, 0x1f, 0x7e, 0x3f, 0x3f, 0xfe, 0x3f, 0xfe};
+#define middlebutton_width 16
+#define middlebutton_height 16
+#define middlebutton_x_hot 8
+#define middlebutton_y_hot 8
+static unsigned char middlebutton_bits[] = {
+0x01, 0xc0, 0xfe, 0xbf, 0xfe, 0xbf, 0x22, 0xa2, 0x2a, 0xaa, 0x2a, 0xaa, 0x2a, 0xaa, 0x2a, 0xaa, 0x22, 0xa2, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0x01, 0xc0};
+#define middlebutton_mask_width 15
+#define middlebutton_mask_height 16
+#define middlebutton_mask_x_hot 8
+#define middlebutton_mask_y_hot 8
+static unsigned char middlebutton_mask_bits[] = {
+0xfe, 0xbf, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xfe, 0x3f};
+#define mouse_width 15
+#define mouse_height 14
+#define mouse_x_hot 4
+#define mouse_y_hot 1
+static unsigned char mouse_bits[] = {
+0xe0, 00, 0x30, 00, 0x60, 00, 0xc0, 00, 0xfe, 0x1f, 0x01, 0x20, 0xcd, 0x6c, 0xcd, 0x6c, 0xcd, 0x6c, 0x01, 0x60, 0x01, 0x60, 0x06, 0x38, 0x18, 0x06, 0xe0, 0x01};
+#define mouse_mask_width 16
+#define mouse_mask_height 16
+#define mouse_mask_x_hot 4
+#define mouse_mask_y_hot 1
+static unsigned char mouse_mask_bits[] = {
+0xf0, 0x01, 0x78, 00, 0xf0, 00, 0xe0, 00, 0xfe, 0x1f, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xef, 0xf8, 0x07, 0xf0, 0x03, 0xe0, 0x01};
+#define pencil_width 11
+#define pencil_height 16
+#define pencil_x_hot 10
+#define pencil_y_hot 15
+static unsigned char pencil_bits[] = {
+0x0e, 0x10, 0x11, 00, 0x31, 00, 0x52, 00, 0x5e, 00, 0x84, 00, 0x88, 00, 0x08, 0x01, 0x10, 0x01, 0x30, 0x02, 0x20, 0x02, 0x40, 0x04, 0x80, 0x07, 00, 0x07, 00, 0x06, 00, 0x04};
+#define pencil_mask_width 13
+#define pencil_mask_height 16
+#define pencil_mask_x_hot 11
+#define pencil_mask_y_hot 15
+static unsigned char pencil_mask_bits[] = {
+0x3f, 0xc0, 0x7f, 00, 0xff, 00, 0xfe, 00, 0xfc, 0x01, 0xfc, 0x01, 0xf8, 0x03, 0xf0, 0x03, 0xf0, 0x07, 0xe0, 0x07, 0xe0, 0x0f, 0xc0, 0x1f, 0x80, 0x1f, 00, 0x1f, 00, 0x1e, 00, 0x1c};
+#define pirate_width 15
+#define pirate_height 16
+#define pirate_x_hot 7
+#define pirate_y_hot 12
+static unsigned char pirate_bits[] = {
+0xe0, 0x01, 0xf0, 0x03, 0xf8, 0x07, 0xcc, 0x0c, 0xcc, 0x0c, 0xf8, 0x07, 0xf0, 0x03, 0xe0, 0x01, 0xe1, 0x21, 0xe1, 0x61, 0xc2, 0x10, 0x1c, 0x0e, 0xe0, 0x01, 0xf8, 0x47, 0x0f, 0x7c, 0x01, 0x20};
+#define pirate_mask_width 16
+#define pirate_mask_height 16
+#define pirate_mask_x_hot 7
+#define pirate_mask_y_hot 12
+static unsigned char pirate_mask_bits[] = {
+0xf0, 0x03, 0xf8, 0x07, 0xfc, 0x0f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfc, 0x0f, 0xf8, 0x07, 0xf1, 0x83, 0xf1, 0xe3, 0xf3, 0xf3, 0xef, 0x39, 0x1e, 0x1e, 0xe0, 0x01, 0xfe, 0xc7, 0xff, 0xff, 0x0f, 0x7c};
+#define plus_width 10
+#define plus_height 10
+#define plus_x_hot 4
+#define plus_y_hot 5
+static unsigned char plus_bits[] = {
+0x30, 0x10, 0x30, 00, 0x30, 00, 0x30, 00, 0xff, 0x03, 0xff, 0x03, 0x30, 00, 0x30, 00, 0x30, 00, 0x30, 00};
+#define plus_mask_width 12
+#define plus_mask_height 12
+#define plus_mask_x_hot 5
+#define plus_mask_y_hot 6
+static unsigned char plus_mask_bits[] = {
+0xf0, 0xc0, 0xf0, 00, 0xf0, 00, 0xf0, 00, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xf0, 00, 0xf0, 00, 0xf0, 00, 0xf0, 00};
+#define question_arrow_width 9
+#define question_arrow_height 15
+#define question_arrow_x_hot 4
+#define question_arrow_y_hot 7
+static unsigned char question_arrow_bits[] = {
+0x7c, 0x10, 0xfe, 00, 0xc7, 0x01, 0x83, 0x01, 0x87, 0x01, 0xc6, 0x01, 0xe0, 00, 0x78, 00, 0x38, 00, 0x28, 00, 0x28, 00, 0xee, 00, 0x6c, 00, 0x38, 00, 0x10, 00};
+#define question_arrow_mask_width 11
+#define question_arrow_mask_height 16
+#define question_arrow_mask_x_hot 5
+#define question_arrow_mask_y_hot 8
+static unsigned char question_arrow_mask_bits[] = {
+0xf8, 0xc0, 0xfc, 0x01, 0xfe, 0x03, 0xff, 0x07, 0x8f, 0x07, 0x9f, 0x07, 0xde, 0x07, 0xfc, 0x03, 0xf8, 0x01, 0xf8, 00, 0xf8, 00, 0xfc, 0x01, 0xfe, 0x03, 0xfc, 0x01, 0xf8, 00, 0x70, 00};
+#define right_ptr_width 8
+#define right_ptr_height 14
+#define right_ptr_x_hot 7
+#define right_ptr_y_hot 0
+static unsigned char right_ptr_bits[] = {
+0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 0xf8, 0xd8, 0x8c, 0x0c, 0x06, 0x06};
+#define right_ptr_mask_width 10
+#define right_ptr_mask_height 16
+#define right_ptr_mask_x_hot 8
+#define right_ptr_mask_y_hot 1
+static unsigned char right_ptr_mask_bits[] = {
+00, 0xc3, 0x80, 0x03, 0xc0, 0x03, 0xe0, 0x03, 0xf0, 0x03, 0xf8, 0x03, 0xfc, 0x03, 0xfe, 0x03, 0xff, 0x03, 0xff, 0x03, 0xf8, 0x03, 0xbc, 0x03, 0x3c, 0x03, 0x1e, 00, 0x1e, 00, 0x0c, 00};
+#define right_side_width 14
+#define right_side_height 13
+#define right_side_x_hot 13
+#define right_side_y_hot 6
+static unsigned char right_side_bits[] = {
+00, 0x30, 00, 0x30, 0x40, 0x30, 0x80, 0x30, 00, 0x31, 00, 0x32, 0xff, 0x37, 00, 0x32, 00, 0x31, 0x80, 0x30, 0x40, 0x30, 00, 0x30, 00, 0x30};
+#define right_side_mask_width 16
+#define right_side_mask_height 15
+#define right_side_mask_x_hot 14
+#define right_side_mask_y_hot 7
+static unsigned char right_side_mask_bits[] = {
+00, 0xf0, 00, 0xf0, 0xc0, 0xf0, 0xc0, 0xf1, 0x80, 0xf3, 00, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 00, 0xf7, 0x80, 0xf3, 0xc0, 0xf1, 0xc0, 0xf0, 00, 0xf0, 00, 0xf0};
+#define right_tee_width 10
+#define right_tee_height 14
+#define right_tee_x_hot 9
+#define right_tee_y_hot 7
+static unsigned char right_tee_bits[] = {
+00, 0x13, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 0xff, 0x03, 0xff, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03};
+#define right_tee_mask_width 12
+#define right_tee_mask_height 16
+#define right_tee_mask_x_hot 10
+#define right_tee_mask_y_hot 8
+static unsigned char right_tee_mask_bits[] = {
+00, 0xcf, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f};
+#define rightbutton_width 16
+#define rightbutton_height 16
+#define rightbutton_x_hot 8
+#define rightbutton_y_hot 8
+static unsigned char rightbutton_bits[] = {
+0x01, 0xc0, 0xfe, 0xbf, 0xfe, 0xbf, 0x22, 0xa2, 0xaa, 0xa2, 0xaa, 0xa2, 0xaa, 0xa2, 0xaa, 0xa2, 0x22, 0xa2, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0xfe, 0xbf, 0x01, 0xc0};
+#define rightbutton_mask_width 15
+#define rightbutton_mask_height 16
+#define rightbutton_mask_x_hot 8
+#define rightbutton_mask_y_hot 8
+static unsigned char rightbutton_mask_bits[] = {
+0xfe, 0xbf, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xfe, 0x3f};
+#define rtl_logo_width 14
+#define rtl_logo_height 14
+#define rtl_logo_x_hot 6
+#define rtl_logo_y_hot 6
+static unsigned char rtl_logo_bits[] = {
+0xff, 0x3f, 0x01, 0x22, 0x01, 0x22, 0x01, 0x22, 0xff, 0x23, 0x11, 0x22, 0x11, 0x22, 0x11, 0x22, 0x11, 0x22, 0xf1, 0x3f, 0x11, 0x20, 0x11, 0x20, 0x11, 0x20, 0xff, 0x3f};
+#define rtl_logo_mask_width 16
+#define rtl_logo_mask_height 16
+#define rtl_logo_mask_x_hot 7
+#define rtl_logo_mask_y_hot 7
+static unsigned char rtl_logo_mask_bits[] = {
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xee, 0xff, 0xef, 0xff, 0xef, 0xff, 0xef, 0x77, 0xee, 0x77, 0xee, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0x77, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+#define sailboat_width 12
+#define sailboat_height 13
+#define sailboat_x_hot 6
+#define sailboat_y_hot -1
+static unsigned char sailboat_bits[] = {
+0x80, 0x10, 0x80, 00, 0xa0, 0x01, 0xa0, 0x01, 0xb0, 0x01, 0xb0, 0x03, 0xb8, 0x03, 0xb8, 0x03, 0xbc, 0x07, 0xbc, 0x07, 0xbe, 0x07, 0xbe, 0x0f, 0x1f, 0x07};
+#define sailboat_mask_width 16
+#define sailboat_mask_height 16
+#define sailboat_mask_x_hot 8
+#define sailboat_mask_y_hot 0
+static unsigned char sailboat_mask_bits[] = {
+00, 0x03, 00, 0x07, 0x80, 0x07, 0xc0, 0x0f, 0xc0, 0x0f, 0xe0, 0x0f, 0xe0, 0x1f, 0xf0, 0x1f, 0xf0, 0x1f, 0xf8, 0x3f, 0xf8, 0x3f, 0xfc, 0x3f, 0xfc, 0xff, 0xfe, 0xff, 0xff, 0x1f, 0xfe, 0x07};
+#define sb_down_arrow_width 7
+#define sb_down_arrow_height 15
+#define sb_down_arrow_x_hot 3
+#define sb_down_arrow_y_hot 15
+static unsigned char sb_down_arrow_bits[] = {
+0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x7f, 0x3e, 0x1c, 0x08};
+#define sb_down_arrow_mask_width 9
+#define sb_down_arrow_mask_height 16
+#define sb_down_arrow_mask_x_hot 4
+#define sb_down_arrow_mask_y_hot 15
+static unsigned char sb_down_arrow_mask_bits[] = {
+0x7c, 0xc0, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0xff, 0x01, 0xff, 0x01, 0xfe, 00, 0x7c, 00, 0x38, 00, 0x10, 00};
+#define sb_h_double_arrow_width 15
+#define sb_h_double_arrow_height 7
+#define sb_h_double_arrow_x_hot 7
+#define sb_h_double_arrow_y_hot 3
+static unsigned char sb_h_double_arrow_bits[] = {
+0x08, 0x08, 0x0c, 0x18, 0xfe, 0x3f, 0x0f, 0x78, 0xfe, 0x3f, 0x0c, 0x18, 0x08, 0x08};
+#define sb_h_double_arrow_mask_width 15
+#define sb_h_double_arrow_mask_height 9
+#define sb_h_double_arrow_mask_x_hot 7
+#define sb_h_double_arrow_mask_y_hot 4
+static unsigned char sb_h_double_arrow_mask_bits[] = {
+0x18, 0x8c, 0x1c, 0x1c, 0xfe, 0x3f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xfe, 0x3f, 0x1c, 0x1c, 0x18, 0x0c};
+#define sb_left_arrow_width 15
+#define sb_left_arrow_height 7
+#define sb_left_arrow_x_hot -1
+#define sb_left_arrow_y_hot 3
+static unsigned char sb_left_arrow_bits[] = {
+0x08, 00, 0x0c, 00, 0xfe, 0x7f, 0x0f, 00, 0xfe, 0x7f, 0x0c, 00, 0x08, 00};
+#define sb_left_arrow_mask_width 16
+#define sb_left_arrow_mask_height 9
+#define sb_left_arrow_mask_x_hot 0
+#define sb_left_arrow_mask_y_hot 4
+static unsigned char sb_left_arrow_mask_bits[] = {
+0x30, 00, 0x38, 00, 0xfc, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xfc, 0xff, 0x38, 00, 0x30, 00};
+#define sb_right_arrow_width 15
+#define sb_right_arrow_height 7
+#define sb_right_arrow_x_hot 15
+#define sb_right_arrow_y_hot 3
+static unsigned char sb_right_arrow_bits[] = {
+00, 0x08, 00, 0x18, 0xff, 0x3f, 00, 0x78, 0xff, 0x3f, 00, 0x18, 00, 0x08};
+#define sb_right_arrow_mask_width 16
+#define sb_right_arrow_mask_height 9
+#define sb_right_arrow_mask_x_hot 15
+#define sb_right_arrow_mask_y_hot 4
+static unsigned char sb_right_arrow_mask_bits[] = {
+00, 0x0c, 00, 0x1c, 0xff, 0x3f, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff, 0x3f, 00, 0x1c, 00, 0x0c};
+#define sb_up_arrow_width 7
+#define sb_up_arrow_height 15
+#define sb_up_arrow_x_hot 3
+#define sb_up_arrow_y_hot -1
+static unsigned char sb_up_arrow_bits[] = {
+0x08, 0x9c, 0x3e, 0x7f, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14};
+#define sb_up_arrow_mask_width 9
+#define sb_up_arrow_mask_height 16
+#define sb_up_arrow_mask_x_hot 4
+#define sb_up_arrow_mask_y_hot 0
+static unsigned char sb_up_arrow_mask_bits[] = {
+0x10, 0xc0, 0x38, 00, 0x7c, 00, 0xfe, 00, 0xff, 0x01, 0xff, 0x01, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00};
+#define sb_v_double_arrow_width 7
+#define sb_v_double_arrow_height 15
+#define sb_v_double_arrow_x_hot 3
+#define sb_v_double_arrow_y_hot 7
+static unsigned char sb_v_double_arrow_bits[] = {
+0x08, 0x9c, 0x3e, 0x7f, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x7f, 0x3e, 0x1c, 0x08};
+#define sb_v_double_arrow_mask_width 9
+#define sb_v_double_arrow_mask_height 15
+#define sb_v_double_arrow_mask_x_hot 4
+#define sb_v_double_arrow_mask_y_hot 7
+static unsigned char sb_v_double_arrow_mask_bits[] = {
+0x38, 0xc0, 0x7c, 00, 0xfe, 00, 0xff, 0x01, 0xff, 0x01, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0x7c, 00, 0xff, 0x01, 0xff, 0x01, 0xfe, 00, 0x7c, 00, 0x38, 00};
+#define shuttle_width 15
+#define shuttle_height 16
+#define shuttle_x_hot 10
+#define shuttle_y_hot 0
+static unsigned char shuttle_bits[] = {
+00, 0x84, 00, 0x0e, 00, 0x1f, 0x80, 0x7b, 0xa0, 0x7b, 0x90, 0x7b, 0x88, 0x7b, 0x88, 0x7b, 0x88, 0x7b, 0x88, 0x7b, 0x8c, 0x7b, 0x8e, 0x7b, 0xbf, 0x7b, 0x18, 0x11, 00, 0x1e, 00, 0x0c};
+#define shuttle_mask_width 16
+#define shuttle_mask_height 16
+#define shuttle_mask_x_hot 11
+#define shuttle_mask_y_hot 0
+static unsigned char shuttle_mask_bits[] = {
+00, 0x1c, 00, 0x3e, 00, 0x7f, 00, 0xff, 0x60, 0xff, 0x70, 0xff, 0x78, 0xff, 0x78, 0xff, 0x78, 0xff, 0x78, 0xff, 0x7c, 0xff, 0x7e, 0xff, 0x7f, 0xff, 0x7e, 0x7f, 0x30, 0x7e, 00, 0x3c};
+#define sizing_width 14
+#define sizing_height 14
+#define sizing_x_hot 7
+#define sizing_y_hot 7
+static unsigned char sizing_bits[] = {
+0xff, 0xc0, 0x01, 00, 0x01, 00, 0x01, 00, 0xf1, 0x03, 0x11, 0x02, 0x11, 0x22, 0x11, 0x22, 0x10, 0x22, 0xf0, 0x23, 00, 0x24, 00, 0x28, 00, 0x30, 0xc0, 0x3f};
+#define sizing_mask_width 16
+#define sizing_mask_height 16
+#define sizing_mask_x_hot 8
+#define sizing_mask_y_hot 8
+static unsigned char sizing_mask_bits[] = {
+0xff, 0x03, 0xff, 0x03, 0xff, 0x03, 0x07, 00, 0xf7, 0x0f, 0xf7, 0x0f, 0xf7, 0xef, 0x77, 0xee, 0x77, 0xee, 0xf7, 0xef, 0xf0, 0xef, 0xf0, 0xff, 00, 0xf8, 0xc0, 0xff, 0xc0, 0xff, 0xc0, 0xff};
+#define spider_width 16
+#define spider_height 16
+#define spider_x_hot 6
+#define spider_y_hot 7
+static unsigned char spider_bits[] = {
+0x04, 0x08, 0x08, 0x04, 0x08, 0x04, 0x10, 0x02, 0x10, 0x02, 0xe1, 0xe1, 0xe6, 0x19, 0xf8, 0x07, 0xf8, 0x07, 0xe6, 0x19, 0xe1, 0xe1, 0x10, 0x02, 0x10, 0x02, 0x08, 0x04, 0x08, 0x04, 0x04, 0x08};
+#define spider_mask_width 16
+#define spider_mask_height 16
+#define spider_mask_x_hot 6
+#define spider_mask_y_hot 7
+static unsigned char spider_mask_bits[] = {
+0x06, 0x18, 0x0c, 0x0c, 0x08, 0x04, 0x18, 0x06, 0xf1, 0x83, 0xf3, 0xf3, 0xf6, 0x3b, 0xfc, 0x0f, 0xfc, 0x07, 0xf6, 0x1f, 0xf3, 0xf3, 0xf1, 0x83, 0x18, 0x02, 0x18, 0x06, 0x0c, 0x0c, 0x06, 0x18};
+#define spraycan_width 11
+#define spraycan_height 16
+#define spraycan_x_hot 9
+#define spraycan_y_hot 2
+static unsigned char spraycan_bits[] = {
+00, 0xe6, 0x80, 00, 0x2c, 0x06, 0x9e, 00, 0x16, 0x06, 0x3f, 00, 0x21, 00, 0x27, 00, 0x25, 00, 0x27, 00, 0x25, 00, 0x27, 00, 0x27, 00, 0x21, 00, 0x21, 00, 0x3f, 00};
+#define spraycan_mask_width 12
+#define spraycan_mask_height 16
+#define spraycan_mask_x_hot 10
+#define spraycan_mask_y_hot 2
+static unsigned char spraycan_mask_bits[] = {
+00, 0x4c, 0x18, 0x0d, 0x7c, 0x0d, 0x7c, 0x0d, 0x7e, 0x0d, 0xff, 00, 0xff, 00, 0xff, 00, 0xff, 00, 0xff, 00, 0xff, 00, 0xff, 00, 0xff, 00, 0xff, 00, 0xff, 00, 0xff, 00};
+#define star_width 15
+#define star_height 16
+#define star_x_hot 7
+#define star_y_hot 7
+static unsigned char star_bits[] = {
+0x80, 0x80, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x20, 0x02, 0x20, 0x02, 0x20, 0x02, 0x9c, 0x1c, 0x03, 0x60, 0x1c, 0x1c, 0x90, 0x04, 0x48, 0x09, 0x24, 0x12, 0x14, 0x14, 0x0c, 0x18, 0x04, 0x10};
+#define star_mask_width 16
+#define star_mask_height 16
+#define star_mask_x_hot 7
+#define star_mask_y_hot 7
+static unsigned char star_mask_bits[] = {
+0x80, 00, 0xc0, 0x01, 0xc0, 0x01, 0x60, 0x03, 0x60, 0x03, 0x30, 0x06, 0x38, 0x1e, 0x9f, 0x7c, 0x03, 0xe0, 0x1f, 0x7c, 0x9c, 0x1c, 0xcc, 0x19, 0x66, 0x33, 0x36, 0x36, 0x1e, 0x3c, 0x0e, 0x38};
+#define target_width 15
+#define target_height 13
+#define target_x_hot 7
+#define target_y_hot 6
+static unsigned char target_bits[] = {
+0xc0, 0x81, 0xf0, 0x07, 0x38, 0x0e, 0x0c, 0x18, 0x06, 0x30, 0x83, 0x60, 0x43, 0x61, 0x83, 0x60, 0x06, 0x30, 0x0c, 0x18, 0x38, 0x0e, 0xf0, 0x07, 0xc0, 0x01};
+#define target_mask_width 16
+#define target_mask_height 14
+#define target_mask_x_hot 7
+#define target_mask_y_hot 7
+static unsigned char target_mask_bits[] = {
+0xe0, 0x03, 0xf0, 0x07, 0xf8, 0x0f, 0x3c, 0x1e, 0x0e, 0x38, 0x87, 0x70, 0xc3, 0xe1, 0x63, 0xe3, 0xc3, 0xe1, 0x87, 0x70, 0x0e, 0x38, 0x3c, 0x1e, 0xf8, 0x0f, 0xe0, 0x03};
+#define tcross_width 13
+#define tcross_height 13
+#define tcross_x_hot 6
+#define tcross_y_hot 6
+static unsigned char tcross_bits[] = {
+0x40, 0xe0, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0xff, 0x1f, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00};
+#define tcross_mask_width 15
+#define tcross_mask_height 15
+#define tcross_mask_x_hot 7
+#define tcross_mask_y_hot 7
+static unsigned char tcross_mask_bits[] = {
+0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01};
+#define top_left_arrow_width 14
+#define top_left_arrow_height 14
+#define top_left_arrow_x_hot 0
+#define top_left_arrow_y_hot 0
+static unsigned char top_left_arrow_bits[] = {
+0x03, 0xc0, 0x0f, 00, 0x3e, 00, 0xfe, 00, 0xfc, 0x03, 0xfc, 0x0f, 0xf8, 00, 0xf8, 00, 0x30, 0x01, 0x30, 0x02, 0x20, 0x04, 0x20, 0x08, 00, 0x10, 00, 0x20};
+#define top_left_arrow_mask_width 16
+#define top_left_arrow_mask_height 16
+#define top_left_arrow_mask_x_hot 1
+#define top_left_arrow_mask_y_hot 1
+static unsigned char top_left_arrow_mask_bits[] = {
+0x07, 00, 0x1f, 00, 0x7f, 00, 0xfe, 0x01, 0xfe, 0x07, 0xfc, 0x3f, 0xfc, 0x3f, 0xf8, 0x3f, 0xf8, 0x03, 0xf0, 0x07, 0xf0, 0x0e, 0xe0, 0x1c, 0xe0, 0x38, 0xe0, 0x70, 00, 0xe0, 00, 0xc0};
+#define top_left_corner_width 14
+#define top_left_corner_height 14
+#define top_left_corner_x_hot 0
+#define top_left_corner_y_hot 0
+static unsigned char top_left_corner_bits[] = {
+0xff, 0xff, 0xff, 0x3f, 0x03, 00, 0x03, 00, 0x03, 00, 0xe3, 0x0f, 0x63, 00, 0xa3, 00, 0x23, 0x01, 0x23, 0x02, 0x23, 0x04, 0x23, 0x08, 0x03, 00, 0x03, 00};
+#define top_left_corner_mask_width 16
+#define top_left_corner_mask_height 16
+#define top_left_corner_mask_x_hot 1
+#define top_left_corner_mask_y_hot 1
+static unsigned char top_left_corner_mask_bits[] = {
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 00, 0xef, 0x3f, 0xef, 0x3f, 0xef, 0x3f, 0xef, 0x03, 0xef, 0x07, 0xef, 0x0e, 0xef, 0x1c, 0xef, 0x38, 0xef, 0x30, 0x0f, 00, 0x0f, 00};
+#define top_right_corner_width 14
+#define top_right_corner_height 14
+#define top_right_corner_x_hot 13
+#define top_right_corner_y_hot 0
+static unsigned char top_right_corner_bits[] = {
+0xff, 0xff, 0xff, 0x3f, 00, 0x30, 00, 0x30, 00, 0x30, 0xfc, 0x31, 0x80, 0x31, 0x40, 0x31, 0x20, 0x31, 0x10, 0x31, 0x08, 0x31, 0x04, 0x31, 00, 0x30, 00, 0x30};
+#define top_right_corner_mask_width 16
+#define top_right_corner_mask_height 16
+#define top_right_corner_mask_x_hot 14
+#define top_right_corner_mask_y_hot 1
+static unsigned char top_right_corner_mask_bits[] = {
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 00, 0xf0, 0xfc, 0xf7, 0xfc, 0xf7, 0xfc, 0xf7, 0xc0, 0xf7, 0xe0, 0xf7, 0x70, 0xf7, 0x38, 0xf7, 0x1c, 0xf7, 0x0c, 0xf7, 00, 0xf0, 00, 0xf0};
+#define top_side_width 13
+#define top_side_height 14
+#define top_side_x_hot 6
+#define top_side_y_hot 0
+static unsigned char top_side_bits[] = {
+0xff, 0xff, 0xff, 0x1f, 00, 00, 0x40, 00, 0xe0, 00, 0x50, 0x01, 0x48, 0x02, 0x44, 0x04, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00};
+#define top_side_mask_width 15
+#define top_side_mask_height 16
+#define top_side_mask_x_hot 7
+#define top_side_mask_y_hot 1
+static unsigned char top_side_mask_bits[] = {
+0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0xc0, 0x01, 0xe0, 0x03, 0xf0, 0x07, 0xf8, 0x0f, 0xdc, 0x1d, 0xcc, 0x19, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01};
+#define top_tee_width 14
+#define top_tee_height 10
+#define top_tee_x_hot 7
+#define top_tee_y_hot 0
+static unsigned char top_tee_bits[] = {
+0xff, 0xff, 0xff, 0x3f, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00, 0xc0, 00};
+#define top_tee_mask_width 16
+#define top_tee_mask_height 12
+#define top_tee_mask_x_hot 8
+#define top_tee_mask_y_hot 1
+static unsigned char top_tee_mask_bits[] = {
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03};
+#define trek_width 7
+#define trek_height 16
+#define trek_x_hot 3
+#define trek_y_hot 0
+static unsigned char trek_bits[] = {
+0x88, 0x80, 0x1c, 0x3e, 0x7f, 0x77, 0x7f, 0x3e, 0x1c, 0x08, 0x5d, 0x6b, 0x49, 0x41, 0x41, 0x41};
+#define trek_mask_width 9
+#define trek_mask_height 16
+#define trek_mask_x_hot 4
+#define trek_mask_y_hot 0
+static unsigned char trek_mask_bits[] = {
+0x38, 0x40, 0x38, 00, 0x7c, 00, 0xfe, 00, 0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0xfe, 00, 0x7c, 00, 0xba, 00, 0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0xd7, 0x01, 0xd7, 0x01, 0xc7, 0x01};
+#define ul_angle_width 10
+#define ul_angle_height 10
+#define ul_angle_x_hot 0
+#define ul_angle_y_hot 0
+static unsigned char ul_angle_bits[] = {
+0xff, 0xe3, 0xff, 0x03, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00};
+#define ul_angle_mask_width 12
+#define ul_angle_mask_height 12
+#define ul_angle_mask_x_hot 1
+#define ul_angle_mask_y_hot 1
+static unsigned char ul_angle_mask_bits[] = {
+0xff, 0x4f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00};
+#define umbrella_width 14
+#define umbrella_height 14
+#define umbrella_x_hot 7
+#define umbrella_y_hot 2
+static unsigned char umbrella_bits[] = {
+0x88, 0xc4, 0x20, 0x0a, 0xc9, 0x32, 0xf2, 0x09, 0x4c, 0x06, 0x43, 0x18, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 00, 0x40, 0x01, 0x40, 0x01, 0x80, 00};
+#define umbrella_mask_width 16
+#define umbrella_mask_height 16
+#define umbrella_mask_x_hot 8
+#define umbrella_mask_y_hot 2
+static unsigned char umbrella_mask_bits[] = {
+0xe8, 0x76, 0xfb, 0xdf, 0xfd, 0x3f, 0xfe, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xcf, 0x79, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0x80, 0x03};
+#define ur_angle_width 10
+#define ur_angle_height 10
+#define ur_angle_x_hot 9
+#define ur_angle_y_hot 0
+static unsigned char ur_angle_bits[] = {
+0xff, 0xe3, 0xff, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03, 00, 0x03};
+#define ur_angle_mask_width 12
+#define ur_angle_mask_height 12
+#define ur_angle_mask_x_hot 10
+#define ur_angle_mask_y_hot 1
+static unsigned char ur_angle_mask_bits[] = {
+0xff, 0x4f, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f, 00, 0x0f};
+#define watch_width 16
+#define watch_height 16
+#define watch_x_hot 15
+#define watch_y_hot 9
+static unsigned char watch_bits[] = {
+0xf8, 0x07, 0xf8, 0x07, 0xf8, 0x07, 0xfc, 0x0f, 0x86, 0x18, 0x83, 0x30, 0x81, 0xe0, 0xc1, 0xe1, 0xc1, 0xe1, 0x21, 0xe0, 0x13, 0x30, 0x06, 0x18, 0xfc, 0x0f, 0xf8, 0x07, 0xf8, 0x07, 0xf8, 0x07};
+#define watch_mask_width 16
+#define watch_mask_height 16
+#define watch_mask_x_hot 15
+#define watch_mask_y_hot 9
+static unsigned char watch_mask_bits[] = {
+0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f, 0xfe, 0x1f, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0x1f, 0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f};
+#define xterm_width 7
+#define xterm_height 14
+#define xterm_x_hot 3
+#define xterm_y_hot 7
+static unsigned char xterm_bits[] = {
+0xf7, 0x9c, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x77};
+#define xterm_mask_width 9
+#define xterm_mask_height 16
+#define xterm_mask_x_hot 4
+#define xterm_mask_y_hot 8
+static unsigned char xterm_mask_bits[] = {
+0xef, 0x41, 0xff, 0x01, 0xff, 0x01, 0x7c, 00, 0x38, 00, 0x38, 00, 0x38, 00, 0x38, 00, 0x38, 00, 0x38, 00, 0x38, 00, 0x38, 00, 0x7c, 00, 0xff, 0x01, 0xff, 0x01, 0xef, 0x01};
diff -ruN old/gdk/gdk.symbols gtk+/gdk/gdk.symbols
--- old/gdk/gdk.symbols	2005-08-24 05:29:05.000000000 +0200
+++ gtk+/gdk/gdk.symbols	2006-06-13 23:46:23.000000000 +0200
@@ -326,10 +326,10 @@
 #if IN_FILE(__GDK_COLOR_X11_C__)
 gdk_colormap_new
 gdk_colormap_get_type G_GNUC_CONST
+#ifndef GDK_DISABLE_DEPRECATED
 gdk_colormap_change
 gdk_colors_alloc
 gdk_colors_free
-#ifndef GDK_DISABLE_DEPRECATED
 gdk_colormap_get_system_size
 gdk_color_change
 #endif
@@ -530,6 +530,8 @@
 gdk_drawable_ref
 gdk_drawable_unref
 gdk_draw_string
+gdk_draw_text
+gdk_draw_text_wc
 #endif
 gdk_drawable_get_depth
 gdk_drawable_get_display
@@ -553,8 +555,6 @@
 gdk_draw_polygon
 gdk_draw_rectangle
 gdk_draw_segments
-gdk_draw_text
-gdk_draw_text_wc
 gdk_draw_trapezoids
 #endif
 #endif
@@ -806,7 +806,22 @@
 gdk_keymap_get_for_display
 gdk_keymap_lookup_key
 gdk_keymap_translate_keyboard_state
+#ifndef GDK_WINDOWING_DIRECTFB
 gdk_keyval_convert_case
+#endif
+gdk_keyval_from_name
+gdk_keyval_name G_GNUC_CONST
+#endif
+#endif
+
+#if IN_HEADER(__GDK_KEYS_H__)
+#if IN_FILE(__GDK_KEYS_DIRECTFB_C__)
+gdk_keymap_get_direction
+gdk_keymap_get_entries_for_keycode
+gdk_keymap_get_entries_for_keyval
+gdk_keymap_get_for_display
+gdk_keymap_lookup_key
+gdk_keymap_translate_keyboard_state
 gdk_keyval_from_name
 gdk_keyval_name G_GNUC_CONST
 #endif
diff -ruN old/gtk/Makefile.am gtk+/gtk/Makefile.am
--- old/gtk/Makefile.am	2005-10-26 20:13:22.000000000 +0200
+++ gtk+/gtk/Makefile.am	2006-06-13 23:46:23.000000000 +0200
@@ -666,20 +666,23 @@
 libgtk_x11_2_0_la_SOURCES = $(gtk_c_sources)
 libgtk_linux_fb_2_0_la_SOURCES = $(gtk_c_sources)
 libgtk_win32_2_0_la_SOURCES = $(gtk_c_sources)
+libgtk_directfb_2_0_la_SOURCES = $(gtk_c_sources)
 
 libgtk_x11_2_0_la_LDFLAGS = $(libtool_opts)
 libgtk_linux_fb_2_0_la_LDFLAGS = $(libtool_opts)
 libgtk_win32_2_0_la_LDFLAGS = $(libtool_opts)
+libgtk_directfb_2_0_la_LDFLAGS = $(libtool_opts)
 
 libgtk_x11_2_0_la_LIBADD = $(libadd)
 libgtk_linux_fb_2_0_la_LIBADD = $(libadd)
 libgtk_win32_2_0_la_LIBADD = $(libadd) -lole32 -lgdi32
 libgtk_win32_2_0_la_DEPENDENCIES = $(gtk_def) $(gtk_win32_res)
+libgtk_directfb_2_0_la_LIBADD = $(libadd)
 
 if USE_WIN32
 libgtk_target_ldflags = $(gtk_win32_res_ldflag) $(gtk_win32_symbols)
 endif
-EXTRA_LTLIBRARIES = libgtk-x11-2.0.la libgtk-linux-fb-2.0.la libgtk-win32-2.0.la
+EXTRA_LTLIBRARIES = libgtk-x11-2.0.la libgtk-linux-fb-2.0.la libgtk-win32-2.0.la libgtk-directfb-2.0.la
 
 install-exec-hook: 
 if DISABLE_EXPLICIT_DEPS
diff -ruN old/gtk/gtkplug-stub.c gtk+/gtk/gtkplug-stub.c
--- old/gtk/gtkplug-stub.c	2005-07-21 15:26:27.000000000 +0200
+++ gtk+/gtk/gtkplug-stub.c	2006-06-13 23:46:23.000000000 +0200
@@ -25,6 +25,7 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+#include <gtk.h>
 #include "gtkplugprivate.h"
 
 GdkNativeWindow
diff -ruN old/gtk/gtksocket-stub.c gtk+/gtk/gtksocket-stub.c
--- old/gtk/gtksocket-stub.c	2005-07-21 15:26:27.000000000 +0200
+++ gtk+/gtk/gtksocket-stub.c	2006-06-13 23:46:23.000000000 +0200
@@ -25,6 +25,7 @@
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
+#include <gtk.h>
 #include "gtksocketprivate.h"
 
 GdkNativeWindow
