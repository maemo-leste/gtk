Index: gtk/gtk/gtkrange.c
===================================================================
--- gtk.orig/gtk/gtkrange.c
+++ gtk/gtk/gtkrange.c
@@ -57,7 +57,8 @@ enum {
   PROP_SHOW_FILL_LEVEL,
   PROP_RESTRICT_TO_FILL_LEVEL,
   PROP_FILL_LEVEL,
-  PROP_ROUND_DIGITS
+  PROP_ROUND_DIGITS,
+  PROP_JUMP_TO_POSITION
 };
 
 enum {
@@ -133,6 +134,8 @@ struct _GtkRangeLayout
   gint *mark_pos;
   gint n_marks;
   gboolean recalc_marks;
+
+  gboolean jump_to_position;
 };
 
 
@@ -476,6 +479,23 @@ gtk_range_class_init (GtkRangeClass *cla
                                                      -1,
                                                      GTK_PARAM_READWRITE));
 
+  /**
+   * GtkRange:jump-to-position:
+   *
+   * Whether to jump to the destined position immediately
+   * instead of moving a number of steps
+   *
+   * Since: maemo 4.0
+   * Stability: Unstable
+   */
+  g_object_class_install_property (gobject_class,
+				   PROP_JUMP_TO_POSITION,
+				   g_param_spec_boolean ("jump-to-position",
+							 P_("Jump to Position"),
+							 P_("Whether to jump to the destined position immediately instead of moving a number of steps"),
+							 FALSE,
+							 GTK_PARAM_READWRITE | G_PARAM_CONSTRUCT));
+
   gtk_widget_class_install_style_property (widget_class,
 					   g_param_spec_int ("slider-width",
 							     P_("Slider Width"),
@@ -664,6 +684,9 @@ gtk_range_set_property (GObject      *ob
     case PROP_ROUND_DIGITS:
       gtk_range_set_round_digits (range, g_value_get_int (value));
       break;
+    case PROP_JUMP_TO_POSITION:
+      gtk_range_set_jump_to_position (range, g_value_get_boolean (value));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -710,6 +733,9 @@ gtk_range_get_property (GObject      *ob
     case PROP_ROUND_DIGITS:
       g_value_set_int (value, gtk_range_get_round_digits (range));
       break;
+    case PROP_JUMP_TO_POSITION:
+      g_value_set_boolean (value, gtk_range_get_jump_to_position (range));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1460,6 +1486,52 @@ gtk_range_get_fill_level (GtkRange *rang
   return range->layout->fill_level;
 }
 
+/**
+ * gtk_range_set_jump_to_position:
+ * @range: A #GtkRange
+ * @jump_to_position: Whether to jump to the position immediately
+ *
+ * Sets whether scrolling through user interaction should
+ * jump directly to the destined position, as opposed to moving
+ * a number of steps towards the destination.
+ *
+ * Since: maemo 4.0
+ * Stability: Unstable
+ **/
+void
+gtk_range_set_jump_to_position (GtkRange *range,
+				gboolean  jump_to_position)
+{
+  g_return_if_fail (GTK_IS_RANGE (range));
+
+  if (jump_to_position != range->layout->jump_to_position)
+    {
+      range->layout->jump_to_position = jump_to_position;
+      g_object_notify (G_OBJECT (range), "jump-to-position");
+    }
+}
+
+/**
+ * gtk_range_get_jump_to_position:
+ * @range: A #GtkRange
+ *
+ * Determines whether the value should jump immediately to the
+ * destined position as opposed to moving a number of steps.
+ * See also gtk_range_set_jump_to_position().
+ *
+ * Return value: %TRUE if @range jumps directly to the destination
+ *
+ * Since: maemo 4.0
+ * Stability: Unstable
+ **/
+gboolean
+gtk_range_get_jump_to_position (GtkRange *range)
+{
+  g_return_val_if_fail (GTK_IS_RANGE (range), FALSE);
+
+  return range->layout->jump_to_position;
+}
+
 static gboolean
 should_invert (GtkRange *range)
 {  
@@ -2340,7 +2412,8 @@ gtk_range_button_press (GtkWidget      *
     }
 
   if (range->layout->mouse_location == MOUSE_TROUGH  &&
-      event->button == page_increment_button)
+      event->button == page_increment_button &&
+      !range->layout->jump_to_position)
     {
       /* this button steps by page increment, as with button 2 on a stepper
        */
@@ -2385,7 +2458,8 @@ gtk_range_button_press (GtkWidget      *
       return TRUE;
     }
   else if ((range->layout->mouse_location == MOUSE_TROUGH &&
-            event->button == warp_button) ||
+	    (event->button == warp_button ||
+	     range->layout->jump_to_position)) ||
            range->layout->mouse_location == MOUSE_SLIDER)
     {
       gboolean need_value_update = FALSE;
@@ -2625,19 +2699,28 @@ gtk_range_motion_notify (GtkWidget
 			 GdkEventMotion *event)
 {
   GtkRange *range;
+  gint x, y;
 
   range = GTK_RANGE (widget);
 
   gdk_event_request_motions (event);
-  
-  range->layout->mouse_x = event->x;
-  range->layout->mouse_y = event->y;
+
+  if (event->window == range->event_window)
+    {
+      x = event->x;
+      y = event->y;
+    }
+  else
+    gdk_window_get_pointer (range->event_window, &x, &y, NULL);
+
+  range->layout->mouse_x = x;
+  range->layout->mouse_y = y;
 
   if (gtk_range_update_mouse_location (range))
     gtk_widget_queue_draw (widget);
 
   if (range->layout->grab_location == MOUSE_SLIDER)
-    update_slider_position (range, event->x, event->y);
+    update_slider_position (range, x, y);
 
   /* We handled the event if the mouse was in the range_rect */
   return range->layout->mouse_location != MOUSE_OUTSIDE;
Index: gtk/gtk/gtkrange.h
===================================================================
--- gtk.orig/gtk/gtkrange.h
+++ gtk/gtk/gtkrange.h
@@ -197,6 +197,9 @@ void               gtk_range_set_round_d
                                                             gint           round_digits);
 gint                gtk_range_get_round_digits             (GtkRange      *range);
 
+void               gtk_range_set_jump_to_position          (GtkRange      *range,
+                                                            gboolean       jump_to_position);
+gboolean           gtk_range_get_jump_to_position          (GtkRange      *range);
 
 /* internal API */
 gdouble            _gtk_range_get_wheel_delta              (GtkRange      *range,
