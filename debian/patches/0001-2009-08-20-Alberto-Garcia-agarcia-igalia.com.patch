From 71b25471293a51f21192044beb688108fd2802b5 Mon Sep 17 00:00:00 2001
From: Alberto Garcia <agarcia@igalia.com>
Date: Thu, 20 Aug 2009 16:02:06 +0000
Subject: [PATCH] 2009-08-20  Alberto Garcia  <agarcia@igalia.com>

	* gdk/gdkcairo.c
	(gdk_cairo_set_source_pixbuf, +clear_surface_cache):
	Cache the cairo surface created from each GdkPixbuf to avoid
	having to repeat the same expensive computation once and again.
	Clear cache every ~150 ms.

	Fixes: NB#131815 (gdk_cairo_set_source_pixbuf() needs to be
	optimized)

Index: leste/gdk/gdkcairo.c
===================================================================
--- leste.orig/gdk/gdkcairo.c
+++ leste/gdk/gdkcairo.c
@@ -173,6 +173,14 @@ gdk_cairo_region (cairo_t         *cr,
 		     boxes[i].y2 - boxes[i].y1);
 }
 
+static gboolean
+clear_surface_cache (GHashTable **hashtable)
+{
+    g_hash_table_destroy (*hashtable);
+    *hashtable = NULL;
+    return FALSE;
+}
+
 /**
  * gdk_cairo_set_source_pixbuf:
  * @cr: a #Cairo context
@@ -204,6 +212,24 @@ gdk_cairo_set_source_pixbuf (cairo_t
   static const cairo_user_data_key_t key;
   cairo_status_t status;
   int j;
+  static GHashTable *surface_cache_table = NULL;
+
+  if (surface_cache_table == NULL)
+    {
+      surface_cache_table = g_hash_table_new_full (g_direct_hash, g_direct_equal,
+                                                   g_object_unref, (GDestroyNotify) cairo_surface_destroy);
+      gdk_threads_add_timeout_full (GDK_PRIORITY_REDRAW + 1, 150, (GSourceFunc) clear_surface_cache,
+                                    &surface_cache_table, NULL);
+    }
+  else
+    {
+      surface = g_hash_table_lookup (surface_cache_table, pixbuf);
+      if (surface)
+        {
+          cairo_set_source_surface (cr, surface, pixbuf_x, pixbuf_y);
+          return;
+        }
+    }
 
   if (n_channels == 3)
     format = CAIRO_FORMAT_RGB24;
@@ -216,6 +242,9 @@ gdk_cairo_set_source_pixbuf (cairo_t
                                                  format,
                                                  width, height, cairo_stride);
 
+  g_hash_table_insert (surface_cache_table, g_object_ref (G_OBJECT (pixbuf)),
+		       cairo_surface_reference (surface));
+
   status = cairo_surface_set_user_data (surface, &key,
                                         cairo_pixels, (cairo_destroy_func_t)g_free);
   if (status != CAIRO_STATUS_SUCCESS)
